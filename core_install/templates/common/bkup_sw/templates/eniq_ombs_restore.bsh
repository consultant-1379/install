#!/usr/bin/bash
# ********************************************************************
# Ericsson Radio Systems AB                                     SCRIPT
# ********************************************************************
#
# (c) Ericsson Radio Systems AB 2023 - All rights reserved.
#
# The copyright to the computer program(s) herein is the property
# of Ericsson Radio Systems AB, Sweden. The programs may be used
# and/or copied only with the written permission from Ericsson Radio
# Systems AB or in accordance with the terms and conditions stipulated
# in the agreement/contract under which the program(s) have been
# supplied.
#
# ********************************************************************
# Name    : eniq_ombs_restore.bsh
# Date    : 14/09/2023
# Revision: \main\21
# Purpose : Main wrapper script handling the restore of ENIQ. It will
#           call all necessary scripts to complete the restore
## Usage  : eniq_ombs_restore.bsh -c <hostname>
#
# ********************************************************************
#
#   Command Section
#
# ********************************************************************
AWK=/usr/bin/awk
BASENAME=/usr/bin/basename
BASH=/usr/bin/bash
BC=/usr/bin/bc
CAT=/usr/bin/cat
CHOWN=/usr/bin/chown
CLEAR=/usr/bin/clear
CP=/usr/bin/cp
CUT=/usr/bin/cut
DATE=/usr/bin/date
DIRNAME=/usr/bin/dirname
ECHO='/usr/bin/echo -e'
EGREP=/usr/bin/egrep
EXPECT=/usr/bin/expect
EXPR=/usr/bin/expr
GREP=/usr/bin/grep
GTAR=/usr/sfw/bin/gtar
GTAR_LINUX=/usr/bin/gtar
GZCAT=/usr/bin/gzcat
GZIP=/usr/bin/gzip
ID=/usr/bin/id
INIT=/usr/sbin/init
IOSTAT=/usr/bin/iostat
KILL=/usr/bin/kill
LS=/usr/bin/ls
MKDIR=/usr/bin/mkdir
MULTIPATH=/usr/sbin/multipath
MV=/usr/bin/mv
NSLOOKUP=/usr/bin/nslookup
PING=/usr/bin/ping
PRINTF=/usr/bin/printf
PS=/usr/bin/ps
PWD=/usr/bin/pwd
RM=/usr/bin/rm
SED=/usr/bin/sed
SORT=/usr/bin/sort
SLEEP=/usr/bin/sleep
SSH=/usr/bin/ssh
SVCADM=/usr/sbin/svcadm
SVCS=/usr/bin/svcs
SYSTEMCTL=/usr/bin/systemctl
TAIL=/usr/bin/tail
TAR=/usr/bin/tar
TEE=/usr/bin/tee
TOUCH=/usr/bin/touch
TR=/usr/bin/tr
UEMCLI=/usr/bin/uemcli
UNAME=/usr/bin/uname
WC=/usr/bin/wc
XARGS=/usr/bin/xargs
PYTHON=/usr/bin/python

####################
#OMBS COMMANDS #####
NBU_ADMIN=/usr/openv/netbackup/bin/admincmd
NBU_BIN=/usr/openv/netbackup/bin
####################



# ********************************************************************
#
#   Functions
#
# ********************************************************************
### Function: abort_script ###
#
#   This will is called if the script is aborted through an error
#   signal sent by the kernel such as CTRL-C or if a serious
#   error is encountered during runtime
#
# Arguments:
#       $1 - Error message from part of program (Not always used)
# Return Values:
#       none
abort_script()
{
_err_time_=`$DATE '+%Y-%b-%d_%H.%M.%S'`

if [ "$1" ]; then
    _err_msg_="${_err_time_} - $1"
else
    _err_msg_="${_err_time_} - ERROR : Script aborted.......\n"
fi

if [ "${LOGFILE}" ]; then
    $ECHO "\e[0;31m\n\n---------------------------------------------------------------------------------------------------------------------\e[0m"
    $ECHO "\e[1;31mERROR : ${_err_msg_} \e[0m" | $TEE -a ${LOGFILE}
    $ECHO "\e[0;31m-------------------------------------------------------------------------------------------------------------------------\e[0m"
else
    $ECHO "\e[0;31m\n\n---------------------------------------------------------------------------------------------------------------------\e[0m"
    $ECHO "\e[1;31mERROR : ${_err_msg_} \e[0m"
    $ECHO "\e[0;31m-------------------------------------------------------------------------------------------------------------------------\e[0m"
fi

if [ -f "${ENIQ_CLIENT_CONFIG_DIR}/restore_stages_started" ];then
    $TOUCH ${ENIQ_CLIENT_CONFIG_DIR}/.restore_stage_failure_${_hostname_}_${_nxt_stage_}
fi

$RM -rf ${SCRIPTHOME}/../etc/ombs_server_info
$RM -rf ${ENIQ_CLIENT_CONFIG_DIR}/stage3_running
$RM -rf ${ENIQ_CLIENT_CONFIG_DIR}/raw_restore_running
$RM -rf ${TEM_DIR}
exit 1

}

### function:add_client_etchosts ###
#
#  Add OMBS server IP and hostname in client /etc/hosts
#
# Arguments:
#       none
# Return Values:
#       none
add_client_etchosts()
{

log_msg -s "Starting to add OMBS server entry in the client $client /etc/hosts" -l ${LOGFILE}

ombs_hostname=`$CAT ${SERVER_DETAILS_INFO_CONF} |$GREP -w OMBS_BACKUP_HOST | $AWK -F '=' '{print $2}'`
ombs_ip=`$CAT ${SERVER_DETAILS_INFO_CONF} |$GREP -w OMBS_IP | $AWK -F '=' '{print $2}'`
local actual_op=$($SSH -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no ${DEFAULT_USER}@${_clientip_} "$GREP -w ${ombs_hostname} /etc/hosts")
local correct_op="${ombs_ip}    ${ombs_hostname}"

if [ -z "${correct_op}" ]; then
    _err_msg_="Failed to fetch OMBS server details"
    abort_script "${_err_msg_}"
fi

if [ -z "${actual_op}" ]; then
    host_add=$($SSH -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no ${DEFAULT_USER}@${_clientip_} "$ECHO ${correct_op} >>/etc/hosts")
else
    host_add=$($SSH -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no ${DEFAULT_USER}@${_clientip_} "$SED 's/${actual_op}/${correct_op}/g' /etc/hosts")
fi

if [ $? -ne 0 ]; then
    log_msg -q -s "Failed to add OMBS server entry due to ${host_add}" -l ${LOGFILE} -w
    _err_msg_="Failed to add OMBS server entry on client $client /etc/hosts" >>${LOGFILE}
    abort_script "${_err_msg_}"
fi

log_msg -s "Added OMBS server entry in the client $client /etc/hosts" -l ${LOGFILE}
}

### Function: ask_for_input ###
#
#   Common function to ask for user input
#   and stores user input in USER_VALUE
#
# Arguments:
#       $1 : User message
# Return Values:
#       none
ask_for_input()
{
_msg_=$*
unset USER_VALUE

while [ 1 ]; do
    log_msg -s  "\nPlease enter ${_msg_}" -l ${LOGFILE} -c 33

    read USER_VALUE

    if [ ! "${USER_VALUE}" ];then
        log_msg -s  "\nPlease enter a valid input" -l ${LOGFILE} -c 31
        continue
    else
        break
    fi
done
}

### Function: check_for_second_run ###
#
#   Check if the second loop of restore needs to be executed or not
#
#
# Arguments:
#       $1 : current stage file of dependent server , $2 : current stage file of the server itself
# Return Values:
#       YES/NO
check_for_second_run()
{
_dependant_file_=$1
_self_file_=$2

if [ -s "${ENIQ_CLIENT_CONFIG_DIR}/${_dependant_file_}" ];then
    _dependant_val_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/${_dependant_file_} |$GREP -v ^#|$TR -d " "`
    if [ ! "${_dependant_val_}" ];then
        _err_msg_="Could not get value from ${ENIQ_CLIENT_CONFIG_DIR}/${_dependant_file_} "
        abort_script
    fi
else
    _err_msg_="${_dependant_file_} file not found "
    abort_script
fi

if [ -s "${ENIQ_CLIENT_CONFIG_DIR}/${_self_file_}" ];then
    _self_val_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/${_self_file_}|$GREP -v ^#|$TR -d " "`
    if [ ! "${_self_val_}" ];then
        _err_msg_="Could not get value from ${ENIQ_CLIENT_CONFIG_DIR}/${_self_file_} "
        abort_script
    fi
    _self_val_seq_=`$CAT -n  ${RESTORE_STAGE_FILE}| $GREP ${_self_val_} |$AWK '{print $1}'`
else
    _self_val_seq_=0
fi

_second_run_mid_stage_val_=`$CAT -n  ${RESTORE_STAGE_FILE}| $GREP ${SECOND_RUN_MID_STAGE} |$AWK '{print $1}'`

if [ "${_self_val_}" == "done" ];then
    SECOND_RUN=NO
    log_msg "Restore has already been completed for $_blade_type_ " -l ${LOGFILE}
elif [ "${_dependant_val_}" == "${SECOND_RUN_LAST_STAGE}" -a ${_self_val_seq_} -ge ${_second_run_mid_stage_val_} ];then
    SECOND_RUN=YES
else
    SECOND_RUN=NO
    log_msg "Restore of ${_dependant_hostname_} is incomplete,cannot proceed with Restore of $_blade_type_ " -l ${LOGFILE}
fi

}

### Function: check_id ###
#
#   Check the effective id of the user is correct
#   If not print error message and exit.
#
# Arguments:
#       $1 : User ID name
# Return Values:
#       none
check_id()
{
_check_id_=`$ID | $AWK -F\( '{print $2}' | $AWK -F\) '{print $1}'`
if [ "${_check_id_}" != "$1" ]; then
    _err_msg_="You must be $1 to execute this script."
    abort_script "${_err_msg_}"
fi
}

### Function: check_run_restore_stages_status ###
#
# Check if restore_stages need to be run or not
#
# Arguments:
#   none
# Return Values:
#   PROC_STATUS and MID_STAGE
check_run_restore_stages_status()
{

if [ -s "${ENIQ_CLIENT_CONFIG_DIR}/pid_${_host_name_}" ];then
    _pid_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/pid_${_host_name_}`
    if [ ! "${_pid_}" ];then
        _err_msg_="Could not get pid value from  ${ENIQ_CLIENT_CONFIG_DIR}/pid_${_host_name_}"
        abort_script "${_err_msg_}"
    fi

    _curr_pid_=`$PS -ef |$GREP ${SCRIPTNAME} | $AWK '{ if($2 == '${_pid_}') print $2;}'`
    if [ "${_pid_}" == "${_curr_pid_}" ];then
        PROC_STATUS=RUNNING
    else
        PROC_STATUS=NOTRUNNING
    fi
else
    PROC_STATUS=NOTRUNNING
fi

if [ -s "${STAGEFILE}" ];then
    _curr_val_=`$CAT ${STAGEFILE} |$GREP -v ^#`
    _current_stg_=`$CAT -n  ${RESTORE_STAGE_FILE}| $GREP -w ${_curr_val_} |$AWK '{print $1}'`
    if [ ! "${_current_stg_}" ];then
        _err_msg_="Could not get _current_stg_ value from  ${RESTORE_STAGE_FILE}"
        abort_script "${_err_msg_}"
    fi
else
    _current_stg_=0
fi

if [ "${_blade_type_}" == "eniq_stats" -o "${_blade_type_}" == "stats_coordinator" ];then
    _mid_stage_=`$CAT -n  ${RESTORE_STAGE_FILE}| $GREP ${CO_MID_STAGE} |$AWK '{print $1}'`
    if [ ! "${_mid_stage_}" ];then
        _err_msg_="Could not get _mid_stage_ value from  ${RESTORE_STAGE_FILE}"
        abort_script "${_err_msg_}"
    fi
else
    _mid_stage_=`$CAT -n  ${RESTORE_STAGE_FILE}| $GREP ${NON_CO_MID_STAGE} |$AWK '{print $1}'`
    if [ ! "${_mid_stage_}" ];then
        _err_msg_="Could not get _mid_stage_ value from  ${RESTORE_STAGE_FILE}"
        abort_script "${_err_msg_}"
    fi
fi

if [ ${_mid_stage_} -gt ${_current_stg_} ];then
    MID_STAGE=HIGHER
else
    if [ ${_mid_stage_} -eq ${_current_stg_} ];then
        MID_STAGE=EQUAL
    else
        MID_STAGE=LOWER
    fi
fi
}

### function: create_token ###
#
# Creates a token for security authentication
#
# Arguments:
#       none
# Return Values:
#       none
create_token()
{
_time_=`$DATE '+%Y%b%d%H%M%S'`
_token_name_=${_host_name_}_bmr_${_time_}

${NBU_BIN}/bpnbat -whoami | $GREP "Web login details:" | $TEE -a ${_logfile_} >>/dev/null 2>&1
_res_1_=`$ECHO ${PIPESTATUS[1]}`
if [ ${_res_1_} -ne 0 ]; then
    ${NBU_BIN}/bpnbat -login -Info ${SCRIPTHOME}/../etc/ombs_server_info -loginType WEB | $TEE -a ${_logfile_} >>/dev/null 2>&1
    _res_2_=`$ECHO ${PIPESTATUS[0]}`
    if [ ${_res_2_} -ne 0 ]; then
        _err_msg_="Failed to perform the WEB login"
        abort_script "${_err_msg_}"
    fi
fi

${NBU_BIN}/nbcertcmd -cleanuptoken | $TEE -a ${_logfile_}  >>/dev/null 2>&1
if [ $? -ne 0 ] ; then
    _err_msg_="Failed to cleanup usage-exhausted and expired tokens"
    abort_script "${_err_msg_}"
fi

${NBU_BIN}/nbcertcmd -createToken -name ${_token_name_} -reissue -host ${_host_name_} | $TEE -a ${_logfile_} >>/dev/null 2>&1
_res_4_=`$ECHO ${PIPESTATUS[0]}`
if [ ${_res_4_} -ne 0 ] ; then
    _err_msg_="Failed to create token "
    abort_script "${_err_msg_}"
fi

}
### Function: e_extract_bmr ###
#
# To extract the bmr config tar file
# Arguments:
#        none
# Return Values:
#         none
e_extract_bmr()
{
insert_header_footer head "Entering restore stage - ${NEXT_STAGE} on ${_hostname_}" ${LOGFILE} -w

_curr_server_type_=`$CAT ${SERVER_TYPE}`
if [ "${_curr_server_type_}" == "ENIQ_Statistics_Multi_Blade" ]; then
    _co_hostname_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details | $GREP -w stats_coordinator | $AWK -F: '{print $1}'`
    if [ ! "${_co_hostname_}" ]; then
        _err_msg_="Could not read value {_co_hostname_} from ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details"
        abort_script "${_err_msg_}"
    fi
else
    _co_hostname_=${_hostname_}
fi

_starttime_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/${_co_hostname_}_server_details.conf |$GREP BACKUP_START_DATE_TIME |$CUT -d "=" -f2`
if [ ! "${_starttime_}" ]; then
    _err_msg_="Could not read value {_starttime_} from ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_server_details.conf"
    abort_script "${_err_msg_}"
fi

_endtime_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/${_co_hostname_}_server_details.conf |$GREP BACKUP_END_DATE_TIME |$CUT -d "=" -f2`
if [ ! "${_endtime_}" ]; then
       _err_msg_="Could not read value {_endtime_} from ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_server_details.conf"
       abort_script "${_err_msg_}"
fi


    _os_version_name_=`$RUN_REM_CMD ${DEFAULT_USER}@${_client_ip_} $UNAME`
    if [ ! "${_os_version_name_}" ]; then
        _err_msg_="Could not get OS version of ${_host_name_}"
        abort_script "{_err_msg_}"
    fi

if [ "${_os_version_name_}" == "Linux" ]; then
    local bmrconfig_path="/.ENIQ_BACKUP/eniq/bkup_sw/bmr_config_data"
    _bmr_config_file_=$(${NBU_BIN}/bplist -C ${_hostname_} -S `hostname` -s ${_starttime_} -e ${_endtime_} -R 1 ${bmrconfig_path}/ 2>>${LOGFILE} | $TAIL -1 | $AWK -F'/' '"$6==tar.gz" {print $6}')
    if [ $? -ne 0 -o -z "${_bmr_config_file_}" ]; then
        _err_msg_="Failed to fetch BMR configuration file"
        abort_script "${_err_msg_}"
    fi
else
    local bmrconfig_path="/usr/openv/netbackup/bin/ombs/bmr/bmr_config_data"
    _bmr_config_file_=$(${NBU_BIN}/bplist -C ${_hostname_} -S `hostname` -s ${_starttime_} -e ${_endtime_} -R 1 ${bmrconfig_path}/ 2>>${LOGFILE} | $TAIL -1 | $AWK -F'/' '"$9==tar.gz" {print $9}')
    if [ $? -ne 0 -o -z "${_bmr_config_file_}" ]; then
        _err_msg_="Failed to fetch BMR configuration file"
        abort_script "$_err_msg_"
    fi
fi

$RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "$LS /tmp/bmr" >>/dev/null 2>&1
if [ $? -eq 0 ]; then
    $RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "$RM -rf /tmp/bmr"
    if [ $? -ne 0 ]; then
        _err_msg_="Could not clean existing bmr folder present at /tmp location"
        abort_script "${_err_msg_}"
    fi
fi

$RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "$LS /tmp/${_bmr_config_file_}"
if [ $? -ne 0 ]; then
    _err_msg_="Could not locate a bmr save config file with in /tmp location on ${_hostname_}"
    abort_script "${_err_msg_}"
fi

$RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "$GTAR_LINUX zxf  /tmp/${_bmr_config_file_} -C /tmp" >/dev/null 2>&1
if [ $? -ne 0 ]; then
    _err_msg_="Failed to unpack bmr save config file on ${_hostname_}"
    abort_script "${_err_msg_}"
else
    log_msg -s "Successfully unzipped ${_bmr_config_file_} file" -l ${LOGFILE} -w
fi

insert_header_footer foot "Successfully completed ${NEXT_STAGE} stage on ${_hostname_}" ${LOGFILE} -w

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: e_extract_bmr_1 ###
#
# To extract the bmr config tar file for solaris 11
# Arguments:
#        none
# Return Values:
#         none
e_extract_bmr_1()
{
insert_header_footer head "Entering restore stage - ${NEXT_STAGE} on ${_hostname_}" ${LOGFILE}

_curr_server_type_=`$CAT ${SERVER_TYPE}`
if [ "${_curr_server_type_}" == "ENIQ_Statistics_Multi_Blade" ]; then
    _co_hostname_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details | $GREP -w stats_coordinator | $AWK -F: '{print $1}'`
    if [ ! "${_co_hostname_}" ]; then
        _err_msg_="Could not read value {_co_hostname_} from ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details"
        abort_script "${_err_msg_}"
    fi
else
    _co_hostname_=${_hostname_}
fi

_starttime_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/${_co_hostname_}_server_details.conf |$GREP BACKUP_START_DATE_TIME |$CUT -d "=" -f2`
if [ ! "${_starttime_}" ]; then
    _err_msg_="Could not read value {_starttime_} from ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_server_details.conf"
    abort_script "${_err_msg_}"
fi

_endtime_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/${_co_hostname_}_server_details.conf |$GREP BACKUP_END_DATE_TIME |$CUT -d "=" -f2`
if [ ! "${_endtime_}" ]; then
    _err_msg_="Could not read value _endtime_ from ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_server_details.conf"
    abort_script "${_err_msg_}"
fi

local bmrconfig_path1="/.ENIQ_BACKUP/eniq/bkup_sw/bmr_config_data"

_bmr_config_file_=$(${NBU_BIN}/bplist -C ${_hostname_} -S `hostname` -s ${_starttime_} -e ${_endtime_} -R 1 ${bmrconfig_path1}/ 2>>${LOGFILE} | $TAIL -1 | $AWK -F'/' '"$6==tar.gz" {print $6}')
if [ $? -ne 0 -o -z "${_bmr_config_file_}" ]; then
    _err_msg_="Failed to fetch BMR configuration file"
    abort_script "${_err_msg_}"
fi

$RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "$LS /var/tmp/bmr" >>/dev/null 2>&1
if [ $? -eq 0 ]; then
    $RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "$RM -rf /var/tmp/bmr"
    if [ $? -ne 0 ]; then
        _err_msg_="Could not clean existing bmr folder present at /var/tmp location"
        abort_script "${_err_msg_}"
    fi
fi

$RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "$LS /var/tmp/${_bmr_config_file_}"
if [ $? -ne 0 ]; then
    _err_msg_="Could not locate a bmr save config file with the extension .gz in /var/tmp location"
    abort_script "${_err_msg_}"
fi

$RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "$GTAR_LINUX zxf  /var/tmp/${_bmr_config_file_} -C /var/tmp"
if [ $? -ne 0 ]; then
    _err_msg_="Failed to unpack bmr save config file"
    abort_script "${_err_msg_}"
else
    log_msg -s "Successfully unzipped ${_bmr_config_file_} file" -l ${LOGFILE} -w
fi


insert_header_footer foot "Successfully completed ${NEXT_STAGE} stage on ${_hostname_}" ${LOGFILE} -w

set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: e_reboot_client ###
#
#   Reboot the eniq client after restore stage 2
#
# Arguments:
#      none
# Return Values:
#       none
e_reboot_client()
{

insert_header_footer head "Entering restore stage - ${NEXT_STAGE} on ${_hostname_}" ${LOGFILE} -w

reboot_client

insert_header_footer foot "Successfully completed ${NEXT_STAGE} stage on ${_hostname_}" ${LOGFILE} -w
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: e_reboot_client_1 ###
#
#   Reboot the eniq client after restore stage 3
#
# Arguments:
#       none
# Return Values:
#       none
e_reboot_client_1()
{
insert_header_footer head "Entering restore stage - ${NEXT_STAGE} on ${_hostname_}" ${LOGFILE} -w

reboot_client

insert_header_footer foot "Successfully completed ${NEXT_STAGE} stage on ${_hostname_}" ${LOGFILE} -w
set_next_stage `$EXPR ${ARRAY_ELEM}+1`

}

### Function: e_reboot_client_2 ###
#
#   Reboot the eniq client after /eniq restore
#
# Arguments:
#       none
# Return Values:
#       none
e_reboot_client_2()
{
insert_header_footer head "Entering restore stage - ${NEXT_STAGE} on ${_hostname_}" ${LOGFILE} -w

reboot_client

insert_header_footer foot "Successfully completed ${NEXT_STAGE} stage on ${_hostname_}" ${LOGFILE} -w
set_next_stage `$EXPR ${ARRAY_ELEM}+1`

}

### Function: e_restore_stage1 ###
#
# Execute restore stage 1 on ENIQ server
# Arguments:
#        none
# Return Values:
#         none
e_restore_stage1()
{
insert_header_footer head "Entering restore stage - ${NEXT_STAGE} on ${_hostname_}" ${LOGFILE}

fetch_details_from_conf_file

if [ "${_os_version_name_}" == "Linux" ] ; then
    $RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "$BASH /tmp/bmr/restore_eniq.bsh -s 1"
    if [ $? -ne 0 ];then
        _err_msg_="Failed to execute restore stage 1"
        abort_script "${_err_msg_}"
    fi
else
    $RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "$BASH /tmp/bmr/bin/restore_sol11_boot.bsh -s 1"
    if [ $? -ne 0 ];then
        _err_msg_="Failed to execute restore stage 1"
        abort_script "${_err_msg_}"
    fi
fi

insert_header_footer foot "Successfully completed ${NEXT_STAGE} stage on ${_hostname_}" ${LOGFILE} -w
set_next_stage `$EXPR ${ARRAY_ELEM}+1`

}

### Function: e_restore_stage2 ###
#
# Execute restore stage 1 on ENIQ server
# Arguments:
#        none
# Return Values:
#         none
e_restore_stage2()
{
insert_header_footer head "Entering restore stage - ${NEXT_STAGE} on ${_hostname_}" ${LOGFILE}


fetch_details_from_conf_file

if [ "${_os_version_name_}" == "Linux" ] ; then
    $RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "$BASH /tmp/bmr/restore_eniq.bsh -s 2"
    if [ $? -ne 0 ];then
        _err_msg_="Failed to execute restore stage 2"
        abort_script "${_err_msg_}"
    fi
else
    $RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "$BASH /tmp/bmr/bin/restore_sol11_boot.bsh -s 2"
    if [ $? -ne 0 ];then
        _err_msg_="Failed to execute restore stage 2"
        abort_script "${_err_msg_}"
    fi
fi


#Code Changes for Eniq Privilege Feature Restore
$RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "$CAT /tmp/root_disk/etc/group | $GREP -w ENIQ_ADMIN_ROLE > /dev/null 2>&1"
if [ $? -eq 0 ]; then
     feature_check=1
        $RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "$PYTHON /tmp/root_disk/ericsson/security/bin/restore_ssh_login.py /tmp/root_disk/etc/group,/tmp/root_disk/etc/ssh/sshd_config"
        if [ $? -ne 0 ];then
                _err_msg_="Unable to execute Enable Root SSH script"
                abort_script "${_err_msg_}"
        else
                log_msg -s "Root SSH Enabled for Eniq Privilege User Support"
        fi
else
        feature_check=0
        log_msg -s "Skipping Enable Root SSH as Eniq Privilege User Support is not enabled" -l ${LOGFILE}
fi


insert_header_footer foot "Successfully completed ${NEXT_STAGE} stage on ${_hostname_}" ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`

}

### Function: e_restore_stage3 ###
#
# Executing restore stage 3 on eniq client
#
# Arguments:
#   none
# Return Values:
#   none
e_restore_stage3()
{

insert_header_footer head "Entering restore stage - ${NEXT_STAGE} on ${_hostname_}" ${LOGFILE}

$RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "/usr/bin/echo 3 > /var/tmp/bmr/eniq_restore_stage " >/dev/null 2>&1
if [ $? -ne 0 ]; then
    _err_msg_="Could not insert value 3 into /var/tmp/bmr/eniq_restore_stage file on ${_hostname_}"
    abort_script "${_err_msg_}"
fi


_curr_server_type_=`$CAT ${SERVER_TYPE}`
if [ "${_curr_server_type_}" == "ENIQ_Statistics_Multi_Blade" ]; then
    _co_hostname_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details | $GREP -w stats_coordinator | $AWK -F: '{print $1}'`
    if [ ! "${_co_hostname_}" ]; then
        _err_msg_="Could not read value {_co_hostname_} from ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details"
        abort_script "${_err_msg_}"
    fi
else
    _co_hostname_=${_hostname_}
fi

_blade_detail_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_server_details.conf |$GREP "CLIENT_SERVER_TYPE" | $AWK -F"=" '{print $2}'`
if [ ! "${_blade_detail_}" ]; then
        _err_msg_="Could not read client server type detail from  ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_server_details.conf"
        abort_script "${_err_msg_}"
fi

if [ "${_storage_type_}" != "fs" -a "${_storage_type_}" != "zfs" ]; then
    _storage_list_count_=1
    SAN_DETAIL_FILE=${CLNT_CONF_DIR}/${_co_hostname_}_san_details

    _san_enc_password_1=`$CAT ${SERVER_DETAILS_INFO_CONF} |$AWK -F 'ADMIN_PASSWORD_1=' '{print $2}'`
    if [ ! "${_san_enc_password_1}" ]; then
        _err_msg_="Could not read ADMIN_PASSWORD_1 from ${SERVER_DETAILS_INFO_CONF}"
        abort_script "${_err_msg_}"
    fi

    password_decryption "${_san_enc_password_1}" _san_password_1_
    _san_password_1_=${_san_password_1_}

    _block_storage_name_1_=`$CAT ${SERVER_DETAILS_INFO_CONF} |$GREP -w SAN_NAME | $CUT -d "=" -f2`
    if [ ! "${_block_storage_name_1_}" ]; then
        _err_msg_="Could not read SAN_NAME from ${SERVER_DETAILS_INFO_CONF}"
        abort_script "${_err_msg_}"
    fi

    _block_storage_username_1_=`$CAT ${SERVER_DETAILS_INFO_CONF} |$GREP -w SAN_USER | $CUT -d "=" -f2`
    if [ ! "${_block_storage_username_1_}" ]; then
        _err_msg_="Could not read SAN_USER from ${SERVER_DETAILS_INFO_CONF}"
        abort_script "${_err_msg_}"
    fi


    _san_type_=`$CAT ${SERVER_DETAILS_INFO_CONF} |$GREP -w SAN_TYPE | $CUT -d "=" -f2`
    if [ "${_san_type_}" == "vnx" ];then	
        _block_storage_ip_spa_1_=`$CAT ${SERVER_DETAILS_INFO_CONF} |$GREP -w SPA_IP | $CUT -d "=" -f2`
        if [ ! "${_block_storage_ip_spa_1_}" ]; then
            _err_msg_="Could not read SPA_IP from ${SERVER_DETAILS_INFO_CONF}"
            abort_script "${_err_msg_}"
        fi

        _block_storage_ip_spb_1_=`$CAT ${SERVER_DETAILS_INFO_CONF} |$GREP -w SPB_IP | $CUT -d "=" -f2`
        if [ ! "${_block_storage_ip_spb_1_}" ]; then
            _err_msg_="Could not read SPB_IP from ${SERVER_DETAILS_INFO_CONF}"
            abort_script "${_err_msg_}"
        fi

        _block_storage_group_name_1_=`$CAT ${SERVER_DETAILS_INFO_CONF} |$GREP -w ENIQ_SG | $CUT -d "=" -f2`
        if [ ! "${_block_storage_group_name_1_}" ]; then
            _err_msg_="Could not read ENIQ_SG from ${SERVER_DETAILS_INFO_CONF}"
            abort_script "${_err_msg_}"
        fi
    else
        _block_storage_ip_spa_1_=`$CAT ${SERVER_DETAILS_INFO_CONF} |$GREP -w SP_IP | $CUT -d "=" -f2`
        if [ ! "${_block_storage_ip_spa_1_}" ]; then
            _err_msg_="Could not read SP_IP from ${SERVER_DETAILS_INFO_CONF}"
            abort_script "${_err_msg_}"
        fi

        _consistency_group_=`$CAT ${SERVER_DETAILS_INFO_CONF} |$GREP -w CONSISTENCY_GRP | $CUT -d "=" -f2`
        if [ ! "${_consistency_group_}" ]; then
            _err_msg_="Could not read CONSISTENCY_GRP from ${SERVER_DETAILS_INFO_CONF}"
            abort_script "${_err_msg_}"
        fi
    fi
    
    _storage_disks_=`$CAT ${SERVER_DETAILS_INFO_CONF} |$GREP -w SAN_DISKS | $CUT -d "=" -f2`
    if [ ! "${_storage_disks_}" ]; then
            _err_msg_="Could not read SAN_DISKS from ${SERVER_DETAILS_INFO_CONF}"
            abort_script "${_err_msg_}"
    fi
    
    if [ ${_storage_list_count_} -eq 2 ]; then
        _san_enc_password_2_=`$CAT ${SERVER_DETAILS_INFO_CONF} |$AWK -F 'ADMIN_PASSWORD_2=' '{print $2}'`
        if [ ! "${_san_enc_password_2_}" ]; then
            _err_msg_="Could not read {ADMIN_PASSWORD_2} value from ${SERVER_DETAILS_INFO_CONF}"
            abort_script "${_err_msg_}"
        fi

        password_decryption "${_san_enc_password_2_}" _san_password_2_
        _san_password_2_=${_san_password_2_}

        _block_storage_name_2_=`iniget BLK_STORAGE_DEV_DETAILS_2 -f ${TEM_DIR}/block_storage.ini_${_hostname_} -v BLK_STORAGE_NAME`
        if [ ! "${_block_storage_name_2_}" ]; then
            _err_msg_="Could not read values from ${TEM_DIR}/block_storage.ini_${_hostname_}"
            abort_script "${_err_msg_}"
        fi

        _block_storage_username_2_=`iniget BLK_STORAGE_DEV_DETAILS_2 -f ${TEM_DIR}/block_storage.ini_${_hostname_} -v BLK_STORAGE_USERNAME`
        if [ ! "${_block_storage_username_2_}" ]; then
            _err_msg_="Could not read values from ${TEM_DIR}/block_storage.ini_${_hostname_}"
            abort_script "${_err_msg_}"
        fi
        
        _block_storage_ip_spa_2_=`iniget BLK_STORAGE_DEV_DETAILS_2 -f ${TEM_DIR}/block_storage.ini_${_hostname_} -v BLK_STORAGE_IP_SPA`
        if [ ! "${_block_storage_ip_spa_2_}" ]; then
            _err_msg_="Could not read values from ${TEM_DIR}/block_storage.ini_${_hostname_}"
            abort_script "${_err_msg_}"
        fi

        if [ "${_san_type_}" == "vnx" ];then
            _block_storage_ip_spb_2_=`iniget BLK_STORAGE_DEV_DETAILS_2 -f ${TEM_DIR}/block_storage.ini_${_hostname_} -v BLK_STORAGE_IP_SPB`
            if [ ! "${_block_storage_ip_spb_2_}" ]; then
                _err_msg_="Could not read values from ${TEM_DIR}/block_storage.ini_${_hostname_}"
                abort_script "${_err_msg_}"
            fi

            _block_storage_group_name_2_=`iniget BLK_STORAGE_DEV_DETAILS_2 -f ${TEM_DIR}/block_storage.ini_${_hostname_} -v BLK_STORAGE_GROUP_NAME`
            if [ ! "${_block_storage_group_name_2_}" ]; then
                _err_msg_="Could not read values from ${TEM_DIR}/block_storage.ini_${_hostname_}"
                abort_script "${_err_msg_}"
            fi
        fi
    fi
fi

# De registering entries from SAN for host if present
if [ "${_san_type_}" != "vnx" ]; then
    _eniq_hostname_=`$CAT ${CLNT_CONF_DIR}/ombs_cfg/server_details | $GREP -i "${_hostname_}" | $AWK -F'::' '{print $2}'`
    if [ ! ${_eniq_hostname_} ]; then
            _err_msg_="Unable to get the Host name from ${CLNT_CONF_DIR}/ombs_cfg/server_details"
            abort_script "${_err_msg_}" 
    fi

    #Identify the Host ID & Accessible LUNs in order to disconnect the Host from Unity
    host_id=`$UEMCLI -d ${_block_storage_ip_spa_1_} /remote/host show -filter "ID,Name,Accessible LUNs" | $GREP -C 1 "${_eniq_hostname_}" | $GREP "Host" | $CUT -d '=' -f2`        
    if [ "${host_id}" ];then
        log_msg -q -s "\nStarting to remove entries for ${_eniq_hostname_} from SAN" -l ${LOGFILE}
        
        for i in ${host_id[@]}
        do           
            _luns_=`$UEMCLI -d ${_block_storage_ip_spa_1_} /remote/host show -filter "ID,Name,Accessible LUNs" | $GREP -A 2 "$i" | $GREP "Accessible" | $CUT -d '=' -f2 | $TR -d " "`         
            if [ ! "${_luns_}" ];then
                log_msg -s "Removing Empty Host Entry "$i"..." -l ${LOGFILE}
                 # Removing duplicate host entry if present
                $UEMCLI -d ${_block_storage_ip_spa_1_} /remote/host -id $i delete
                if [ $? -ne 0 ];then
                    _err_msg_="Failed to remove Host Entry $i"
                    abort_script "${_err_msg_}"
                fi
            else
                _err_msg_="The ${_eniq_hostname_} has HOST ID $i with LUNS : "${_luns_}"\n These are recommended to be removed before restore".
                abort_script "${_err_msg_}" 
            
            fi
        done
    fi
fi

if [ "${_curr_server_type_}" == "ENIQ_Statistics_Multi_Blade" ] && [ "${_blade_detail_}" != "stats_engine" ] && [ ${_san_type_} != "vnx" ]; then
    while true; do
        if [ -f ${ENIQ_CLIENT_CONFIG_DIR}/raw_restore_running ]; then
            log_msg -s  "RAW Restore is in Progress on CO Server, Please wait for some more time...." -l ${LOGFILE} -w
            $SLEEP 60
        else
            if [ -f ${ENIQ_CLIENT_CONFIG_DIR}/stage3_running ]; then
                if [ ${_blade_detail_} == "stats_coordinator" ] ; then 
                    $ECHO ".\c"
                    $SLEEP 5
                elif [ ${_blade_detail_} == "dwh_reader_1" ]; then
                    $ECHO ".\c"
                    $SLEEP 8
                else
                    $ECHO ".\c"
                    $SLEEP 12
                fi
            else
                $TOUCH ${ENIQ_CLIENT_CONFIG_DIR}/stage3_running
                if [ $? -ne 0 ] ; then
                    _err_msg_="Unable to Touch ${ENIQ_CLIENT_CONFIG_DIR}/stage3_running"
                    abort_script "${_err_msg_}"
                fi
                
                expect_stage3
                if [ $? -ne 0 ] ; then
                    _err_msg_="e_restore_stage3 failed"
                    abort_script "${_err_msg_}"
                fi
                
                $RM -rf ${ENIQ_CLIENT_CONFIG_DIR}/stage3_running
                if [ $? -ne 0 ] ; then
                    _err_msg_="Unable to remove ${ENIQ_CLIENT_CONFIG_DIR}/stage3_running"
                    abort_script "${_err_msg_}"
                fi
                break
            fi
        fi
    done
else
    expect_stage3
    if [ $? -ne 0 ] ; then
        _err_msg_="e_restore_stage3 failed"
        abort_script "${_err_msg_}"
    fi
fi

insert_header_footer foot "Successfully completed ${NEXT_STAGE} stage on ${_hostname_}" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`

if [ "${_bladetype_}" != "stats_coordinator" ];then
    if [ "${_bladetype_}" != "eniq_stats" ];then
        stage_3_check
    fi
fi

}

### Function: e_restore_stage4 ###
#
# Executing restore stage 4 on eniq client
#
# Arguments:
#   none
# Return Values:
#   none
e_restore_stage4()
{
insert_header_footer head "Entering restore stage - ${NEXT_STAGE} on ${_hostname_}" ${LOGFILE}

_curr_server_type_=`$CAT ${SERVER_TYPE}`
if [ "${_curr_server_type_}" == "ENIQ_Statistics_Multi_Blade" ]; then
    _co_hostname_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details | $GREP -w stats_coordinator | $AWK -F: '{print $1}'`
    if [ ! "${_co_hostname_}" ]; then
        _err_msg_="Could not read value {_co_hostname_} from ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details"
        abort_script "${_err_msg_}"
    fi
else
    _co_hostname_=${_hostname_}
fi


if [ "${_storage_type_}" != "fs" -a "${_storage_type_}" != "zfs" ]; then
    $RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "$ECHO| ${BLKCLI} --action listluns" > ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_lun_list 
    if [ ! -s "${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_lun_list" ]; then 
        _err_msg_="Could not create ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_lun_list" 
        abort_script "${_err_msg_}"
    fi

    $RM -rf ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_selected_disks
    
    _block_storage_name_1_=`$CAT ${SERVER_DETAILS_INFO_CONF} |$GREP -w SAN_NAME | $CUT -d "=" -f2`
    if [ ! "${_block_storage_name_1_}" ]; then
        _err_msg_="Could not read SAN_NAME from ${SERVER_DETAILS_INFO_CONF}"
        abort_script "${_err_msg_}"
    fi
    
    _san_type_=`$CAT ${SERVER_DETAILS_INFO_CONF} |$GREP -w SAN_TYPE | $CUT -d "=" -f2`
    if [ -z "${_san_type_}" ];then
    _err_msg_="Could not get _san_type_ from ${SERVER_DETAILS_INFO_CONF}"
    abort_script "${_err_msg_}"
    fi
	
    # creating selected_disks file using previous lun_details file which was created in get_lun_details and lun_list which is been 
    # created using blkcli command in eniq. inserting new disk id using lun id 
    for _user_input_ in `$CAT ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_lun_details`;do
        _lun_id_=`$ECHO $_user_input_ | $AWK -F '::' '{print $3}'`
        if [ "${_san_type_}" == "vnx" ];then
            _new_disk_id_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_lun_list| $EGREP -w "$_block_storage_name_1_@$_lun_id_" | $AWK -F ';' '{print $2}'`
        else
            _new_disk_id_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_lun_list| $EGREP -w "$_lun_id_" | $AWK -F ';' '{print $2}'`
        fi
        $ECHO $_user_input_ | $AWK -F'::' -v var="$_new_disk_id_" '{$(NF-1)=var FS $(NF-1);}1' OFS=:: >> ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_selected_disks
        if [  $? -ne 0 ]; then
            _err_msg_="Could not create ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_selected_disks" 
            abort_script "${_err_msg_}"
        fi
    done
    
    while read _line_; do
        _disk_check_=`$ECHO ${_line_} | $AWK -F"::" '{print $4}'`
        
        _mpath_check_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
        if [  $? -ne 0 ]; then
            _err_msg_="Could not find the mpath detail for Disk ID: ${_disk_check_} in ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_selected_disks" 
            abort_script "${_err_msg_}"
        fi
        
    done < ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_selected_disks

    $RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "$RM -rf /tmp/restore_get_disk_info"
    $RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "$MKDIR -p /tmp/restore_get_disk_info"
    if [ $? -ne 0 ]; then
        _err_msg_="Could not create directory /tmp/restore_get_disk_info on ${_hostname_}"
        abort_script "${_err_msg_}"
    fi
    $SCP -p ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_selected_disks ${_clientip_}:${TMP}/restore_get_disk_info/selected_disks 
    if [  $? -ne 0 ]; then
        _err_msg_="Could not copy ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_selected_disks to ${TMP}/restore_get_disk_info on ${_hostname_}" 
        abort_script "${_err_msg_}"
    else
        log_msg -s "Successfully copied ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_selected_disks to ${TMP}/restore_get_disk_info on ${_hostname_}" -l ${LOGFILE} -w 
    fi
    expect_for_stage4
    if [ $? -ne 0 ] ; then
        _err_msg_="e_restore_stage4 failed"
        abort_script "${_err_msg_}"
    fi
else 
    expect_for_stage4
    if [ $? -ne 0 ] ; then
        _err_msg_="e_restore_stage4 failed"
        abort_script "${_err_msg_}"
    fi
fi

if [ ! "${_storage_type_}" ]; then
    $CP ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_selected_disks ${ENIQ_CLIENT_CONFIG_DIR}/selected_disks
fi

insert_header_footer foot "Successfully completed ${NEXT_STAGE} stage on ${_hostname_}" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`


}

### Function: e_restore_stage5 ###
#
# Executing restore stage 5 on eniq client
#
# Arguments:
#   none
# Return Values:
#   none
e_restore_stage5()
{
insert_header_footer head "Entering restore stage - ${NEXT_STAGE} on ${_hostname_}" ${LOGFILE}
$RUN_REM_CMD ${DEFAULT_USER}@${_clientip_}  "$BASH /var/tmp/bmr/restore_eniq.bsh -s 5"
if [ $? -ne 0 ] ; then
    _err_msg_="e_restore_stage5 failed"
    abort_script "${_err_msg_}"
fi

insert_header_footer foot "Successfully completed ${NEXT_STAGE} stage on ${_hostname_}" ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`

}

### Function: e_restore_stage6 ###
#
# Executing restore stage 6 on eniq client
#
# Arguments:
#   none
# Return Values:
#   none
e_restore_stage6()
{
insert_header_footer head "Entering restore stage - ${NEXT_STAGE} on ${_hostname_}" ${LOGFILE}

_os_version_name_=`$RUN_REM_CMD ${DEFAULT_USER}@${_client_ip_} $UNAME -a | $AWK '{print $1}'`
if [ ! "${_os_version_name_}" ]; then
    _err_msg_="Could not get OS version of ${_host_name_}"
    abort_script "${_err_msg_}"
fi

if [ "${_os_version_name_}" == "Linux" ]; then
# Checking NASd & NAS milestone services are active or not
    NASD=NASd.service
    NAS_online=NAS-online.service
    if [ "${_storage_type_}" != "fs" ]; then
    local _count_time=0
        while [ ${_count_time} -lt 5 ] ; do
               _nasd_service_state_test=`$RUN_REM_CMD ${DEFAULT_USER}@${_client_ip_} $SYSTEMCTL show ${NASD} -p ActiveState`
               _nasd_service_state_=`$ECHO $_nasd_service_state_test  | $AWK -F '=' '{print $2}' `
               if [ "${_nasd_service_state_}" != "active" ]; then
                   $RUN_REM_CMD ${DEFAULT_USER}@${_client_ip_} $SYSTEMCTL start ${NASD}
                   if [ ${_count_time} -eq 4 ] ;then
                       _err_msg_="Failed to Start NASd service on ${_hostname_}"
                       abort_script "${_err_msg_}"
                   else
                       log_msg -s  "Starting of NASd service on ${_hostname_} still in progress, Please wait..." -l ${LOGFILE} -w
                       $SLEEP 30
                       let _count_time=_count_time+1
                       continue
                   fi
               fi
               log_msg -s  "NASd service is active on ${_hostname_}" -l ${LOGFILE} -w
               log_msg -s  "Enabling of NASd service on ${_hostname_}" -l ${LOGFILE} -w
               $RUN_REM_CMD ${DEFAULT_USER}@${_client_ip_} $SYSTEMCTL enable ${NASD}
               break
        done

    local _count_time=0
        while [ ${_count_time} -lt 5 ] ; do
               _milestone_service_state_test=`$RUN_REM_CMD ${DEFAULT_USER}@${_client_ip_} $SYSTEMCTL show ${NAS_online} -p ActiveState`
               _milestone_service_state_=`$ECHO $_milestone_service_state_test  | $AWK -F '=' '{print $2}' `
               if [ "${_milestone_service_state_}" != "active" ]; then
                   if [ ${_count_time} -eq 4 ] ;then
                       _err_msg_="Failed to Start Milestone service on ${_hostname_}"
                       abort_script "${_err_msg_}"
                   else
                       log_msg -s  "Starting of milestone service on ${_hostname_} still in progress, Please wait..." -l ${LOGFILE} -w
                       $SLEEP 60
                       let _count_time=_count_time+1
                       continue
                   fi
               fi
               log_msg -s  "Milestone service is active on ${_hostname_}" -l ${LOGFILE} -w
               break
        done
    fi

    $RUN_REM_CMD ${DEFAULT_USER}@${_hostname_} $SYSTEMCTL start autofs
    if [ $? -ne 0 ]; then
        _err_msg_="Failed to start autofs service on ${_hostname_}"
        abort_script "${_err_msg_}"
    else
        log_msg -s "Successfully started  autofs service on ${_hostname_}" -l ${LOGFILE} -w
    fi

    log_msg -s "Changing ownership of /eniq/database on ${_hostname_}" -l ${LOGFILE} -w
    $RUN_REM_CMD ${DEFAULT_USER}@${_hostname_} $CHOWN -R dcuser:dc5000 /eniq/database
    if [ $? -ne 0 ]; then
        _err_msg_="Failed to change ownership of /eniq/database on ${_hostname_}"
        abort_script "${_err_msg_}"
    else
        log_msg -s "Successfully changed ownership of /eniq/database on ${_hostname_}" -l ${LOGFILE} -w
    fi

    log_msg -s "Changing ownership of /eniq/data on ${_hostname_}" -l ${LOGFILE} -w
    $RUN_REM_CMD ${DEFAULT_USER}@${_hostname_} $CHOWN  dcuser:dc5000 /eniq/data
    if [ $? -ne 0 ]; then
        _err_msg_="Failed to change ownership of /eniq/data on ${_hostname_}"
        abort_script "${_err_msg_}"
    else
        log_msg -s "Successfully changed ownership of /eniq/data on ${_hostname_}" -l ${LOGFILE} -w
    fi

$EXPECT <<EOF
set timeout 15000
spawn $RUN_REM_CMD ${DEFAULT_USER}@${_hostname_} "$BASH /var/tmp/bmr/restore_eniq.bsh -s 6 "

expect {
"Database sym links will be recreated." {send "Yes\r";exp_continue}
"ERROR" {send_user "\nERROR!!!\n"; exit 1}
"Restore Stage 6 completed" {send "\r"}
timeout {send_user "\nTIMEOUT!\n"; exit 9}
}
EOF

    if [ $? -ne 0 ] ; then
        _err_msg_="e_restore_stage6 failed"
        abort_script "${_err_msg_}"
    fi

else
    #Checking NASd & NAS milestone services are online or not
    #_storage_type_=`$CAT ${SERVER_DETAILS_INFO_CONF} |$GREP STORAGE_TYPE | $AWK -F '=' '{print $2}'`
    if [ "${_storage_type_}" != "fs" -a "${_storage_type_}" != "zfs" ]; then
    local _count_time=0
         while [ ${_count_time} -lt 5 ] ; do
                _nasd_service_state_=`$RUN_REM_CMD ${DEFAULT_USER}@${_client_ip_} $SVCS -H svc:/storage/NASd | $AWK '{print $1}'`
                if [ "${_nasd_service_state_}" != "online" ]; then
                    $RUN_REM_CMD ${DEFAULT_USER}@${_hostname_} $SVCADM enable svc:/storage/NASd
                    if [ ${_count_time} -eq 4 ] ;then
                        _err_msg_="Failed to Start NASd service on ${_hostname_}"
                        abort_script "${_err_msg_}"
                    else
                        log_msg -s  "Enabling of NASd service on ${_hostname_} still in progress, Please wait..." -l ${LOGFILE} -w
                        $SLEEP 30
                        let _count_time=_count_time+1
                        continue
                    fi
                fi
                log_msg -s  "NASd service is online on ${_hostname_}" -l ${LOGFILE} -w
                break
         done

    local _count_time=0
         while [ ${_count_time} -lt 5 ] ; do
                _milestone_service_state_=`$RUN_REM_CMD ${DEFAULT_USER}@${_client_ip_} $SVCS -H svc:/milestone/NAS-online | $AWK '{print $1}'`
                if [ "${_milestone_service_state_}" != "online" ]; then
                    if [ ${_count_time} -eq 4 ] ;then
                        _err_msg_="Failed to Start Milestone service on ${_hostname_}"
                        abort_script "${_err_msg_}"
                    else
                        log_msg -s  "Enabling of milestone service on ${_hostname_} still in progress, Please wait..." -l ${LOGFILE} -w
                        $SLEEP 60
                        let _count_time=_count_time+1
                        continue
                    fi
                fi
                log_msg -s  "Milestone service is online on ${_hostname_}" -l ${LOGFILE} -w
                break
         done
    fi


    $RUN_REM_CMD ${DEFAULT_USER}@${_hostname_} $SVCADM enable svc:/system/filesystem/autofs
    if [ $? -ne 0 ]; then
        _err_msg_="Failed to start autofs service on ${_hostname_}"
        abort_script "${_err_msg_}"
    else
        log_msg -s "Successfully started  autofs service on ${_hostname_}" -l ${LOGFILE} -w
    fi

    log_msg -s "Changing ownership of /eniq/database on ${_hostname_}" -l ${LOGFILE} -w
    $RUN_REM_CMD ${DEFAULT_USER}@${_hostname_} $CHOWN -R dcuser:dc5000 /eniq/database
    if [ $? -ne 0 ]; then
        _err_msg_="Failed to change ownership of /eniq/database on ${_hostname_}"
        abort_script "${_err_msg_}"
    else
        log_msg -s "Successfully changed ownership of /eniq/database on ${_hostname_}" -l ${LOGFILE} -w
    fi

    log_msg -s "Changing ownership of /eniq/data on ${_hostname_}" -l ${LOGFILE} -w
    $RUN_REM_CMD ${DEFAULT_USER}@${_hostname_} $CHOWN  dcuser:dc5000 /eniq/data
    if [ $? -ne 0 ]; then
        _err_msg_="Failed to change ownership of /eniq/data on ${_hostname_}"
        abort_script "${_err_msg_}"
    else
        log_msg -s "Successfully changed ownership of /eniq/data on ${_hostname_}" -l ${LOGFILE} -w
    fi

$EXPECT <<EOF
set timeout 15000
spawn $RUN_REM_CMD ${DEFAULT_USER}@${_hostname_} "$BASH /var/tmp/bmr/restore_eniq.bsh -s 6 "

expect {
"Database sym links will be recreated." {send "Yes\r";exp_continue}
"ERROR" {send_user "\nERROR!!!\n"; exit 1}
"Restore Stage 6 completed" {send "\r"}
timeout {send_user "\nTIMEOUT!\n"; exit 9}
}
EOF

    if [ $? -ne 0 ] ; then
        _err_msg_="e_restore_stage6 failed"
        abort_script "${_err_msg_}"
    fi
fi

insert_header_footer foot "Successfully completed ${NEXT_STAGE} stage on ${_hostname_}" ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: e_restart_services ###
#
# To disable the ENIQ services across the deployment
#
# Arguments:
#    none
# Return Values:
#     none
e_restart_services()
{
insert_header_footer head "Entering restore stage - ${NEXT_STAGE} on ${_hostname_}" ${LOGFILE}
log_msg -s "Stopping ENIQ services on ${_bladetype_}" -l ${LOGFILE} -w

local _command_="${ENIQ_ADMIN_BIN_DIR}/manage_eniq_services.bsh"

log_msg -s "Starting to run $BASH ${_command_} -a stop -s ALL -N" -l ${LOGFILE} -w
$RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "$BASH ${_command_} -a stop -s ALL -N"
if [ $? -ne 0 ]; then
    _err_msg_="Exiting... Unable to stop services on ${_bladetype_}\n"
    abort_script "${_err_msg_}"
fi

log_msg -s "Successfully stopped ENIQ services on ${_bladetype_}" -l ${LOGFILE} -w

log_msg -s "Starting ENIQ services on ${_bladetype_}" -l ${LOGFILE} -w
log_msg -s "Starting to run $BASH ${_command_} -a start -s ALL -N" -l ${LOGFILE} -w
$RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "$BASH ${_command_} -a start -s ALL -N"
if [ $? -ne 0 ]; then
    _err_msg_="Exiting... Unable to start services on ${_bladetype_}\n"
    abort_script "${_err_msg_}"
fi

$RM -rf ${SCRIPTHOME}/../etc/ombs_server_info

log_msg -s "Successfully started ENIQ services on ${_bladetype_}" -l ${LOGFILE} -w

insert_header_footer foot "Successfully completed ${NEXT_STAGE} stage on ${_hostname_}" ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: expect_for_stage4###
#
# Expecting LUN details
#
# Arguments:
#   none
# Return Values:
#   none
expect_for_stage4()
{

if [ "${_storage_type_}" != "fs" -a "${_storage_type_}" != "zfs" ]; then
    if [ "$_bladetype_" == "eniq_stats" -o "$_bladetype_" == "stats_coordinator" -o "$_bladetype_" == "stats_engine" ]; then
         $EXPECT <<EOF
    set timeout 15000
    spawn $RUN_REM_CMD -t ${DEFAULT_USER}@${_clientip_} "$BASH /var/tmp/bmr/restore_eniq.bsh -s 4"
    expect {
    "All ZFS filesystems will be destroyed" {send "Yes\r" ; exp_continue}
    "All ZFS filesytems will be destroyed" {send "Yes\r" ; exp_continue}
    "All filesystems will be destroyed" {send "Yes\r";exp_continue}
    "Hit enter for" {send "\r";exp_continue}
   "Are you sure you wish to re-create existing ini files with values above" {send "Yes\r";exp_continue} 
    "ERROR" {send_user "\nERROR!!!\n"; exit 1}
    "Restore Stage 4 completed" {send "\r"}
    timeout {send_user "\nTIMEOUT!\n"; exit 9}
    }
EOF

    elif [ "$_bladetype_" == "dwh_reader_1" -o "$_bladetype_" == "dwh_reader_2" ];then
          $EXPECT <<EOF
    set timeout 15000
    spawn $RUN_REM_CMD -t ${DEFAULT_USER}@${_clientip_}  "$BASH /var/tmp/bmr/restore_eniq.bsh -s 4"
    expect {
    "All filesystems will be destroyed" {send "Yes\r";exp_continue}
    "All ZFS filesytems will be destroyed" {send "Yes\r" ; exp_continue}
    "All ZFS filesystems will be destroyed" {send "Yes\r" ; exp_continue}
    "Value must be in the form - dwh_reader_" {send "$_bladetype_\r";exp_continue}
    "Hit enter for" {send "\r";exp_continue}				 
    "Are you sure you wish to re-create existing ini files with values above" {send "Yes\r";exp_continue}
    "ERROR" {send_user "\nERROR!!!\n"; exit 1}
    "Restore Stage 4 completed" {send "\r"}
    timeout {send_user "\nTIMEOUT!\n"; exit 9}
    }
EOF
    fi
else
$EXPECT <<EOF
    set timeout 15000
    spawn $RUN_REM_CMD -t ${DEFAULT_USER}@${_clientip_}  "$BASH /var/tmp/bmr/restore_eniq.bsh -s 4"
    expect {
    "All filesystems will be destroyed" {send "Yes\r";exp_continue}
    "All ZFS filesystems will be destroyed" {send "Yes\r" ; exp_continue}
    "All ZFS filesytems will be destroyed" {send "Yes\r" ; exp_continue}
    "ERROR" {send_user "\nERROR!!!\n"; exit 1}
    "Restore Stage 4 completed" {send "\r"}
    timeout {send_user "\nTIMEOUT!\n"; exit 9}
    }
EOF
fi
}

### Function: expect_stage3###
#
# Expecting SAN details
#
# Arguments:
#   none
# Return Values:
#   none
expect_stage3()
{

if [ "${_storage_type_}" != "fs" -a "${_storage_type_}" != "zfs" ]; then
    if [ "${_san_type_}" != "vnx" ];then
        if [ ${_storage_list_count_} -eq 1 ];then
        

$EXPECT <<EOF >>${LOGFILE} 2>&1
set timeout 3000
spawn $RUN_REM_CMD ${DEFAULT_USER}@${_hostname_} "$BASH /var/tmp/bmr/restore_eniq.bsh -s 3 -N"

expect {
"to listen on"                                                {send "1\r";exp_continue}
"How many SANs are in the deployment?"                        {send "${_storage_list_count_}\r";exp_continue}
"Enter name of SAN 1"                                         {send "${_block_storage_name_1_}\r";exp_continue}
"Enter username of SAN storage admin account for SAN 1"        {send "${_block_storage_username_1_}\r";exp_continue}
"Enter password of SAN storage admin account for SAN 1"        {send -- "${_san_password_1_}\r";exp_continue}
"Enter IP address of SAN storage processor (A) for SAN 1"    {send "${_block_storage_ip_spa_1_}\r";exp_continue}
"Enter Consistency group ID for SAN 1"    {send "${_consistency_group_}\r";exp_continue}
"Enter LUN IDs for SAN 1"  {send "${_storage_disks_}\r";exp_continue}
"Is the information above correct"                            {send "Yes\r";exp_continue}
"ERROR" {send_user "\nERROR!!!\n"; exit 1}
"Restore Stage 3 completed"                                 {send "\r"}
timeout {send_user "\nTIMEOUT!\n"; exit 9}
}
EOF
        else
$EXPECT <<EOF >>${LOGFILE} 2>&1
set timeout 3000
spawn $RUN_REM_CMD ${DEFAULT_USER}@${_hostname_} "$BASH /var/tmp/bmr/restore_eniq.bsh -s 3"

expect {
"to listen on"                                                {send "1\r";exp_continue}
"How many SANs are in the deployment?                        {send "${_storage_list_count_}\r";exp_continue}
"Enter name of SAN 1"                                        {send "${_block_storage_name_1_}\r";exp_continue}
"Enter username of SAN storage admin account for SAN 1"        {send "${_block_storage_username_1_}\r";exp_continue}
"Enter password of SAN storage admin account for SAN 1"        {send -- "${_san_password_1_}\r";exp_continue}
"Enter IP address of SAN storage processor (A) for SAN 1"    {send "${_block_storage_ip_spa_1_}\r";exp_continue}
"Enter Consistency group ID for SAN 1"    {send "${_consistency_group_}\r";exp_continue}
"Enter LUN IDs for SAN 1"  {send "${_storage_disks_}\r";exp_continue}
"Enter name of SAN 2"                                        {send "${_block_storage_name_2_}\r";exp_continue}
"Enter username of SAN storage admin account for SAN 2"        {send "${_block_storage_username_2_}\r";exp_continue}
"Enter password of SAN storage admin account for SAN 2"        {send -- "${_san_password_2_}\r";exp_continue}
"Enter IP address of SAN storage processor (A) for SAN 2"    {send "${_block_storage_ip_spa_2_}\r";exp_continue}
"Enter Consistency group ID for SAN 2"    {send "${_consistency_group_}\r";exp_continue}
"Enter LUN IDs for SAN 2"  {send "${_storage_disks_}\r";exp_continue}
"Is the information above correct"                            {send "Yes\r";exp_continue}
"ERROR" {send_user "\nERROR!!!\n"; exit 1}
"Restore Stage 3 completed"                                 {send "\r"}
timeout {send_user "\nTIMEOUT!\n"; exit 9}
}
EOF
        fi
    elif [ "${_san_type_}" == "vnx" ];then
        if [ ${_storage_list_count_} -eq 1 ];then
$EXPECT <<EOF >>${LOGFILE} 2>&1
set timeout 3000
spawn $RUN_REM_CMD ${DEFAULT_USER}@${_hostname_} "$BASH /var/tmp/bmr/restore_eniq.bsh -s 3 -N"

expect {
"This will register ENIQ to the SAN and import all LUNs"    {send "Yes\r";exp_continue}
"to listen on"                                                {send "1\r";exp_continue}
"How many SANs are in the deployment?"                        {send "${_storage_list_count_}\r";exp_continue}
"Enter name of SAN 1"                                         {send "${_block_storage_name_1_}\r";exp_continue}
"Enter username of SAN storage admin account for SAN 1"        {send "${_block_storage_username_1_}\r";exp_continue}
"Enter password of SAN storage admin account for SAN 1"        {send -- "${_san_password_1_}\r";exp_continue}
"Enter IP address of SAN storage processor (A) for SAN 1"    {send "${_block_storage_ip_spa_1_}\r";exp_continue}
"Enter IP address of SAN storage processor (B) for SAN 1"    {send "$_block_storage_ip_spb_1_\r";exp_continue}
"Enter SAN storage group name for SAN 1"                    {send "${_block_storage_group_name_1_}\r";exp_continue}
"Is the information above correct"                            {send "Yes\r";exp_continue}
"ERROR" {send_user "\nERROR!!!\n"; exit 1}
"Restore Stage 3 completed"                                 {send "\r"}
timeout {send_user "\nTIMEOUT!\n"; exit 9}
}
EOF
        else
$EXPECT <<EOF >>${LOGFILE} 2>&1
set timeout 3000
spawn $RUN_REM_CMD ${DEFAULT_USER}@${_hostname_} "$BASH /var/tmp/bmr/restore_eniq.bsh -s 3"

expect {
"to listen on"                                                {send "1\r";exp_continue}
"How many SANs are in the deployment?"                        {send "${_storage_list_count_}\r";exp_continue}
"Enter name of SAN 1"                                        {send "${_block_storage_name_1_}\r";exp_continue}
"Enter username of SAN storage admin account for SAN 1"        {send "${_block_storage_username_1_}\r";exp_continue}
"Enter password of SAN storage admin account for SAN 1"        {send -- "${_san_password_1_}\r";exp_continue}
"Enter IP address of SAN storage processor (A) for SAN 1"    {send "${_block_storage_ip_spa_1_}\r";exp_continue}
"Enter IP address of SAN storage processor (B) for SAN 1"    {send "${_block_storage_ip_spb_1_}\r";exp_continue}
"Enter SAN storage group name for SAN 1"                    {send "${_block_storage_group_name_1_}\r";exp_continue}
"Enter name of SAN 2"                                        {send "${_block_storage_name_2_}\r";exp_continue}
"Enter username of SAN storage admin account for SAN 2"        {send "${_block_storage_username_2_}\r";exp_continue}
"Enter password of SAN storage admin account for SAN 2"        {send -- "${_san_password_2_}\r";exp_continue}
"Enter IP address of SAN storage processor (A) for SAN 2"    {send "${_block_storage_ip_spa_2_}\r";exp_continue}
"Enter IP address of SAN storage processor (B) for SAN 2"    {send "${_block_storage_ip_spb_2_}\r";exp_continue}
"Enter SAN storage group name for SAN 2"                    {send "${_block_storage_group_name_2_}\r";exp_continue}
"Is the information above correct"                            {send "Yes\r";exp_continue}
"ERROR" {send_user "\nERROR!!!\n"; exit 1}
"Restore Stage 3 completed"                                 {send "\r"}
timeout {send_user "\nTIMEOUT!\n"; exit 9}
}
EOF
        fi
    fi
else
$EXPECT <<EOF
set timeout 3000
spawn $RUN_REM_CMD ${DEFAULT_USER}@${_hostname_} "$BASH /var/tmp/bmr/restore_eniq.bsh -s 3"

expect {
    "Are you sure you wish to continue?" {send "Yes\r";exp_continue}
    "ERROR" {send_user "\nERROR!!!\n"; exit 1}
    "Restore Stage 3 completed"                                 {send "\r"}
timeout {send_user "\nTIMEOUT!\n"; exit 9}
}
EOF

fi
}

### Function: fetch_details_from_conf_file ###
#
# fetch parameters from file
#
# Arguments:
#   none
# Return Values:
#   none
fetch_details_from_conf_file()
{


if [ ! "${_storage_type_}" ]; then
    _san_type_=`$CAT ${SERVER_DETAILS_INFO_CONF} |$GREP -w SAN_TYPE | $CUT -d "=" -f2`
    if [ -z "${_san_type_}" ]; then
        _err_msg_="Could not read value {_san_type_} from ${SERVER_DETAILS_INFO_CONF}"
        abort_script "${_err_msg_}"
    fi
fi
_curr_server_type_=`$CAT ${SERVER_TYPE}`
if [ "${_curr_server_type_}" == "ENIQ_Statistics_Multi_Blade" ]; then
    _co_hostname_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details | $GREP -w stats_coordinator | $AWK -F: '{print $1}'`
    if [ ! "${_co_hostname_}" ]; then
        _err_msg_="Could not read value {_co_hostname_} from ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details"
        abort_script "${_err_msg_}"
    fi
else
    _co_hostname_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details | $AWK -F: '{print $1}'`
    if [ ! "${_co_hostname_}" ]; then
        _err_msg_="Could not read value {_co_hostname_} from ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details"
        abort_script "${_err_msg_}"
    fi
fi

_starttime_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/${_co_hostname_}_server_details.conf |$GREP BACKUP_START_DATE_TIME |$AWK -F "=" '{print $2}'`
if [ ! "${_starttime_}" ]; then
    _err_msg_="Could not read value {_starttime_} from ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_server_details.conf"
    abort_script "${_err_msg_}"
fi

_endtime_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/${_co_hostname_}_server_details.conf |$GREP BACKUP_END_DATE_TIME |$AWK -F "=" '{print $2}'`
if [ ! "${_endtime_}" ]; then
    _err_msg_="Could not read value {_endtime_} from ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_server_details.conf"
    abort_script "${_err_msg_}"
fi


}

get_absolute_path()
{
_dir_=`$DIRNAME $0`
SCRIPTHOME=`cd ${_dir_} 2>/dev/null && pwd || $ECHO ${_dir_}`
SCRIPTNAME=`$BASENAME $0`
}

### Function: get_array_element ###
#
# Get the current array element number
#
# Arguments:
#   none
# Return Values:
#   none
get_array_element()
{
_num_elements_=${#ENIQ_CORE_STAGES[*]}
_array_length_=`${EXPR} ${_num_elements_} - 1`

for (( _elem_=0; _elem_<=${_array_length_}; _elem_++ )); do
    $ECHO ${ENIQ_CORE_STAGES[${_elem_}]} | $GREP -w ${NEXT_STAGE} >> /dev/null 2>&1
    if [ $? -eq 0 ]; then
        ARRAY_ELEM=${_elem_}
        break
    fi
done
}

### Function: get_blade_details ###
#
# Get detail for backup VLAN configuration
#
# Arguments:
#   none
# Return Values:
#   none
get_blade_details()
{
while true
do
    $CLEAR
    log_msg -s  "\nGetting server information for ENIQ CLIENT" -l ${LOGFILE}
    for _server_type_ in ${_server_list_} ; do
        while true
        do
            # Ask for client backup hostname
            while true
            do
                ask_for_input "Client backup hostname of ${_server_type_} server: \n"
                if [ $? -eq 0 ]; then
                    _client_hostname_=${USER_VALUE}
                    break
                fi
            done

            if [ "${_server_type_}" == "eniq_stats" -o "${_server_type_}" == "stats_coordinator" ];then
                ENIQ_CLIENT_CONFIG_DIR=/ericsson/ombsl/eniq_stats_blade/etc/${_client_hostname_}
                if [ ! -d ${ENIQ_CLIENT_CONFIG_DIR} ];then
                    $MKDIR -p ${ENIQ_CLIENT_CONFIG_DIR}
                fi
                SERVER_TYPE=${ENIQ_CLIENT_CONFIG_DIR}/server_type_file
                # Save the user input values
                $ECHO ${_curr_server_type_} > ${SERVER_TYPE}
                
                RAW_CLIENTS_PATH=${SCRIPTHOME}/../raw_clients
                CLIENT_DIR=${RAW_CLIENTS_PATH}/${_client_hostname_}
                CLNT_CONF_DIR=${CLIENT_DIR}/conf
                CLNT_CONF_OMBS_DIR=${CLNT_CONF_DIR}/ombs_cfg

            fi

            #Removing current stage list for the server if already present,assuming that user wants to restart restore
            if [ -s ${ENIQ_CLIENT_CONFIG_DIR}/current_restore_stage_${_client_hostname_} ];then
                $RM ${ENIQ_CLIENT_CONFIG_DIR}/current_restore_stage_${_client_hostname_}
                if [ $? -ne 0 ]; then
                    _err_msg_="Could not remove ${ENIQ_CLIENT_CONFIG_DIR}/current_restore_stage_${_client_hostname_}"
                    abort_script "${_err_msg_}"
                else
                    log_msg -s "Successfully removed ${ENIQ_CLIENT_CONFIG_DIR}/current_restore_stage_${_client_hostname_}" -l ${LOGFILE}
                fi
            fi
            
            # Ask for client ip
            while true
            do
			    
                ask_for_input "Client backup IP of ${_server_type_} server: \n"
                if [ $? -eq 0 ]; then
                    _client_ip_=${USER_VALUE}
                    break
                fi
            done
            
			
            _os_version_name_=`$RUN_REM_CMD ${DEFAULT_USER}@${_client_ip_} $UNAME -a | $AWK '{print $1}'`
            if [ ! "${_os_version_name_}" ]; then
                _err_msg_="Could not get OS version of ${_host_name_}"
                abort_script "${_err_msg_}"
            fi
            
            if [ ${_curr_server_type_} == "ENIQ_Statistics_Rack_Server" ]; then
                if [ "${_os_version_name_}" == "Linux" ]; then
                    _storage_type_="fs"
                else
                    _storage_type_="zfs"
                fi
            fi
            
            SERVER_DETAILS_INFO_CONF="${ENIQ_CLIENT_CONFIG_DIR}/${_client_hostname_}_server_details.conf"
            if [ -s "${SERVER_DETAILS_INFO_CONF}" ];then
                log_msg -s "\nUser input are already present for ${_server_type_} ${_client_hostname_}\n" -l ${LOGFILE} -c 33
                $CAT ${SERVER_DETAILS_INFO_CONF}
                log_msg -s "\nPlease enter (y/Y) to proceed with the above values or (n/N) to enter new values "  -l ${LOGFILE} -c 33
                user_confirm "(Yy/Nn)"
                if [ "${_response_}" == "NO" ];then
                    $RM -rf ${SERVER_DETAILS_INFO_CONF}
                else
                    break
                fi
            fi

            # Ask for client password
             password_authentication "password for root user of ${_server_type_} server: \nNOTE:: Please ensure that the root password is same as it was used while taking OMBS backup\n" _encrypt_pw_ "root"
             _encrypt_pw_=${_encrypt_pw_}

            if [ "${_server_type_}" == "eniq_stats" -o "${_server_type_}" == "stats_coordinator" ];then
                # Ask for backup start Date and time
                while true
                do
                    log_msg -s  "\nPlease enter backup start Date and time in format: MM/DD/YYYY HH:MM:SS" -l ${LOGFILE} -c 33
                    read _start_date_ _start_time_
                    if [[ $_start_date_ =~ ^[0-9]{2}/[0-9]{2}/[0-9]{4} && $_start_time_ =~ ^([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$ ]] ; then
                        break
                    else
                        log_msg -s  "\nPlease enter a valid input, Date and time  $_start_date_ $_start_time_ is in an invalid format (MM/DD/YYYY HH:MM:SS )" -l ${LOGFILE} -c 31
                        continue
                    fi
                done

                # Ask backup end date and time
                while true; do
                    log_msg -s  "\nPlease enter backup End  Date and time in format: MM/DD/YYYY HH:MM:SS" -l ${LOGFILE} -c 33
                    read _end_date_ _end_time_
                    if [[ $_end_date_ =~ ^[0-9]{2}/[0-9]{2}/[0-9]{4} && $_end_time_ =~ ^([01]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$ ]] ; then
                        break
                    else
                        log_msg -s  "\nPlease enter a valid input, Date and time  $_end_date_ $_end_time_ is in an invalid format (MM/DD/YYYY HH:MM:SS )" -l ${LOGFILE} -c 31
                        continue
                    fi
                done
            fi

                #Ask for ombs backup vlan name
                while true
                do
                    ask_for_input "Backup VLAN hostname for OMBS server"
                    if [ $? -eq 0 ]; then
                        _san_host_=${USER_VALUE}
                        break
                    fi
                done

                #Ask for ombs backup vlan ip
                while true
                do
                    ask_for_input "Backup VLAN IP for OMBS server"
                    if [ $? -eq 0 ]; then
                        _ombs_ip_=${USER_VALUE}
                        break
                    fi
                done

                #Ask for ombs Storage vlan name
                while true
                do
                    ask_for_input "Storage VLAN hostname for OMBS server. [NOTE : If Storage VLAN not configured then enter Service VLAN hostname]"
                    if [ $? -eq 0 ]; then
                        _ombs_storage_host_=${USER_VALUE}
                        break
                    fi
                done

                #Ask for ombs Storage vlan ip
                while true
                do
                    ask_for_input "Storage VLAN IP for OMBS server. [NOTE : If Storage IP not configured then enter Service VLAN IP]"
                    if [ $? -eq 0 ]; then
                        _ombs_storage_ip_=${USER_VALUE}
                        break
                    fi
                done

            if [ ! "${_storage_type_}" ]; then
                # Ask for SAN count
                log_msg -s "\nHow many SAN are deployed for ENIQ client? \n" -c 33
                read _san_count_
                
                # Ask for san type from user 
                while true
                do
                    ask_for_input "type of SAN storage device connected to this ENIQ deployment (e.g. vnx, unity, unityXT)"
                    if [ $? -eq 0 ]; then
                        _san_type_=${USER_VALUE}
                        break
                    fi
                done
                
                # Ask for san name from user 
                while true
                do
                    ask_for_input "name of SAN 1 storage device"
                    if [ $? -eq 0 ]; then
                        _san_name_1_=${USER_VALUE}
                        break
                    fi
                done
                
                # Ask for storage "admin" user name for SAN 1
                while true
                do
                    ask_for_input "username for SAN storage admin account \n"
                    if [ $? -eq 0 ]; then
                        _admin_user_=${USER_VALUE}
                        break
                    fi
                done

                # Ask for storage "admin" user password for SAN 1
                password_authentication "password of SAN storage admin account for SAN 1 ( 1 of 2) for ${_server_type_}: \n" _admin_password_1_ "admin San 1"

                _admin_password_1_=${_admin_password_1_}

                if [ "${_san_type_}" == "vnx" ];then
                    #Ask for Eniq storage group
                    while true
                    do
                        ask_for_input "ENIQ storage group for SAN 1"
                        if [ $? -eq 0 ]; then
                            _storage_grp_1_=${USER_VALUE}
                            break
                        fi
                    done

                    # Ask for SPA IP
                    while true
                    do
                        ask_for_input "ENIQ SPA IP for SAN 1"
                        if [ $? -eq 0 ]; then
                            _spa_1_=${USER_VALUE}
                            break
                        fi
                    done

                    # Ask for SPB IP
                    while true
                    do
                        ask_for_input "ENIQ SPB IP for SAN 1"
                        if [ $? -eq 0 ]; then
                            _spb_1_=${USER_VALUE}
                            break
                        fi
                    done
                    # Ask for OMBS Storage Group
                    while true
                    do
                        ask_for_input "ENIQ storage group for OMBS server"
                        if [ $? -eq 0 ]; then
                            _storage_grp_ombs_=${USER_VALUE}
                            break
                        fi
                    done
                else
                    # Ask for SP IP
                    while true
                    do
                        ask_for_input "ENIQ SPA IP for SAN 1"
                        if [ $? -eq 0 ]; then
                            _sp_1_=${USER_VALUE}
                            break
                        fi
                    done 
		  
                    #Ask for Eniq storage group
                    while true
                    do
                        ask_for_input "ENIQ Consistency group for SAN 1"
                        if [ $? -eq 0 ]; then
                            _consistency_grp_1_=${USER_VALUE}
                            break
                        fi
                    done
                fi

                #Ask for Eniq luns available from storage
                while true
                do
                    ask_for_input "LUN IDs for SAN 1 separated by comma(Example:- For Unity:sv_1,sv_2 and For VNX:1,2)"
                    if [ $? -eq 0 ]; then
                        _san_disks_1_=${USER_VALUE}
                        break
                    fi
                done
                
                if [ ${_san_count_} -eq 2 ];then
                    # Ask for storage "admin" user password for SAN 2
                    password_authentication "password of SAN storage admin account for SAN 2 ( 1 of 2) for ${_server_type_}: \n" _admin_password_2_ "admin San 2"
                    _admin_password_2_=${_admin_password_2_}

                    if [ "${_san_type_}" == "vnx" ];then
                        #Ask for Eniq storage group
                        while true
                        do
                            ask_for_input "ENIQ storage group for SAN 2"
                            if [ $? -eq 0 ]; then
                                _storage_grp_2_=${USER_VALUE}
                                break
                            fi
                        done
                    else    
                        #Ask for Eniq luns available from storage
                        while true
                        do
                            ask_for_input "LUN IDs for SAN 2 separated by comma(Example :sv_1,sv_2)"
                            if [ $? -eq 0 ]; then
                                _san_disks_2_=${USER_VALUE}
                                break
                            fi
                        done
                    fi
                fi
            fi


            $CLEAR
            log_msg -s "\nDisplaying ENIQ client server information for ${_server_type_}" -l ${LOGFILE} -c 36
            _line1_str_="%-70s%-50s%-50s%-50s\n"
            $ECHO "------------------------------------------------------------------\n" > ${_disp_file_}
            $PRINTF "${_line1_str_}" "Client backup hostname of ${_server_type_} server" " : ${_client_hostname_}" >> ${_disp_file_}
            $PRINTF "${_line1_str_}" "Client backup IP of ${_server_type_} server" " : ${_client_ip_}" >> ${_disp_file_}
            $PRINTF "${_line1_str_}" "Client root password (encrypted) of ${_server_type_} server" " : ${_encrypt_pw_}" >> ${_disp_file_}
            if [ "${_server_type_}" == "eniq_stats" -o "${_server_type_}" == "stats_coordinator" ];then
                $PRINTF "${_line1_str_}" "Backup Start date and time of ${_server_type_} server" " : ${_start_date_} ${_start_time_}" >> ${_disp_file_}
                $PRINTF "${_line1_str_}" "Backup End date and time of ${_server_type_} server" " : ${_end_date_} ${_end_time_}" >> ${_disp_file_}

            fi
            $PRINTF "${_line1_str_}" "Client server type" " : ${_server_type_}" >> ${_disp_file_}
																																				   
            $PRINTF "${_line1_str_}" "OMBS Backup VLAN hostname" " : ${_san_host_}"
            $PRINTF "${_line1_str_}" "OMBS Backup VLAN IP" " : ${_ombs_ip_}"
            $PRINTF "${_line1_str_}" "OMBS Storage VLAN hostname" " : ${_ombs_storage_host_}"
            $PRINTF "${_line1_str_}" "OMBS Storage VLAN IP" " : ${_ombs_storage_ip_}"
            if [ ! "${_storage_type_}" ]; then
                $PRINTF "${_line1_str_}" "SAN storage type" " : ${_san_type_}" >> ${_disp_file_}
                $PRINTF "${_line1_str_}" "SAN storage name" " : ${_san_name_1_}" >> ${_disp_file_}
                $PRINTF "${_line1_str_}" "SAN storage user name" " : ${_admin_user_}" >> ${_disp_file_}
                $PRINTF "${_line1_str_}" "SAN ${_san_count_} password (encrypted) of ${_server_type_} server" " : ${_admin_password_1_}" >> ${_disp_file_}
                if [ "${_san_type_}" == "vnx" ]; then
                    $PRINTF "${_line1_str_}" "SAN SPA IP" " : ${_spa_1_}" >> ${_disp_file_}
                    $PRINTF "${_line1_str_}" "SAN SPB IP" " : ${_spb_1_}" >> ${_disp_file_}
                    $PRINTF "${_line1_str_}" "ENIQ storage group" " : ${_storage_grp_1_}" >> ${_disp_file_}
                    $PRINTF "${_line1_str_}" "OMBS storage group" " : ${_storage_grp_ombs_}" >> ${_disp_file_}
                else
                    $PRINTF "${_line1_str_}" "SAN Consistency Group" " : ${_consistency_grp_1_}" >> ${_disp_file_}
                    $PRINTF "${_line1_str_}" "SAN SPA IP" " : ${_sp_1_}" >> ${_disp_file_}
                fi
			  
																																																							 
                $PRINTF "${_line1_str_}" "SAN disks" " : ${_san_disks_1_}" >> ${_disp_file_}
                if [ ${_san_count_} -eq 2 ];then
                    $PRINTF "${_line1_str_}" "SAN ${_san_count_} password (encrypted) of ${_server_type_} server" " : ${_admin_password_2_}" >> ${_disp_file_}
                    if [ "${_san_type_}" == "vnx" ]; then
                        $PRINTF "${_line1_str_}" "SAN 2 storage group" " : ${_storage_grp_2_}" >> ${_disp_file_}
                    else
                        $PRINTF "${_line1_str_}" "SAN 2 disks" " : ${_san_disks_2_}" >> ${_disp_file_}
                    fi
                fi
            fi
            
            if [ "${_storage_type_}" ]; then
                $PRINTF "${_line1_str_}" "Storage Type" " : ${_storage_type_}" >> ${_disp_file_}
            fi
            


            # Displaying data to user
            $CAT ${_disp_file_} | $TEE -a ${LOGFILE}
            user_confirm
            if [ "${_response_}" != "YES" ];then
                log_msg -s  "\nEniq client details will be asked again as user selected NOT to proceed." -l ${LOGFILE}
                continue
            fi

            # Set value in backup conf file
            if [ ! -d ${ENIQ_CLIENT_CONFIG_DIR} ]; then
                #creating directory structure for eniq client configurations
                $MKDIR -p ${ENIQ_CLIENT_CONFIG_DIR}
                if [ $? -ne 0 ];then
                    _err_msg_="Could not create ${ENIQ_CLIENT_CONFIG_DIR} directory"
                    abort_script "${_err_msg_}"
                else
                    log_msg -s  "${ENIQ_CLIENT_CONFIG_DIR} directory successfully created" -l ${LOGFILE}
                fi
            else
                log_msg -q -s  "${ENIQ_CLIENT_CONFIG_DIR} directory already present"  -l ${LOGFILE}
            fi

            set_conf_value CLIENT_HOSTNAME ${_client_hostname_} ${SERVER_DETAILS_INFO_CONF}
            set_conf_value CLIENT_IP ${_client_ip_} ${SERVER_DETAILS_INFO_CONF}
            set_conf_value CLIENT_PASSWORD ${_encrypt_pw_} ${SERVER_DETAILS_INFO_CONF}
            if [ "${_server_type_}" == "eniq_stats" -o "${_server_type_}" == "stats_coordinator" ];then
                set_conf_value BACKUP_START_DATE_TIME "${_start_date_} ${_start_time_}" ${SERVER_DETAILS_INFO_CONF}
                set_conf_value BACKUP_END_DATE_TIME "${_end_date_} ${_end_time_}" ${SERVER_DETAILS_INFO_CONF}

            fi
            set_conf_value CLIENT_SERVER_TYPE ${_server_type_} ${SERVER_DETAILS_INFO_CONF}
            set_conf_value OMBS_BACKUP_HOST ${_san_host_} ${SERVER_DETAILS_INFO_CONF}
            set_conf_value OMBS_IP ${_ombs_ip_} ${SERVER_DETAILS_INFO_CONF}
            set_conf_value SAN_HOST ${_ombs_storage_host_} ${SERVER_DETAILS_INFO_CONF}
            set_conf_value OMBS_STORAGE_IP ${_ombs_storage_ip_} ${SERVER_DETAILS_INFO_CONF}
            if [ ! "${_storage_type_}" ]; then
                set_conf_value SAN_TYPE ${_san_type_} ${SERVER_DETAILS_INFO_CONF}
                set_conf_value SAN_NAME ${_san_name_1_} ${SERVER_DETAILS_INFO_CONF}
                set_conf_value SAN_USER ${_admin_user_} ${SERVER_DETAILS_INFO_CONF}
                set_conf_value ADMIN_PASSWORD_1 ${_admin_password_1_} ${SERVER_DETAILS_INFO_CONF}
                if [ "${_san_type_}" == "vnx" ]; then
                    set_conf_value SPA_IP ${_spa_1_} ${SERVER_DETAILS_INFO_CONF}
                    set_conf_value SPB_IP ${_spb_1_} ${SERVER_DETAILS_INFO_CONF}
                    set_conf_value ENIQ_SG ${_storage_grp_1_} ${SERVER_DETAILS_INFO_CONF}
                    set_conf_value OMBS_SG ${_storage_grp_ombs_} ${SERVER_DETAILS_INFO_CONF}
																						 
                else
                    set_conf_value SP_IP ${_sp_1_} ${SERVER_DETAILS_INFO_CONF}
                    set_conf_value CONSISTENCY_GRP ${_consistency_grp_1_} ${SERVER_DETAILS_INFO_CONF}
                fi

                set_conf_value SAN_DISKS ${_san_disks_1_} ${SERVER_DETAILS_INFO_CONF}
                
                if [ ${_san_count_} -eq 2 ]; then
                    set_conf_value ADMIN_PASSWORD_2 ${_admin_password_2_} ${SERVER_DETAILS_INFO_CONF}
                    if [ "${_san_type_}" == "vnx" ]; then
                        set_conf_value ENIQ_SG ${_storage_grp_2_} ${SERVER_DETAILS_INFO_CONF}
                    else
                        set_conf_value SAN_DISKS ${_san_disks_2_} ${SERVER_DETAILS_INFO_CONF}
                    fi
                fi
            fi

            if [ "${_storage_type_}" ]; then
                set_conf_value STORAGE_TYPE ${_storage_type_} ${SERVER_DETAILS_INFO_CONF}
            fi
            

            
            if [ -s "${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details" ];then
                $GREP ${_client_hostname_} ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details >/dev/null 2>&1
                if [ $? -eq  0 ];then
                    $CAT ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details | $SED -e 's|^[       ]*'${_client_hostname_}'.*|'${_client_hostname_}:${_server_type_}:${_client_ip_}'|' > ${TEM_DIR}/eniq_client_details_tmp.$$.$$
                    if [ $? -ne 0 ];then
                        _err_msg_="Failed to update ${_client_hostname_} server value in ${TEM_DIR}/eniq_client_details_tmp.$$.$$"
                        abort_script "${_err_msg_}"
                    fi
                    $CP -rp ${TEM_DIR}/eniq_client_details_tmp.$$.$$ ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details
                    if [ $? -ne 0 ];then
                        _err_msg_="Failed to save ${_client_hostname_} server value in ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details"
                        abort_script "${_err_msg_}"
                    fi
                else
                    $ECHO "${_client_hostname_}:${_server_type_}:${_client_ip_}" >>${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details
                    if [ $? -ne 0 ];then
                        _err_msg_="Failed to save ${_client_hostname_} server value in ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details"
                        abort_script "${_err_msg_}"
                    fi
                fi
            else
                $ECHO "${_client_hostname_}:${_server_type_}:${_client_ip_}" >>${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details
                if [ $? -ne 0 ];then
                    _err_msg_="Failed to save ${_client_hostname_} server value in ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details"
                    abort_script "${_err_msg_}"
                fi
            fi

        break
        done
     _curr_server_type_=`$CAT ${SERVER_TYPE}`
     if [ "${_curr_server_type_}" == "ENIQ_Statistics_Multi_Blade" ]; then
         _co_hostname_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details | $GREP -w stats_coordinator | $AWK -F: '{print $1}'`
         if [ ! "${_co_hostname_}" ]; then
             _err_msg_="Could not read value {_co_hostname_} from ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details"
             abort_script "${_err_msg_}"
         fi
     else
         _co_hostname_=${_client_hostname_}
     fi
    if [ ! "${_storage_type_}" ]; then
     _san_type_=`$CAT ${SERVER_DETAILS_INFO_CONF} |$GREP -w SAN_TYPE | $CUT -d "=" -f2`
     if [ -z "${_san_type_}" ]; then
        _err_msg_="Could not read value {_san_type_} from ${SERVER_DETAILS_INFO_CONF}"
        abort_script "${_err_msg_}"
     fi
    fi

    #restoring ENIQ shared directory on OMBS

    restore_ombs_cfg ${_server_type_}



    _bkup_opt_=`$CAT ${CLNT_CONF_OMBS_DIR}/eniq_backup.conf |$GREP -w BKUP_OPTION_STR | $AWK -F '=' '{print $2}'`
    if [ -z "${_bkup_opt_}" ]; then
        _err_msg_="Could not read value {_bkup_opt_} from ${CLNT_CONF_OMBS_DIR}/eniq_backup.conf"
        abort_script "${_err_msg_}"
     fi

    #Get the lun details of ENIQ server
    if [ ! "${_storage_type_}" ]; then
        #Restoring /raw_clients directory on OMBS
        restore_conf ${_server_type_}

        #Running prebackup to register ombs on UNITY
        run_prebackup ${_server_type_}

        #Running get_luns_details
        get_lun_details ${_server_type_}
    fi

    done
break
done

}



###### get_lun_details ######
# Get lun details  from user
#
# Arguments:
#       none
# Return Values:
#       none
get_lun_details()
{

if [ -s "${ENIQ_CLIENT_CONFIG_DIR}/${_client_hostname_}_lun_details" ]; then
    log_msg -s "\nLUN  details are already present for ${_server_type_} ${_client_hostname_}\n" -l ${LOGFILE} -c 33
    $CAT ${ENIQ_CLIENT_CONFIG_DIR}/${_client_hostname_}_lun_details
    log_msg -s "\nPlease enter (y/Y) to proceed with the above values or (n/N) to enter new values "  -l ${LOGFILE} -c 33
    user_confirm "(Yy/Nn)"
    if [ "${_response_}" == "NO" ];then
        $RM -rf ${ENIQ_CLIENT_CONFIG_DIR}/${_client_hostname_}_lun_details
    else
        return
    fi
fi

_curr_server_type_=`$CAT ${SERVER_TYPE}`
if [ "${_curr_server_type_}" == "ENIQ_Statistics_Multi_Blade" ]; then
    _co_hostname_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details | $GREP -w stats_coordinator | $AWK -F: '{print $1}'`
    if [ ! "${_co_hostname_}" ]; then
        _err_msg_="Could not read value {_co_hostname_} from ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details"
        abort_script "${_err_msg_}"
    fi
else
    _co_hostname_=${_client_hostname_}
fi

# Initialize variables
CURR_SERVER_TYPE=$1

_client_ip_=`$CAT ${SERVER_DETAILS_INFO_CONF} |$GREP -w CLIENT_IP |$AWK -F= '{print $2}'`
if [ ! "${_client_ip_}" ]; then
    _err_msg_="Could not get Client IP "
    abort_script "${_err_msg_}"
fi

_field1_=0
_field2_=0
_field3_=0
_field4_=0

_san_type_=`$CAT ${SERVER_DETAILS_INFO_CONF} |$GREP -w SAN_TYPE |$CUT -d "=" -f2`
if [ -z "${_san_type_}" ];then
    _err_msg_="Could not get _san_type_ from ${SERVER_DETAILS_INFO_CONF}"
    abort_script "${_err_msg_}"
fi

if [ "${_san_type_}" == "vnx" ]; then
	_SAN_SCRIPT_="${SCRIPTHOME}/vnx_toolbox.bsh"
else
	_SAN_SCRIPT_="${SCRIPTHOME}/unity_toolbox.bsh"
fi

_lun_ids_=`$CAT ${SERVER_DETAILS_INFO_CONF} | $GREP -w "SAN_DISKS" | $AWK -F"=" '{print $2}'`
$BASH ${_SAN_SCRIPT_} -c ${_client_hostname_} -a get_lun_det -f ${SERVER_DETAILS_INFO_CONF} -l ${_lun_ids_} > ${TEM_DIR}/diskfile
    if [ ! -s "${TEM_DIR}/diskfile" -o $? -ne 0 ]; then
        _err_msg_="Execution of ${_SAN_SCRIPT_} failed."
        abort_script "${_err_msg_}"
    fi

$CAT ${TEM_DIR}/diskfile | $AWK -F"@@" '{print $1}' > ${TEM_DIR}/disk_id
    if [ ! -s "${TEM_DIR}/disk_id" ]; then
       _err_msg_="Could not create ${TEM_DIR}/disk_id "
        abort_script "${_err_msg_}"
    fi

_cnt_=1
for _lun_map_det_ in `$CAT ${TEM_DIR}/disk_id`; do
    #Save disk_opt value to the array
    _disk_opt_array_[${_cnt_}]=${_cnt_}

    _len_=`$EXPR "${_disk_opt_array_[${_cnt_}]}" : '.*'`
    if [ ${_len_} -gt ${_field1_} ]; then
        _field1_=${_len_}
    fi

    #Get the LUN ID
    _disk_lun_id_=${_lun_map_det_}

    # Save disk lun id to array
    _disk_lun_id_array_[${_cnt_}]=${_disk_lun_id_}
    _len_=`$EXPR "${_disk_lun_id_array_[${_cnt_}]}" : '.*'`
    if [ ${_len_} -gt ${_field2_} ]; then
        _field2_=${_len_}
    fi

     # Get the disk size
    _size_=`$CAT ${TEM_DIR}/diskfile |$GREP -w ${_lun_map_det_} | $AWK -F"@@" '{print $2}'`
    
    # Converting lun size in GB
    _disk_size_array_[${_cnt_}]=`$ECHO "${_size_} / (1024*1024*1024)" | $BC`
    if [ ! "${_disk_size_array_[${_cnt_}]}" ]; then
        _err_msg_="Could not determine ${_lun_map_det_}:SIZE param "
        abort_script "${_err_msg_}"
    fi

    _len_=`$EXPR "${_disk_size_array_[${_cnt_}]}" : '.*'`
    if [ ${_len_} -gt ${_field3_} ]; then
        _field3_=${_len_}
    fi

    # Get the lun name array
    _lun_name_array_[${_cnt_}]=`$CAT ${TEM_DIR}/diskfile | $GREP -w ${_lun_map_det_} | $AWK -F"@@" '{print $3}'`
    if [ ! "${_lun_name_array_[${_cnt_}]}" ]; then
        _err_msg_="Could not determine ${_lun_map_det_}:Name param "
        abort_script "${_err_msg_}"
    fi

    _len_=`$EXPR "${_lun_name_array_[${_cnt_}]}" : '.*'`
    if [ ${_len_} -gt ${_field4_} ]; then
        _field4_=${_len_}
    fi

    let _cnt_=${_cnt_}+1
done

let _field2_=_field2_+2
let _field3_=_field3_+2
let _field4_=_field4_+2

_line1_str_="%-${_field1_}s%-${_field2_}s%-${_field3_}s%-${_field4_}s\n"
_line2_str_="%-${_field1_}s%-${_field2_}s%-${_field3_}s\n\n"
# _disp_file_ contains the formated disk list
_disp_file_=${TEM_DIR}/disp_file
#_disk_menu_opt_file_ will hold the questions to display on the screen for the different disk types
_disk_menu_opt_file_=${TEM_DIR}/_disk_menu_opt_file_
$RM -f ${_disk_menu_opt_file_}
_menu_opt_list_=""


# Only add IQ main info to the list if I'm a coordinator
if [ "${CURR_SERVER_TYPE}" == "eniq_stats" -o "${CURR_SERVER_TYPE}" == "stats_coordinator" ]; then
    if [ "${_bkup_opt_}" == "FullData" ]; then
            _sys_main_id_=`iniget DWH_SYSTEM_MAIN_1 -f ${CLNT_CONF_OMBS_DIR}/sym_links.ini -v Lun_ID`

        if [ "${_san_type_}" != "vnx" ]; then
            _sys_main_id_="${_sys_main_id_}"
        else
            _sys_main_id_=`$ECHO "${_sys_main_id_}" | $AWK -F "@" '{print $2}'`
        fi
        

            CLNT_CONF_DIR=${CLIENT_DIR}/conf

        $ECHO > ${CLNT_CONF_DIR}/backup_luns_type
        #adding one more column in file lun_type using latest_attach_details
        while read line
        do
            _id_=`$ECHO ${line} | $AWK -F '::' '{print $3}'`
            _sys_main_entry_=`$ECHO ${line} | $EGREP -i "sys" `
            if [[ ${_sys_main_entry_} = *[!\ ]*  ]]; then
                $ECHO ${line} | $SED  "s/$/::IQ_SYS_MAIN/" >> ${CLNT_CONF_DIR}/backup_luns_type
            else
                $ECHO ${line} | $SED  "s/$/::MainDB/" >> ${CLNT_CONF_DIR}/backup_luns_type
            fi
        done < ${CLNT_CONF_DIR}/latest_attach_details
        
        #Building file containing MainDB lun details from backup_luns_type to use it for size comparison
        $CAT ${CLNT_CONF_DIR}/backup_luns_type | $EGREP -w "MainDB" | $AWK -F'::' '{print $2}' | $SORT > ${TEM_DIR}/MainDB_details
        
        count=0
        #Storing MainDB size in an array
        for _lun_info_ in `$CAT ${TEM_DIR}/MainDB_details`; do 
        #converting size in GB from Bytes
            _db_size_=`$ECHO ${_lun_info_}/1024/1024/1024 |$BC`
            _MainDB_size_array_[${count}]=${_db_size_}
            let count=${count}+1
        done
        
        # get IQ_SYS_MAIN size
        _sysmain_size_=`$CAT ${CLNT_CONF_DIR}/backup_luns_type | $EGREP "IQ_SYS_MAIN" | $AWK -F'::' '{print $2}'`
        _sys_size_gb_=`$ECHO ${_sysmain_size_}/1024/1024/1024 |$BC`
    fi
    
    # Add Main DB spaces to menu opt file
    _str1_="MainDB"
    _str2_="MainDB DISK ALLOCATION OPTIONS"
    _str3_="for MainDB database usage"
    _str4_="\\\nSelect Range of disks you want to allocate ${_str3_} \\\nusing the format [n,n,n-n,n...n]\\tE.G. 1,2,3-8,9,10"
    _max_lun_=999999
    $ECHO "${_str1_}@@@${_str2_}@@@${_str3_}@@@${_str4_}@@@${_max_lun_}" >> ${_disk_menu_opt_file_}
    if [ ! "${_menu_opt_list_}" ]; then
        _menu_opt_list_="${_str1_}"
    else
        _menu_opt_list_="${_menu_opt_list_} ${_str1_}"
    fi

    # Add IQ System Main to menu opt file
    _str1_="IQ_SYS_MAIN"
    _str2_="IQ SYS MAIN DISK ALLOCATION OPTIONS"
    _str3_="for IQ SYS MAIN database usage"
    _str4_="\\\nSelect the disks you want to allocate ${_str3_} \\\nusing the format [n,n,n-n,n...n]\\tE.G. 1,2,3-8,9,10"
    _max_lun_=999999
    $ECHO "${_str1_}@@@${_str2_}@@@${_str3_}@@@${_str4_}@@@${_max_lun_}" >> ${_disk_menu_opt_file_}
    if [ ! "${_menu_opt_list_}" ]; then
        _menu_opt_list_="${_str1_}"
    else
        _menu_opt_list_="${_menu_opt_list_} ${_str1_}"
    fi
fi
    _os_version_name_=`$RUN_REM_CMD ${DEFAULT_USER}@${_client_ip_} $UNAME`
    if [ ! "${_os_version_name_}" ]; then
        _err_msg_="Could not get OS version of ${_host_name_}"
        abort_script "${_err_msg_}"
    fi


if [ "${_os_version_name_}" == "Linux" ]; then
    # Select the FS Pool Disks
    if [ "${CURR_SERVER_TYPE}" == "dwh_reader_1" -o "${CURR_SERVER_TYPE}" == "dwh_reader_2" ];then
        _pool_list_="stats_iqr_pool"
    else
        _pool_list_="${CURR_SERVER_TYPE}_pool"
    fi 
    
    for _pool_ in ${_pool_list_}; do
        _pool_name_=${_pool_}
        _str1_="${_pool_name_}"
        _str2_="${_pool_name_} FS DISK ALLOCATION OPTIONS"
        _str3_="to the ${_pool_name_} FS Storage Pool"
        _str4_="\\\nSelect Range of disks you want to allocate ${_str3_}\\\nusing the format [n,n,n-n,n...n]\\tE.G. 1,2,3-8,9,10"
        _max_lun_=999999
        $ECHO "${_str1_}@@@${_str2_}@@@${_str3_}@@@${_str4_}@@@${_max_lun_}" >> ${_disk_menu_opt_file_}
        if [ ! "${_menu_opt_list_}" ]; then
            _menu_opt_list_="${_str1_}"
        else
            _menu_opt_list_="${_menu_opt_list_} ${_str1_}"
        fi
    done
else
    # Select the ZFS Pool Disks
    if [ "${CURR_SERVER_TYPE}" == "dwh_reader_1" -o "${CURR_SERVER_TYPE}" == "dwh_reader_2" ];then
         _pool_list_="eniq_sp_1 stats_iqr_pool"
    else
        _pool_list_="eniq_sp_1 ${CURR_SERVER_TYPE}_pool"
    fi     

    for _pool_ in ${_pool_list_}; do
        #_pool_name_=`iniget ${_pool_} -f ${TEM_DIR}/${SUNOS_INI} -v name`
        _pool_name_=$_pool_
        _str1_="${_pool_name_}"
        _str2_="${_pool_name_} ZFS DISK ALLOCATION OPTIONS"
        _str3_="to the ${_pool_name_} ZFS Storage Pool"
        _str4_="\\\nSelect Range of disks you want to allocate ${_str3_}\\\nusing the format [n,n,n-n,n...n]\\tE.G. 1,2,3-8,9,10"
        _max_lun_=999999
        $ECHO "${_str1_}@@@${_str2_}@@@${_str3_}@@@${_str4_}@@@${_max_lun_}" >> ${_disk_menu_opt_file_}
        if [ ! "${_menu_opt_list_}" ]; then
            _menu_opt_list_="${_str1_}"
        else
            _menu_opt_list_="${_menu_opt_list_} ${_str1_}"
        fi
    done
fi 

if [ "${CURR_SERVER_TYPE}" != "stats_engine" ]; then
    # Add Temp DB spaces to menu opt file
    _str1_="TempDB"
    _str2_="TempDB DISK ALLOCATION OPTIONS"
    _str3_="for TempDB database usage"
    _str4_="\\\nSelect Range of disks you want to allocate ${_str3_}\\\nusing the format [n,n,n-n,n...n]\\tE.G. 1,2,3-8,9,10"
    _max_lun_=999999
    $ECHO "${_str1_}@@@${_str2_}@@@${_str3_}@@@${_str4_}@@@${_max_lun_}" >> ${_disk_menu_opt_file_}
    if [ ! "${_menu_opt_list_}" ]; then
        _menu_opt_list_="${_str1_}"
    else
        _menu_opt_list_="${_menu_opt_list_} ${_str1_}"
    fi
fi

while :; do
    $CP /dev/null ${TEM_DIR}/selected_disks
    for _menu_opt_ in ${_menu_opt_list_}; do
        _str1_=`$GREP "^${_menu_opt_}" ${_disk_menu_opt_file_} | $AWK -F"@@@" '{print $1}'`
        _str2_=`$GREP "^${_menu_opt_}" ${_disk_menu_opt_file_} | $AWK -F"@@@" '{print $2}'`
        _str3_=`$GREP "^${_menu_opt_}" ${_disk_menu_opt_file_} | $AWK -F"@@@" '{print $3}'`
        _str4_=`$GREP "^${_menu_opt_}" ${_disk_menu_opt_file_} | $AWK -F"@@@" '{print $4}'`
        _max_lun_=`$GREP "^${_menu_opt_}" ${_disk_menu_opt_file_} | $AWK -F"@@@" '{print $5}'`

        while :; do
            unset _opt_
            $RM -f ${_disp_file_}
            #The purpose of the following if statement is to prevent it displaying the message unless there are actually disks to select
            if [ "$_cnt_" -le "1" ]; then
                _err_msg_="There are no disks to select. Exiting."
                abort_script "${_err_msg_}"
            fi
            $ECHO "${_str2_}"  >> ${_disp_file_}
            $ECHO "------------------------------------------------------------\n" >> ${_disp_file_}
            $PRINTF "${_line1_str_}" "" "LUN ID" "Size" "LUN NAME" >> ${_disp_file_}

            #Display the disks that have not yet been selected in previous iterations of this while loop
            _loop_opt_cnt_=${#_disk_opt_array_[@]}
            for (( i=1; i<=${_loop_opt_cnt_}; i++ )); do
                #$GREP -w "${_disk_lun_id_array_[${i}]}"  ${TEM_DIR}/selected_disks >> /dev/null 2>&1
                $CAT ${TEM_DIR}/selected_disks | $AWK -F "::" '{print $3}' | $GREP -w "${_disk_lun_id_array_[${i}]}"
                if [ $? -eq 0 ]; then
                    continue
                fi
                $PRINTF "${_line1_str_}" "[${_disk_opt_array_[${i}]}]" "${_disk_lun_id_array_[${i}]}" "${_disk_size_array_[${i}]}GB" "${_lun_name_array_[${i}]}" >> ${_disp_file_}
            done
            $CAT ${_disp_file_} >> ${ENIQ_CLIENT_CONFIG_DIR}/disp_file_${_client_hostname_}
            _numerror_=0
            $CLEAR
            $CAT ${_disp_file_} #List the disks
            if [ -f ${ENIQ_CLIENT_CONFIG_DIR}/Main_selection ]; then
                log_msg -s "Please select lun size greater than or equal to ${missed_lun_size[@]} instead of "${_dsk_size[@]}"" -l ${LOGFILE} -c 35
                $RM -rf ${ENIQ_CLIENT_CONFIG_DIR}/Main_selection
            elif [ -f ${ENIQ_CLIENT_CONFIG_DIR}/Failure_case ]; then
                log_msg -s "Please select lun size greater than or equal to ${_sys_size_gb_} instead of "${_dsk_size[@]}"" -l ${LOGFILE} -c 35
                $RM -rf ${ENIQ_CLIENT_CONFIG_DIR}/Failure_case
            fi

            $ECHO "${_str4_}"
            read _opt_
            # If the User hit nothing and there is a default. that will do
            #if [ ! "${_opt_}" ]; then
             #   continue
            #fi

            #Iterate through each comma seperated item of the user input
            unset _num_ # - item of user input
            _opt_sel_="," # - validated list of items
            for _num_ in `$ECHO ${_opt_} | $SED -e 's| ||g' -e 's|,| |g'`; do
                $ECHO ${_num_} | $GREP '-' >> /dev/null 2>&1
                if [ $? -eq 0 ]; then # it's a range
                    # Only one disk required?
                    if [ ${_max_lun_} -eq 1 ]; then
                        _numerror_=1
                        break
                    fi

                    _start_=`$ECHO ${_num_} | $AWK -F\- '{print $1}'`
                    if [ ! "${_start_}" ]; then
                        _numerror_=1
                        break
                    fi
                    # Check if the first number is numeric
                    $ECHO ${_start_} | $GREP '[^0-9]' >> /dev/null 2>&1
                    if [ $? -eq 0 ]; then
                        _numerror_=1
                        break
                    fi

                    _end_=`$ECHO ${_num_} | $AWK -F\- '{print $2}'`
                    if [ ! "${_end_}" ]; then
                        _numerror_=1
                        break
                    fi
                    # Check if the last number is numeric
                    $ECHO ${_end_} | $GREP '[^0-9]' >> /dev/null 2>&1
                    if [ $? -eq 0 ]; then
                        _numerror_=1
                        break
                    fi

                    if [ "${_start_}" -ge  "${_end_}" >> /dev/null 2>&1 ]; then
                        _numerror_=1
                        break
                    fi

                    for (( _sel_=${_start_}; _sel_<=${_end_}; _sel_++ )); do
                        # Check if already selected
                        $ECHO $_opt_sel_ | $GREP ",${_sel_}," >> /dev/null 2>&1
                        if [ $? -eq 0 ]; then
                            _numerror_=1
                            break
                        fi

                    # Check it's within range
                        if [ ${_sel_} -lt 1 -o ${_sel_} -gt ${_loop_opt_cnt_} ]; then
                            _numerror_=1
                            break
                        fi

                        #Add to list of validated disk numbers
                        _opt_sel_="${_opt_sel_}${_sel_},"

                    done
                else # it's not a range.
                    # Check for numeric
                    $ECHO ${_num_} | $GREP '[^0-9]' >> /dev/null 2>&1
                    if [ $? -eq 0 ]; then
                        _numerror_=1
                        break
                    fi

                    # Only one disk required?
                    if [ ${_max_lun_} -eq 1 ]; then
                        _chk_=`$ECHO ${_opt_} | $SED -e 's| ||g' -e 's|,| |g'|$WC -w`
                        if [ ${_chk_} -ne 1 ]; then
                            _numerror_=1
                            break
                        fi
                    fi

                    # Check if already selected
                    $ECHO $_opt_sel_ | $GREP ",${_num_}," >> /dev/null 2>&1
                    if [ $? -eq 0 ]; then
                        _numerror_=1
                        break
                    fi

                    # Check it's within range
                    if [ ${_num_} -lt 1 -o ${_num_} -gt ${_loop_opt_cnt_} ]; then
                        _numerror_=1
                        break
                    fi

                    #Add to list of validated disk numbers
                    _opt_sel_="${_opt_sel_}${_num_},"
                fi
            done
            if [ "${_bkup_opt_}" == "FullData" ]; then
                if [ "${_str1_}" == "MainDB" -o "${_str1_}" == "IQ_SYS_MAIN" ]; then
                    $ECHO $_opt_sel_ | $SED 's/,/\n/g' > ${TEM_DIR}/option_file
                    _count_option_=`$CAT ${TEM_DIR}/option_file | $WC -w`
                    #Compare the size of option selected by user and old MainDB. It should be equal.
                    if [ "${_str1_}" == "MainDB" ]; then 
                        if [ ${#_MainDB_size_array_[@]} -ne $_count_option_ ]; then
                            _err_msg_="Please add number of MainDBs equal to ${#_MainDB_size_array_[@]}"
                            abort_script "${_err_msg_}"
                        fi
                    else 
                        if [ $_count_option_ -ne 1 ]; then
                            _err_msg_="Please add 1 IQ_SYS_MAIN lun"
                            abort_script "${_err_msg_}"
                        fi
                    fi
                fi
                if [ ${_numerror_} -eq 0 ]; then
                    #User input is valid. Iterate through each disk number and write selections(s) to file
                    unset _num_
                    _index_=0
                    #Building an array for storing size of maindb luns selected by user
                    if [ "${_str1_}" == "MainDB" ]; then
                        for _num_ in `$ECHO ${_opt_sel_} | $SED -e 's| ||g' -e 's|,| |g'`; do
                            _dsk_size[${_index_}]=`$ECHO ${_disk_size_array_[${_num_}]}`
                            let _index_=${_index_}+1
                        done
                        #Sorting that array in ascending order which will be each for comparing this lun size with stored lun size
                        sort_the_array ${_dsk_size[@]}
                        #Start comparing the luns: input lun size should be greater than or equal to old luns
                        for ((i=0; i <= $((${#_MainDB_size_array_[@]} - 1)); i++)); do
                            for ((j=0; j <= $((${#_dsk_size[@]} - 1)); j++)); do
                                if [[ ${_dsk_size[j]} -ge ${_MainDB_size_array_[i]} ]]; then
                                    _dsk_size=(${_dsk_size[@]:0:$j} ${_dsk_size[@]:$(($j + 1))})
                                    _new_MainDB_=("${_new_MainDB_[@]}" "${_MainDB_size_array_[i]}")
                                    break
                                else
                                    continue
                                fi
                            done
                        done
                        #Checking if _disk_size is empty or not. If it is not empty please check which lun size it has to choose from the list to successfully move ahead.
                        if [ ${#_dsk_size[@]} -ne 0 ]; then
                            $TOUCH ${ENIQ_CLIENT_CONFIG_DIR}/Main_selection
                            for ((k=0; k <= $((${#_MainDB_size_array_[@]} - 1)); k++)); do
                                f=0
                                for ((l=0; l <= $((${#_new_MainDB_[@]} - 1)); l++)); do
                                    if [ "$k" == "$l" ]; then
                                        if [[ ${_MainDB_size_array_[k]} -eq ${_new_MainDB_[l]} ]]; then
                                           f=1
                                           break
                                        fi
                                    else
                                        continue
                                    fi
                                done
                                if [ "$f" -eq "0" ]; then
                                    missed_lun_size=("${missed_lun_size[@]}" "${_MainDB_size_array_[k]}")
                                fi
                            done
                        else
                            for _num_ in `$ECHO ${_opt_sel_} | $SED -e 's| ||g' -e 's|,| |g'`; do
                                _dsk_size=`$ECHO ${_disk_size_array_[${_num_}]}`
                                _dsk_lun_id_=`$ECHO ${_disk_lun_id_array_[${_num_}]}`
                                #$GREP -w ${_dsk_lun_id_} ${TEM_DIR}/selected_disks >> /dev/null 2>&1
                                $CAT ${TEM_DIR}/selected_disks | $AWK -F "::" '{print $3}' | $GREP -w ${_dsk_lun_id_} 
                                if [ $? -ne 0 ]; then
                                    $ECHO "${_num_}::${_str1_}::${_dsk_lun_id_}::${_dsk_size}" >> ${TEM_DIR}/selected_disks
                                fi
                            done
                            break
                        fi
                    else
                        for _num_ in `$ECHO ${_opt_sel_} | $SED -e 's| ||g' -e 's|,| |g'`; do
                            _dsk_size=`$ECHO ${_disk_size_array_[${_num_}]}`
                            _dsk_lun_id_=`$ECHO ${_disk_lun_id_array_[${_num_}]}`
                             if [ "${_str1_}" == "IQ_SYS_MAIN" ]; then
                                if [ "${_dsk_size}" -ge "${_sys_size_gb_}" ]; then
                                    #$GREP -w ${_dsk_lun_id_} ${TEM_DIR}/selected_disks >> /dev/null 2>&1 
                                    $CAT ${TEM_DIR}/selected_disks | $AWK -F "::" '{print $3}' | $GREP -w ${_dsk_lun_id_}
                                    if [ $? -ne 0 ]; then
                                        $ECHO "${_num_}::${_str1_}::${_dsk_lun_id_}::${_dsk_size}" >> ${TEM_DIR}/selected_disks
                                    fi
                                $TOUCH ${ENIQ_CLIENT_CONFIG_DIR}/Success_case
                                else
                                    #$ECHO "Please select IQ_SYS_MAIN size greater than "${_sys_main_size_}" instead of "${_dsk_size}""
                                    $TOUCH ${ENIQ_CLIENT_CONFIG_DIR}/Failure_case
                                fi 
                             else
                                #$GREP -w ${_dsk_lun_id_} ${TEM_DIR}/selected_disks >> /dev/null 2>&1
                                $CAT ${TEM_DIR}/selected_disks | $AWK -F "::" '{print $3}' | $GREP -w ${_dsk_lun_id_}
                                if [ $? -ne 0 ]; then
                                    $ECHO "${_num_}::${_str1_}::${_dsk_lun_id_}::${_dsk_size}" >> ${TEM_DIR}/selected_disks
                                    $TOUCH ${ENIQ_CLIENT_CONFIG_DIR}/Success_case
                                fi
                             fi
                        done
                        if [ -f ${ENIQ_CLIENT_CONFIG_DIR}/Success_case ] ; then
                             $RM -rf ${ENIQ_CLIENT_CONFIG_DIR}/Success_case
                             break
                        fi
                    fi
                fi
            else
                if [ ${_numerror_} -eq 0 ]; then
                    #User input is valid. Iterate through each disk number and write selections(s) to file
                    unset _num_
                    for _num_ in `$ECHO ${_opt_sel_} | $SED -e 's| ||g' -e 's|,| |g'`; do
                        _dsk_lun_id_=`$ECHO ${_disk_lun_id_array_[${_num_}]}`
                        _dsk_size_=`$ECHO ${_disk_size_array_[${_num_}]}` 
                        #$GREP -w ${_dsk_lun_id_} ${TEM_DIR}/selected_disks >> /dev/null 2>&1
                        $CAT ${TEM_DIR}/selected_disks | $AWK -F "::" '{print $3}' | $GREP -w ${_dsk_lun_id_}
                        if [ $? -ne 0 ]; then
                            $ECHO "${_num_}::${_str1_}::${_dsk_lun_id_}::${_dsk_size_}" >> ${TEM_DIR}/selected_disks
                        fi
                    done
                    break
                fi
            fi
        done
    done
    # Check if overall disk allocation is correct
    $RM -f ${_disp_file_}
    _line3_str_="%-25s%-${_field3_}s\n"
    $PRINTF "${_line3_str_}" "Allocation" "DISK" >> ${_disp_file_}
    for _menu_opt_ in ${_menu_opt_list_}; do
        _disk_ids_=`$GREP "::${_menu_opt_}" ${TEM_DIR}/selected_disks | $AWK -F"::" '{print $3}'`
        _first_=1
        for _dsk_ in ${_disk_ids_}; do
            if [ ${_first_} -eq 1 ]; then
                $PRINTF "${_line3_str_}"  "${_menu_opt_}" "${_dsk_}" >> ${_disp_file_}
                _first_=0
            else
                $PRINTF "${_line3_str_}"  ""  "${_dsk_}" >> ${_disp_file_}
            fi
        done
        $ECHO "\n" >> ${_disp_file_}
    done

    while :; do
        $CLEAR
        $CAT ${_disp_file_}
        $ECHO "\n\nAre the disk allocations above correct (Yy/Nn)"
        read _user_conf_
        # If the User hit nothing and there is a default. that will do
        if [ ! "${_user_conf_}" ]; then
            continue
        fi
        # Did the user input (Y/y/N/n)
        if [ "${_user_conf_}" == "Y" -o "${_user_conf_}" == "y" ]; then
            break
        elif [ "${_user_conf_}" == "N" -o "${_user_conf_}" == "n" ]; then
            break
        else
            :
        fi
    done

    if [ "${_user_conf_}" == "Y" -o "${_user_conf_}" == "y" ]; then
        break
    fi
done

$ECHO "\nUser disk selection:" >> ${LOGFILE}
$CAT ${_disp_file_} >> ${LOGFILE}

$CP ${TEM_DIR}/selected_disks ${ENIQ_CLIENT_CONFIG_DIR}/${_client_hostname_}_lun_details
if [ ! -s "${ENIQ_CLIENT_CONFIG_DIR}/${_client_hostname_}_lun_details" ] ; then
    _err_msg_="Could not create ${ENIQ_CLIENT_CONFIG_DIR}/${_client_hostname_}_lun_details file for ${_client_hostname_}"
    abort_script "${_err_msg_}"
fi

unset _disk_opt_array_
unset _disk_lun_id_array_
unset _disk_size_array_
unset _lun_name_array_

}

### Function: get_next_stage ###
#
# Get the stage to be run
#
# Arguments:
#   $1 : Stage to be set to. Either numeric value or 'done'
# Return Values:
#   none
get_next_stage()
{
ARRAY_ELEM=0

if [ -s ${STAGEFILE} ]; then
    NEXT_STAGE=`$CAT $STAGEFILE | $GREP -v '^[[:blank:]]*#' | $SED -e 's| ||g'`
    if [ ! "${NEXT_STAGE}" ]; then
        _err_msg_="Failed to read stage from ${STAGEFILE}, exiting."
        abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
    fi

    if [ "${NEXT_STAGE}" == "done" ]; then
        return 0
    else
        $ECHO ${ENIQ_CORE_STAGES[*]} | $GREP -w ${NEXT_STAGE} >> /dev/null 2>&1
        if [ $? -ne 0 ]; then
            _err_msg_="Specified stage ${NEXT_STAGE} is not a valid installation stage"
            abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
        fi
    fi

    # Get the element number so we can move along the array
    get_array_element
else
    $MKDIR -p `$DIRNAME ${STAGEFILE}`
    if [ $? -ne 0 ]; then
        _err_msg_="Failed to create directory `$DIRNAME ${STAGEFILE}`, exiting."
        abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
    fi

    NEXT_STAGE=${ENIQ_CORE_STAGES[${ARRAY_ELEM}]}
fi
}

### Function: get_user_input ###
#
#   Read server type from user
#
# Arguments:
#       none
# Return Values:
#       none
get_user_input()
{
$CLEAR

insert_header_footer head "Getting Server Information from user" ${LOGFILE}

while :; do
    _disp_file_=${TEM_DIR}/disp_file
    $RM -rf ${_disp_file_} >> /dev/null 2>&1

    log_msg -s "\nAvailable Server type:\n===========================" -l ${LOGFILE} -c 33
    log_msg -s "\n[1] ENIQ Statistics Single Blade\n[2] ENIQ Statistics Multi Blade\n[3] ENIQ Statistics Rack Server" -l ${LOGFILE} -c 35
    log_msg -s "\nPlease select the server type of ENIQ client to be restored " -l ${LOGFILE} -c 33
    read _user_value_
    if [ -x ${_user_value_} ]; then
        continue
    fi

    if [ ${_user_value_} -eq 1 ]; then
        _curr_server_type_=ENIQ_Statistics_Single_Blade
    elif [ ${_user_value_} -eq 2 ]; then
        _curr_server_type_=ENIQ_Statistics_Multi_Blade
    elif [ ${_user_value_} -eq 3 ]; then
        _curr_server_type_=ENIQ_Statistics_Rack_Server
    else
        log_msg -s  "\nPlease choose the Server type, enter 1 or 2\n" -l ${LOGFILE} -c 31
        continue
    fi

    log_msg -s  "\nUSER VALUE CONFIRMATION\n==========================\n" -l ${LOGFILE}
    log_msg -s "Selected Server type is: ${_curr_server_type_}" -l ${LOGFILE}

     break
done

if [ ${_curr_server_type_} == "ENIQ_Statistics_Single_Blade" ]; then
    _server_list_="eniq_stats"
elif [ ${_curr_server_type_} == "ENIQ_Statistics_Rack_Server" ]; then
    _server_list_="eniq_stats"
else
    _server_list_="stats_coordinator stats_engine dwh_reader_1 dwh_reader_2"
fi

get_blade_details
}

### Function: iniget ###
#
# Read specified parts from a given ini file
#
# Arguments:
#       -f  : specified ini file
#       -p  : gives whole matching <line>
#       -v  : gives only value of matching <line>
#       raw : will print even commented (;) lines
# Return Values:
#       0 : Success
#       1 : Error
#       Text output
iniget()
{
if [ -n "$1" ]; then
    INIBLOCK="$1"
    shift 1
else
    $ECHO "Usage: iniget <block> -f <configfile> [-<p|v> <line>] [raw]"
    return 1
fi

unset INIWLINE INILINE INICONFIGFILE INIPRINTTYPE
while [ -n "$1" ]; do
    case $1 in
        -p)    INIWLINE=parameter
               INILINE=$2
               shift 2
               ;;
        -v)    INIWLINE=value
               INILINE=$2
               shift 2
               ;;
        -f)    INICONFIGFILE=$2
               shift 2
               ;;
        raw)   INIPRINTTYPE=raw
               shift 1
               ;;
        *)     return 1
               ;;
    esac
done

if [ -z "$INICONFIGFILE" ]; then
    $ECHO "Usage: iniget <block> -f <configfile> [-<p|v> <line>] [raw]"
    return 1
fi

$AWK -F= -v printtype=$INIPRINTTYPE -v line="$INILINE" -v way=$INIWLINE '
  { sub(/[       ]*$/,"");      #remove trailing whitespace and tabs
    if ($1=="['$INIBLOCK']") {
        while ((getline) > 0) {
            if ($0 ~ /^ *\[/) exit
            if (($0 ~ /^ *;/) && (printtype!="raw")) continue
            if ($1==line) {
                if (way=="parameter") {print $0; exit}
                if (way=="value")     {sub(/^[^=]*=/,""); print $0; exit}
            }
            else if (! line) print $0
        }
    }
  }' $INICONFIGFILE
}

### Function: insert_header_footer ###
#
#   Insert a stage header/footer message
#
# Arguments:
#   $1 : head/foot
#   $2 : Message
#   $3 : Logfile
# Return Values:
#   none
insert_header_footer()
{
if [ "$1" != "head" -a "$1" != "foot" ]; then
    _err_msg_="Only Parameter of head/foot is allowed...exiting!"
    abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

_type_=$1

_msg_=$2

_logfile_=$3

$MKDIR -p `$DIRNAME ${_logfile_}`
if [ $? -ne 0 ]; then
    _err_msg_="Could not create directory `$DIRNAME ${_logfile_}`"
    abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ ${_logfile_} ] ;then
    $TOUCH -a ${_logfile_}
    if [ $? -ne 0 ]; then
        _err_msg_="Could not write to file ${_logfile_}"
        abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
    fi
fi

_time_=`$DATE '+%Y-%b-%d_%H.%M.%S'`
if [ "${_type_}" == "head" ]; then
    $ECHO "\e[0;36m\n\n\n\n\n\n\n---------------------------------------------------------------------------------------------------------------------\e[0m"
    $ECHO  "\e[1;36m${_time_} : ${_msg_} \e[0m"
    $ECHO "\e[0;36m-----------------------------------------------------------------------------------------------------------------------------------\e[0m"
fi

if [ "${_type_}" == "foot" ]; then
    $ECHO "\e[0;32m\n\n\n-----------------------------------------------------------------------------------------------------------------------------\e[0m"
    $ECHO  "\e[1;32m${_time_} : ${_msg_} \e[0m"
    $ECHO "\e[0;32m-----------------------------------------------------------------------------------------------------------------------------------\e[0m"
fi
}

### Function: log_msg ###
#
# I will create the function log if one does not already exist
# This allows user to have his/her own log function and still
# work with the commmon functions
#
# Arguments:
#       -l) : File to be logged to
#               -h) : Print the message as a header
#       -q) : don't echo the text, just tee it
#       -s) : Text/message to be logged
#               -t) : Prints the current time as part of the message
# Return Values:
#       0 : Success
#       1 : Error
log_msg()
{
local logfile quiet outstr header msg_time
unset colour
while [ -n "$1" ]; do
    case $1 in
        -l)    logfile=$2
               shift 2
               ;;
        -h)    header=-h
               shift 1
               ;;
        -q)    quiet=-q
               shift 1
               ;;
        -s)    outstr=$2
               shift 2
               ;;
        -t)    msg_time=-t
               shift 1
               ;;
        -c)    colour=$2
               shift 2
               ;;
        -w)    write=-w
               shift 1
               ;;
        *)     return 1
               ;;
    esac
done
if [ ! "${outstr}" ]; then
    return 1
fi

local run_time=`$DATE '+%Y-%m-%d_%H.%M.%S'`
if [ "${msg_time}" ]; then
    outstr="${run_time} - ${outstr}"
fi

if [ "${header}" ]; then
    # Print the message as a header. This will
    # pad the string to a defined length and
    # add a prefix and postfix tag (<=== and ===>)
    if [ "${logfile}" ]; then
        if [ ! "${quiet}" ]; then
            $ECHO -e "${outstr}" | $AWK '
            {
                n1=length($0)
                n2=36-n1/2-n1%2
                n3=34-n1/2
                $PRINTF("\n\n")
                for ( n=1; n<n2; n++)
                $PRINTF("=")
                $PRINTF("=< %s >=",$ 0)
                for ( n=1; n<n3 ;n++ )
                $PRINTF("=")
                $PRINTF("\n\n")
                }' | $TEE -a ${logfile}
        else
            $ECHO -e "${outstr}" | $AWK '
            {
                n1=length($0)
                n2=36-n1/2-n1%2
                n3=34-n1/2
                $PRINTF("\n\n")
                for ( n=1; n<n2; n++)
                $PRINTF("=")
                $PRINTF("=< %s >=",$ 0)
                for ( n=1; n<n3 ;n++ )
                $PRINTF("=")
                $PRINTF("\n\n")
                }' >> ${logfile}
        fi
    else
        if [ ! "${quiet}" ]; then
            $ECHO -e "${outstr}" | $AWK '
            {
                n1=length($0)
                n2=36-n1/2-n1%2
                n3=34-n1/2
                $PRINTF("\n\n")
                for ( n=1; n<n2; n++)
                $PRINTF("=")
                $PRINTF("=< %s >=",$ 0)
                for ( n=1; n<n3 ;n++ )
                $PRINTF("=")
                $PRINTF("\n\n")
                }'
        fi
    fi
else
    # Simply print the message
    if [ "${logfile}" ]; then
        if [ ! "${quiet}" ]; then
            if [ "${write}" ]; then
                $ECHO "\e[1;${colour}m${outstr} \e[0m"
            else
                $ECHO "\e[1;${colour}m${outstr} \e[0m"  |$TEE -a ${logfile}
            fi
        else
            $ECHO "${outstr}" >> ${logfile}
        fi
    else
        if [ ! "${quiet}" ]; then
            $ECHO "\e[1;${colour}m${outstr} \e[0m"
        fi
    fi
fi
}

### function: nbu_connectivity_setup ###
#
# Setup connectivity for security authentication
#
# Arguments:
#       none
# Return Values:
#       none
nbu_connectivity_setup()
{
# Creates a token for security authentication
create_token

_token_value_=`${NBU_BIN}/nbcertcmd -displayToken -name ${_token_name_} | $GREP "Token Value" | $AWK '{print $NF}'`
if [ ! "${_token_value_}" ] ; then
    _err_msg_="Failed to fetch token value"
     abort_script "${_err_msg_}"
fi

$RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "${NBU_BIN}/nbcertcmd -getCertificate -token ${_token_value_}"
if [ $? -ne 0 ]; then
    $EXPECT <<EOF >>${LOGFILE} 2>&1
    set timeout 600
    spawn $RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "${NBU_BIN}/nbcertcmd -getCAcertificate -server `hostname`"
     expect {
     "Are you sure you want to continue using this certificate"  {send "y\r";exp_continue}
     "EXIT STATUS" {send_user "\nERROR!!!\n"; exit 1}
     timeout {send_user "\nTIMEOUT!\n"; exit 9}
     }
EOF

    if [ $? -ne 0 ] ; then
        _err_msg_="Failed to get the CAcertificate"
        abort_script "${_err_msg_}"
    fi

    $RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "${NBU_BIN}/nbcertcmd -getCertificate -token ${_token_value_}"
    if [ $? -ne 0 ] ; then
        _err_msg_="Failed to get the certificate"
        abort_script "${_err_msg_}"
    fi
fi
}

### function: o_disable_policies ###
#
# Check for the policies with hostname and disable it
#
# Arguments:
#    hostname
# Return Values:
#     none
o_disable_policies()
{
insert_header_footer head "Entering restore stage - ${NEXT_STAGE} on ${_hostname_}" ${LOGFILE}

$TOUCH ${ENIQ_CLIENT_CONFIG_DIR}/restore_stages_started

if [ -x  "${NBU_ADMIN}/bppllist" ];then
    policies=$(${NBU_ADMIN}/bppllist | $GREP ${_hostname_})
    log_msg -q -s "Policies List: ${policies}" -l ${LOGFILE} -w
else
    _err_msg_="NetBackup is not installed on OMBS server"
    abort_script "${_err_msg_}"
fi

for policy in ${policies}
do
    active_status=$(${NBU_ADMIN}/bpplinfo ${policy} -L | $GREP -i  "Active" | $AWK -F" " '{print $2}')
    if [ "${active_status}" == "no" ];then
       log_msg -s "${policy} Policy is already in disabled state" -l ${LOGFILE} -w
    else
        local deac_op=$(${NBU_ADMIN}/bpplinfo ${policy} -modify -inactive)
        local deac_ec=$($ECHO $?)
        if [ ${deac_ec} -ne 0 ]; then
            log_msg -q -s  "Disable command for ${policy} Output: ${deac_op} "  -l ${LOGFILE}
            log_msg -q -s  "Disable command for ${policy} Exit Code: ${deac_ec} "  -l ${LOGFILE}
            _err_msg_="Failed to disable policy: ${policy}"
            abort_script "${_err_msg_}"
        fi
       log_msg -s "Disabled ${policy} policy successfully" -l ${LOGFILE} -w
    fi
done

# Add OMBS server IP and hostname in client /etc/hosts
add_client_etchosts

insert_header_footer foot "Successfully completed ${NEXT_STAGE} stage on ${_hostname_}" ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`

}

### function: o_restore_bmr ###
#
# Restore the BMR configuration file to /tmp
#
# Arguments:
#       none
# Return Values:
#       none
o_restore_bmr()
{
insert_header_footer head "Entering restore stage - ${NEXT_STAGE} on ${_hostname_}" ${LOGFILE}

fetch_details_from_conf_file

ombs_hname=$(hostname)
conf_hname=$($CAT /usr/openv/netbackup/bp.conf | $GREP EMMSERVER | $AWK -F'= ' '{print $2}' | $XARGS)
if [ "${ombs_hname}" != "${conf_hname}" ]; then
    _err_msg_="Conflict in OMBS Server hostname and bp.conf entry"
    abort_script "${_err_msg_}"
fi

if [ "${_os_version_name_}" == "Linux" ]; then
    local bmrconfig_path="/.ENIQ_BACKUP/eniq/bkup_sw/bmr_config_data" 
    bmr_file=$(${NBU_BIN}/bplist -C ${_hostname_} -S `hostname` -s ${_starttime_} -e ${_endtime_} -R 1 ${bmrconfig_path}/ 2>>${LOGFILE} | $TAIL -1 | $AWK -F'/' '"$6==tar.gz" {print $6}')
    if [ $? -ne 0 -o -z "${bmr_file}" ]; then
        _err_msg_="Failed to fetch BMR configuration file"
        abort_script "${_err_msg_}"
    fi
    $ECHO "change ${bmrconfig_path}/${bmr_file} to /var/tmp/${bmr_file}" > /tmp/${_hostname_}_restore_bmrconfig
else
    local bmrconfig_path="/usr/openv/netbackup/bin/ombs/bmr/bmr_config_data"
    bmr_file=$(${NBU_BIN}/bplist -C ${_hostname_} -S `hostname` -s ${_starttime_} -e ${_endtime_} -R 1 ${bmrconfig_path}/ 2>>${LOGFILE} | $TAIL -1 | $AWK -F'/' '"$9==tar.gz" {print $9}')
    if [ $? -ne 0 -o -z "${bmr_file}" ]; then
        _err_msg_="Failed to fetch BMR configuration file"
        abort_script "${_err_msg_}"
    fi
    $ECHO "change ${bmrconfig_path}/${bmr_file} to /tmp/${bmr_file}" > /tmp/${_hostname_}_restore_bmrconfig
fi

local restore_file=$($AWK '{print $2}' /tmp/${_hostname_}_restore_bmrconfig 2>>{LOGFILE})

#Create progress log file to save bprestore output
restore_bmrconf_proglog="/usr/openv/netbackup/logs/${_hostname_}_bmr_restore_progress.log"
$ECHO "\n Restore of BMR configuration file logs" >${restore_bmrconf_proglog}

local restore_bmrconfig="${NBU_BIN}/bprestore -s ${_starttime_} -e ${_endtime_} -S ${ombs_hname} -C ${_hostname_} -D ${_hostname_} -L ${restore_bmrconf_proglog}  -H -R /tmp/${_hostname_}_restore_bmrconfig ${restore_file}"
if [ -z "${restore_bmrconf_proglog}" -o -z "/tmp/${_hostname_}_restore_bmrconfig" -o -z "${restore_file}" ]; then
    log_msg -q -s "Actual Command: bprestore -s {_starttime_} -e {_endtime_} -S {ombs_hname} -C {_hostname_} -D {_hostname_} -L {restore_bmrconf_proglog}  -H -R /tmp/{_hostname_}_restore_bmrconfig {restore_file}" -l {LOGFILE} -w
    log_msg -q -s "Failed command: bprestore -s ${_starttime_} -e ${_endtime_} -S ${ombs_hname} -C ${_hostname_} -D ${_hostname_} -L ${restore_bmrconf_proglog}  -H -R /tmp/${_hostname_}_restore_bmrconfig ${restore_file}" -l {LOGFILE} -w
    _err_msg_="Failed to frame bprestore command."
    abort_script "${_err_msg_}"
fi

log_msg -s "Executing ${restore_bmrconfig} " -l ${LOGFILE} -w
${restore_bmrconfig} >>${LOGFILE} 2>&1
if [ $? -ne 0 ]; then
    _err_msg_="Restore of BMR configuration file to /tmp failed. Exiting...\nExiting...\nRefer ${LOGFILE} for more information."
    abort_script "${_err_msg_}"
fi

log_msg -s "Restoring BMR configuration file to /tmp.\n"
$SLEEP 10

count_1=1
jobid=$($GREP 'Restore Job Id=' ${restore_bmrconf_proglog} 2>>${LOGFILE} | $AWK -F'=' '{print $2}')
if [ ! "${jobid}" ]; then
    err_msg_="Could not get the value for jobid"
    abort_script "${_err_msg_}"
fi
$SLEEP 15

while [ ! "${jobtype}" -a "${count_1}" -le 6 ]; do
    jobtype=$(${NBU_ADMIN}/bpdbjobs -report | $GREP -w ${jobid} | $AWK '{print $2}')
    if [ "${jobtype}" ]; then
        break;
    else
        $SLEEP 10
        count_1=$($EXPR ${count_1} + 1)
        continue
    fi
done

if [ ! "${jobtype}" ]; then
    err_msg_="Could not get the value for jobtype"
    abort_script "${_err_msg_}"
fi

validate_restore ${jobid} ${jobtype} ${restore_file} /tmp ${restore_bmrconf_proglog} 10

$RUN_REM_CMD ${DEFAULT_USER}@${_client_ip_} "$CP /var/tmp/${bmr_file} /tmp/${bmr_file}"
$RM -rf /tmp/${_hostname_}_restore_bmrconfig
$CP ${restore_bmrconf_proglog} ${ENIQ_CLIENT_CONFIG_DIR}

insert_header_footer foot "Successfully completed ${NEXT_STAGE} stage on ${_hostname_}" ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`

}

### Function : o_restore_bmr_1 ####
#
# Restore  BMR configuration file to /var/tmp
#
# Arguments:
#       none
# Return Values:
#       none
o_restore_bmr_1()
{
insert_header_footer head "Entering restore stage - ${NEXT_STAGE} on ${_hostname_}" ${LOGFILE}

fetch_details_from_conf_file

local bmrconfig_path1="/.ENIQ_BACKUP/eniq/bkup_sw/bmr_config_data"
bmr_file1=$(${NBU_BIN}/bplist -C ${_hostname_} -S `hostname` -s ${_starttime_} -e ${_endtime_} -R 1 ${bmrconfig_path1}/ 2>>${LOGFILE} | $TAIL -1 | $AWK -F'/' '"$6==tar.gz" {print $6}')
if [ $? -ne 0 -o -z "${bmr_file1}" ]; then
    _err_msg_="Failed to fetch BMR configuration file"
    abort_script "${_err_msg_}"
fi

$ECHO "change ${bmrconfig_path1}/${bmr_file1} to /var/tmp/${bmr_file1}" > /tmp/${_hostname_}_restore_bmrconfig1
local restore_file1=$($AWK '{print $2}' /tmp/${_hostname_}_restore_bmrconfig1 2>>${LOGFILE})

#Create progress log file to save bprestore output
restore_bmrconf_proglog1="/usr/openv/netbackup/logs/${_hostname_}_bmr_restore_progress1.log"
$ECHO "\nRestore of BMR configuration file logs" >${restore_bmrconf_proglog1}

local restore_bmrconfig1="${NBU_BIN}/bprestore -s ${_starttime_} -e ${_endtime_} -S `hostname` -C ${_hostname_} -D ${_hostname_} -L ${restore_bmrconf_proglog1}  -H -R /tmp/${_hostname_}_restore_bmrconfig1 ${restore_file1}"

if [ -z "${restore_bmrconf_proglog1}" -o -z "/tmp/${_hostname_}_restore_bmrconfig1" -o -z "${restore_file1}" ]; then
    log_msg -q -s "Actual Command: bprestore -s {_starttime_} -e {_endtime_} -S {ombs_hname} -C {_hostname_} -D {_hostname_} -L {restore_bmrconf_proglog}  -H -R /tmp/{_hostname_}_restore_bmrconfig {restore_file}" -l {LOGFILE} -w
    log_msg -q -s "Failed command: bprestore -s ${_starttime_} -e ${_endtime_} -S ${ombs_hname} -C ${_hostname_} -D ${_hostname_} -L ${restore_bmrconf_proglog1}  -H -R /tmp/${_hostname_}_restore_bmrconfig1 ${restore_file1}" -l {LOGFILE} -w
    _err_msg_="Failed to frame bprestore command."
    abort_script "${_err_msg_}"
fi

log_msg -s "Executing ${restore_bmrconfig1} " -l ${LOGFILE} -w
${restore_bmrconfig1} >>${LOGFILE} 2>&1
if [ $? -ne 0 ]; then
    _err_msg_="Restore of BMR configuration file to /var/tmp failed. Exiting...\nRefer ${LOGFILE} for more information."
    abort_script "${_err_msg_}"
fi

log_msg -s "Restoring BMR configuration file to /var/tmp.\n"
$SLEEP 10

count_1=1
jobid=$($GREP 'Restore Job Id=' ${restore_bmrconf_proglog1} 2>>${LOGFILE} | $AWK -F'=' '{print $2}')
if [ ! "${jobid}" ]; then
    err_msg_="Could not get the value for jobid"
    abort_script "${_err_msg_}"
fi
$SLEEP 5
while [ ! "${jobtype}" -a "${count_1}" -le 6 ]; do
    jobtype=$(${NBU_ADMIN}/bpdbjobs -report | $GREP -w ${jobid} | $AWK '{print $2}')
    if [ "${jobtype}" ]; then
        break;
    else
        $SLEEP 10
        count_1=$($EXPR ${count_1} + 1)
        continue
    fi
done
if [ ! "${jobtype}" ]; then
    err_msg_="Could not get the value for jobtype"
    abort_script "${_err_msg_}"
fi
validate_restore ${jobid} ${jobtype} ${restore_file1} /var/tmp ${restore_bmrconf_proglog1} 10

$RM -rf /tmp/${_hostname_}_restore_bmrconfig1
$CP ${restore_bmrconf_proglog1} ${ENIQ_CLIENT_CONFIG_DIR}

insert_header_footer foot "Successfully completed ${NEXT_STAGE} stage on ${_hostname_}" ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`

}

### Function : restore_conf####
#
# Restore /ericsson/ombsl/eniq_stats_blade/raw_clients/${_hostname_}/conf/
# Arguments:
#       none
# Return Values:
#       none
restore_conf()
{
log_msg  -s "Starting to restore conf directory on OMBS" -l ${LOGFILE}

# Initialize variables
_bladetype_=$1

fetch_details_from_conf_file

    if [ "${_bladetype_}" == "stats_coordinator" -o "${_bladetype_}" == "eniq_stats" ]; then
           _bkup_opt_=`$CAT ${CLNT_CONF_OMBS_DIR}/eniq_backup.conf |$GREP -w BKUP_OPTION_STR | $AWK -F '=' '{print $2}'`
            if [ ! "${_bkup_opt_}" ]; then
                _err_msg_="Could not get value of _bkup_opt_ from ${CLNT_CONF_OMBS_DIR}/eniq_backup.conf file."
                abort_script "${_err_msg_}"
            fi

        if [ "${_bkup_opt_}" == "FullData" ]; then
            local count=0
            restore_conf_proglog="/usr/openv/netbackup/logs/${_co_hostname_}_conf_restore_progress.log"
            $ECHO "conf directory  restore progress log" > $restore_conf_proglog

                restore_file=/ericsson/ombsl/eniq_stats_blade/raw_clients/${_co_hostname_}/conf

            
            ${NBU_BIN}/bplist -C `hostname` -S `hostname` -s ${_starttime_} -e ${_endtime_} -R 1 ${restore_file}/
            if [ $? -eq 0 ]; then
                #restore_file=$CLNT_CONF_DIR
                RESTORE_CONF_DATA="${NBU_BIN}/bprestore -s "${_starttime_}" -e "${_endtime_}" -S `hostname` -C `hostname` -D `hostname` -L $restore_conf_proglog ${restore_file}"
                $RESTORE_CONF_DATA >>${LOGFILE} 2>&1
                if [[ $? -ne 0 ]]; then
                    _err_msg_="\nRestore of conf data failed. Exiting....\n Check Below log and Netbackup GUI for more details.\n $restore_conf_proglog"
                    abort_script "${_err_msg_}"
                fi
                $ECHO "Restoring conf data. This would take some time...\n"
                count_1=1
                jobid=$($GREP 'Restore Job Id=' ${restore_conf_proglog} 2>> ${LOGFILE} | $AWK -F'=' '{print $2}')
                if [ ! "${jobid}" ]; then
                    err_msg_="Could not get the value for jobid"
                    abort_script "${_err_msg_}"
                fi
                $SLEEP 5
                while [ ! "${jobtype}" -a "${count_1}" -le 6 ]; do
                    jobtype=$(${NBU_ADMIN}/bpdbjobs -report | $GREP -w ${jobid} | $AWK '{print $2}')
                    if [ "${jobtype}" ]; then
                        break;
                    else
                        $SLEEP 10
                        count_1=$($EXPR ${count_1} + 1)
                        continue
                    fi
                done
                if [ ! "${jobtype}" ]; then
                    err_msg_="Could not get the value for jobtype"
                    abort_script "${_err_msg_}"
                fi
            
                validate_restore ${jobid} $jobtype ${restore_file} ${restore_file} $restore_conf_proglog 60
                $CP ${restore_conf_proglog} ${ENIQ_CLIENT_CONFIG_DIR}
                $RM -rf ${restore_conf_proglog}
                log_msg  -s "Successfully restored conf directory on OMBS" -l ${LOGFILE} 
            else 
                _err_msg_="There's no conf backup available for mentioned dates. The command ${NBU_BIN}/bplist -C `hostname` -S `hostname` -s ${_starttime_} -e ${_endtime_} -R 1 ${restore_file}/ gave no output."
                abort_script "${_err_msg_}"
            fi
        else
            $ECHO "Skipping this stage as this is NoData backup"
        fi
    else
        $ECHO "Skipping this stage as this is non coordinator blade."
    fi


}

### Function : o_restore_eniq####
#
# Restore /.ENIQ_BACKUP/eniq/ to /eniq
# Arguments:
#       none
# Return Values:
#       none
o_restore_eniq()
{
insert_header_footer head "Entering restore stage - ${NEXT_STAGE} on ${_hostname_}" ${LOGFILE}

fetch_details_from_conf_file

local count=0
restore_eniq_proglog="/usr/openv/netbackup/logs/${_hostname_}_eniq_restore_progress.log"

$ECHO "change /.ENIQ_BACKUP/eniq to /eniq" > /tmp/${_hostname_}_restore_eniq_data
$ECHO "Data restore progress log" > $restore_eniq_proglog
restore_file=/.ENIQ_BACKUP/eniq/

RESTORE_ENIQ_DATA="${NBU_BIN}/bprestore -s "${_starttime_}" -e "${_endtime_}" -S `hostname` -C ${_hostname_} -D ${_hostname_} -L $restore_eniq_proglog -H -R /tmp/${_hostname_}_restore_eniq_data ${restore_file}"

$RESTORE_ENIQ_DATA >>${LOGFILE} 2>&1

if [[ $? -ne 0 ]]; then
    _err_msg_="\nRestore of /eniq date failed. Exiting....\n Check Below log and Netbackup GUI for more details.\n $restore_eniq_proglog"
    abort_script "${_err_msg_}"
fi

$ECHO "Restoring /eniq data. This would take some time...\n"
$SLEEP 10
count_1=1
jobid=$($GREP 'Restore Job Id=' ${restore_eniq_proglog} 2>> ${LOGFILE} | $AWK -F'=' '{print $2}')
if [ ! "${jobid}" ]; then
    err_msg_="Could not get the value for jobid"
    abort_script "${_err_msg_}"
fi
while [ ! "${jobtype}" -a "${count_1}" -le 6 ]; do
    jobtype=$(${NBU_ADMIN}/bpdbjobs -report | $GREP -w ${jobid} | $AWK '{print $2}')
    if [ "${jobtype}" ]; then
        break;
    else
        $SLEEP 10
        count_1=$($EXPR ${count_1} + 1)
        continue
    fi
done
if [ ! "${jobtype}" ]; then
    err_msg_="Could not get the value for jobtype"
    abort_script "${_err_msg_}"
fi

validate_restore ${jobid} $jobtype ${restore_file} /eniq $restore_eniq_proglog 60

$CP ${restore_eniq_proglog} ${ENIQ_CLIENT_CONFIG_DIR}
insert_header_footer foot "Successfully completed ${NEXT_STAGE} stage on ${_hostname_}" ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### function: o_restore_raw ###
#
#  Restore RAW luns
#
# Arguments:
#       none
# Return Values:
#       none
o_restore_raw()
{
insert_header_footer head "Entering restore stage - ${NEXT_STAGE} on ${_hostname_}" ${LOGFILE}

fetch_details_from_conf_file

if [ "${_san_type_}" != "vnx" ]; then
    while true;
    do
        if [ -f ${ENIQ_CLIENT_CONFIG_DIR}/stage3_running ]; then
            log_msg -s  "Stage 3 Configure Storage API is still running on Reader1/Reader2" -l ${LOGFILE} -w
            $SLEEP 10
        else
            $TOUCH ${ENIQ_CLIENT_CONFIG_DIR}/raw_restore_running
            if [ $? -ne 0 ] ; then
                _err_msg_="Unable to Touch ${ENIQ_CLIENT_CONFIG_DIR}/raw_restore_running"
                abort_script "${_err_msg_}"
            fi
            break
        fi
    done
fi

_storage_type_=`$CAT ${SERVER_DETAILS_INFO_CONF} |$GREP STORAGE_TYPE | $AWK -F '=' '{print $2}'`
if [ "${_storage_type_}" != "fs" -a "${_storage_type_}" != "zfs" ]; then


    if [ "${_bladetype_}" == "stats_coordinator" -o "${_bladetype_}" == "eniq_stats" ]; then

        _bkup_opt_=`$CAT ${CLNT_CONF_OMBS_DIR}/eniq_backup.conf |$GREP -w BKUP_OPTION_STR | $AWK -F '=' '{print $2}'`
        if [ -z "${_bkup_opt_}" ]; then
            _err_msg_="Could not get value of _bkup_opt_ from ${CLNT_CONF_OMBS_DIR}/eniq_backup.conf file."
            abort_script "${_err_msg_}"
        fi

        if [ "${_bkup_opt_}" == "FullData" ] ; then
            RESTORE_TEMP=/ericsson/ombsl/eniq_stats_blade/etc/${_hostname_}/ombs_restore_${_hostname_}
            if [ ! -s ${RESTORE_TEMP}/raw_lun_file ]; then
                # Creating TEMP directory for RAW restore
                if [ -d ${RESTORE_TEMP} ]; then
                    $RM -rf ${RESTORE_TEMP}
                fi

                $MKDIR -p ${RESTORE_TEMP}
                if [ $? -ne 0 ]; then
                    _err_msg_="Could not create directory ${RESTORE_TEMP}"
                    abort_script "${_err_msg_}"
                fi
            fi

            #This file contains the backup path of ENIQ luns eg. /dev/dm-1
                _from_path_file_=${CLNT_CONF_DIR}/backup_luns_type

            if [ ! -s "${_from_path_file_}" ]; then
                    _err_msg_="${_from_path_file_} does not exist"
                    abort_script "${_err_msg_}"
            fi
            
            # ${_hostname_}_lun_details file contains the user selected luns
            _eniq_luns_to_attach_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_lun_details |$EGREP "MainDB|IQ_SYS_MAIN" |$AWK -F'::' '{print $3}'|xargs |$SED 's/ /,/g'`
            if [ -z "${_eniq_luns_to_attach_}" ]; then
                    _err_msg_="Could not get values of eniq luns to be attached to ombs server "
                    abort_script "${_err_msg_}"
            fi
            
            #Calling attach_detach_lun function to attach the ENIQ luns to OMBS 
            attach_detach_luns attach_lun ${_hostname_} ${_eniq_luns_to_attach_}
            if [ ! -s ${RESTORE_TEMP}/raw_lun_file ]; then
                for _entry_ in `$CAT ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_lun_details |$EGREP "MainDB|IQ_SYS_MAIN"`
                do
                    _lun_value_=`$ECHO "${_entry_}" | $AWK -F"::" '{print $3}'`
                    if [ -z "${_lun_value_}" ]; then
                        _err_msg_="Could not get lun value "
                        abort_script "${_err_msg_}"
                    fi

					_san_type_=`$CAT ${SERVER_DETAILS_INFO_CONF} |$GREP -w SAN_TYPE |$CUT -d "=" -f2`
					if [ -z "${_san_type_}" ];then
						_err_msg_="Could not get _san_type_ from ${SERVER_DETAILS_INFO_CONF}"
						abort_script "${_err_msg_}"
					fi

					if [ "${_san_type_}" == "vnx" ]; then
						_SAN_SCRIPT_="${SCRIPTHOME}/vnx_toolbox.bsh"
					else
						_SAN_SCRIPT_="${SCRIPTHOME}/unity_toolbox.bsh"
					fi
					
                    _mpath_value_=`$BASH ${_SAN_SCRIPT_} -c ${_hostname_} -a get_lun_det -f ${SERVER_DETAILS_INFO_CONF} -l ${_lun_value_} -S | $AWK -F'@@' '{print $NF}'`
                    if [ -z "${_mpath_value_}" ]; then
                        _err_msg_="Could not get mpath value for "
                        abort_script "${_err_msg_}"
                    fi

                    $ECHO "$_entry_" |$AWK -F'::' -v var="${_mpath_value_}" '{$(NF-1)=var FS $(NF-1);}1' OFS=:: >> ${RESTORE_TEMP}/ombs_mpath_file
                    if [ $? -ne 0 ]; then
                        _err_msg_="Could add ombs mpath value for ${_lun_value_} "
                        abort_script "${_err_msg_}"
                    fi

                done

                _to_path_file_=${RESTORE_TEMP}/ombs_mpath_file
                if [ ! -s "${_to_path_file_}" ]; then
                    _err_msg_="${_to_path_file_} does not exist"
                    abort_script "${_err_msg_}"
                fi

                $CAT ${_from_path_file_}  | $AWK -F"::" '$NF=="MainDB" {print $1,$2}' |$SORT -nrk2 |$AWK '{print $1}' > ${RESTORE_TEMP}/maindb_from_file.txt
                if [ ! -s "${RESTORE_TEMP}/maindb_from_file.txt" ]; then
                    _err_msg_="Could not get Maindb ${RESTORE_TEMP}/maindb_from_file.txt"
                    abort_script "${_err_msg_}"
                fi

                $CAT ${_to_path_file_}  | $AWK -F"::" '$2=="MainDB" {print $3,$NF}' |$SORT -nrk2 |$AWK '{print $1}' > ${RESTORE_TEMP}/maindb_to_file.txt
                if [ ! -s "${RESTORE_TEMP}/maindb_to_file.txt" ]; then
                    _err_msg_="Could not get Maindb ${RESTORE_TEMP}/maindb_to_file.txt"
                    abort_script "${_err_msg_}"
                fi

                _cnt_=0
                while read _line_; do
                    _from_path_[${_cnt_}]=${_line_}
                    let _cnt_=_cnt_+1
                done < ${RESTORE_TEMP}/maindb_from_file.txt

                _cnt_=0
                while read _line_; do
                    _to_path_[${_cnt_}]=${_line_}
                    let _cnt_=_cnt_+1
                done < ${RESTORE_TEMP}/maindb_to_file.txt

                for (( i=0; i<${#_from_path_[@]}; i++ ));do
                    $ECHO "Restore ${_from_path_[$i]} to /dev/mapper/${_to_path_[$i]}" >>${RESTORE_TEMP}/raw_lun_file
                done

                if [ ! -s "${RESTORE_TEMP}/raw_lun_file" ]; then
                    _err_msg_="Could not create ${RESTORE_TEMP}/raw_lun_file"
                    abort_script "${_err_msg_}"
                fi

                _sysmain_from_path_=`$CAT ${_from_path_file_} | $AWK -F"::" '$NF=="IQ_SYS_MAIN"  {print $1}'`
                if [ -z "${_sysmain_from_path_}" ]; then
                    _err_msg_="Could not get IQ_SYS_MAIN FROM value from ${_from_path_file_}"
                    abort_script "${_err_msg_}"
                fi

                _sysmain_to_path_=`$CAT ${_to_path_file_} |$AWK -F"::" '$2=="IQ_SYS_MAIN" {print $3}'`
                if [ -z "${_sysmain_to_path_}" ]; then
                    _err_msg_="Could not get IQ_SYS_MAIN TO path value ${_to_path_file_}"
                    abort_script "${_err_msg_}"
                fi

                $ECHO "Restore ${_sysmain_from_path_} to /dev/mapper/${_sysmain_to_path_}" >>${RESTORE_TEMP}/raw_lun_file
            fi

            ombs_hname=$(hostname)
            conf_hname=$($CAT /usr/openv/netbackup/bp.conf | $GREP  EMMSERVER | $AWK -F'= ' '{print $2}' | $XARGS)
            if [ "${ombs_hname}" != "${conf_hname}" ]; then
                _err_msg_="Conflict in OMBS Server hostname and bp.conf entry"
                abort_script "${_err_msg_}"
            fi

            unset _lun_list_
            if [ -f ${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status -o -f ${RESTORE_TEMP}/raw_lun_restore_status_temp ] ;then
                if [ ! -f ${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status ]; then
                    $CP -rp ${RESTORE_TEMP}/raw_lun_restore_status_temp ${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status
                fi

                _lun_pending_count_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status | $GREP -v "Done:0" |$WC -l|$TR -d " "`
                if [ ${_lun_pending_count_} -eq 0 ]; then
                    log_msg -s "Raw luns restore has been already completed" -l ${LOGFILE} -w
                else
                       _lun_list_check_=`$CAT ${RESTORE_TEMP}/raw_lun_file |$GREP Restore |$AWK '{print $2}'`
                       if [ ! "${_lun_list_check_}" ]; then
                           _err_msg_="Could not get list of luns from $CAT ${RESTORE_TEMP}/raw_lun_file"
                           abort_script "${_err_msg_}"
                       fi
                fi
                    validate_raw_restore_check
                    _lun_list_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status | $EGREP -v "Done:0|Active|Queued"| $AWK -F: '{print $1}'`
                    if [ -z "${_lun_list_}" ]; then
                        log_msg -s "Raw luns restore has been already completed" -l ${LOGFILE} -w
                    fi
            else

                   _lun_list_=`$CAT ${RESTORE_TEMP}/raw_lun_file |$GREP Restore |$AWK '{print $2}'`
                   if [ ! "${_lun_list_}" ]; then
                        _err_msg_="Could not get list of luns from $CAT ${RESTORE_TEMP}/raw_lun_file"
                        abort_script "${_err_msg_}"
                   fi

            fi

            for _raw_lun_full_path_ in ${_lun_list_}
            do

                    _raw_lun_=`$ECHO ${_raw_lun_full_path_} |cut -d "/" -f3`
                    $CAT ${RESTORE_TEMP}/raw_lun_file |$GREP -w ${_raw_lun_} |$SED 's/Restore/change/g' >${RESTORE_TEMP}/${_raw_lun_}_raw_lun.chg


                   local restore_file=`$CAT ${RESTORE_TEMP}/raw_lun_file |$GREP -w ${_raw_lun_} |$AWK '{print $2}'`
                   local restore_to_file=`$CAT ${RESTORE_TEMP}/raw_lun_file |$GREP -w ${_raw_lun_} |$AWK '{print $NF}'`


                #Create progress log file to save bprestore output
                restore_bmrconf_proglog="/usr/openv/netbackup/logs/${_raw_lun_}_raw_restore_progress.log"
                $ECHO "\n Restore of ${_raw_lun_} raw lun to ${restore_to_file} logs" >${restore_bmrconf_proglog}
                local restore_raw_lun="${NBU_BIN}/bprestore -s ${_starttime_} -e ${_endtime_} -S ${ombs_hname} -C ${ombs_hname} -D ${ombs_hname} -L ${restore_bmrconf_proglog}  -H -r -R ${RESTORE_TEMP}/${_raw_lun_}_raw_lun.chg ${restore_file}"
                
                if [ -z "${restore_bmrconf_proglog}" -o -z "/tmp/${_hostname_}_restore_bmrconfig" -o -z "${restore_file}" ]; then
                    log_msg -q -s "Actual Command: bprestore -s {_starttime_} -e {_endtime_} -S {ombs_hname} -C {_hostname_} -D {_hostname_} -L {restore_bmrconf_proglog}  -H -R ${RESTORE_TEMP}/${_raw_lun_}_raw_lun.chg {restore_file}" -l {LOGFILE} -w
                    log_msg -q -s "Failed command: bprestore -s ${_starttime_} -e ${_endtime_} -S ${ombs_hname} -C ${_hostname_} -D ${_hostname_} -L ${restore_bmrconf_proglog}  -H -R ${RESTORE_TEMP}/${_raw_lun_}_raw_lun.chg ${restore_file}" -l {LOGFILE} -w
                    _err_msg_="Failed to frame bprestore command."
                    abort_script "${_err_msg_}"
                fi
                
                ${restore_raw_lun} >>${LOGFILE} 2>&1
                
                if [ $? -ne 0 ]; then
                    _err_msg_="Restore of raw lun ${restore_file} to ${restore_to_file} failed. Exiting...\nExiting...\nRefer ${LOGFILE} for more information."
                    abort_script "${_err_msg_}"
                fi

                log_msg -s "Restoring raw lun ${restore_file} to ${restore_to_file}\n"
                $SLEEP 10
                $GREP 'Restore Job Id=' ${restore_bmrconf_proglog} | $AWK -F'=' '{print $2}'>${ENIQ_CLIENT_CONFIG_DIR}/${_raw_lun_}_jobid
                if [ ! -s "${ENIQ_CLIENT_CONFIG_DIR}/${_raw_lun_}_jobid" ]; then
                    _err_msg_="Could not get jobid for ${_raw_lun_}"
                    abort_script "${_err_msg_}"
                fi
                $CP ${restore_bmrconf_proglog} ${ENIQ_CLIENT_CONFIG_DIR}
            done
        validate_raw_restore
        
        #Calling attach_detach_lun function to detach the ENIQ luns from OMBS ,since restore is completed
        attach_detach_luns detach_lun ${_hostname_} ${_eniq_luns_to_attach_}  
        
        else
            log_msg -s "Skipping this stage,it is only applicable for FullData restore" -l ${LOGFILE} -w
        fi
    else
        log_msg -s "Skipping this stage,it is only applicable for Coordinator server" -l ${LOGFILE} -w
    fi
else
    log_msg -s "Skipping this stage,it is only applicable for BLADE server" -l ${LOGFILE} -w
fi

if [ "${_san_type_}" != "vnx" ]; then
    $RM -rf ${ENIQ_CLIENT_CONFIG_DIR}/raw_restore_running
    if [ $? -ne 0 ] ; then
        _err_msg_="Unable to remove ${ENIQ_CLIENT_CONFIG_DIR}/raw_restore_running"
        abort_script "${_err_msg_}"
    fi
fi

insert_header_footer foot "Successfully completed ${NEXT_STAGE} stage on ${_hostname_}" ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function : o_restore_root####
#
# Restore / to /tmp/root_disk
#
# Arguments:
#       none
# Return Values:
#       none
o_restore_root()
{
insert_header_footer head "Entering restore stage - ${NEXT_STAGE} on ${_hostname_}" ${LOGFILE}

fetch_details_from_conf_file

local count=0
local change_file=/tmp/${_hostname_}"_root_restore_c_file"
restore_root_proglog="/usr/openv/netbackup/logs/${_hostname_}_root_restore_progress.log"

$ECHO "change / to /tmp/root_disk" > ${change_file}
$ECHO "Root restore progress log" > ${restore_root_proglog}

RESTORE_BMR_ROOT="${NBU_BIN}/bprestore -s "${_starttime_}" -e "${_endtime_}" -S `hostname` -C ${_hostname_} -D ${_hostname_} -L ${restore_root_proglog} -H -R ${change_file} / !/.ENIQ_BACKUP"

${RESTORE_BMR_ROOT} >>${LOGFILE} 2>&1
if [ $? -ne 0 ]; then
    _err_msg_="\nRestore of root [/] failed. Exiting....\n Check Below log and Netbackup GUI for more details.\n ${restore_root_proglog}"
    abort_script "${_err_msg_}"
fi

$ECHO "Restoring root data. This would take some time...\n"
$SLEEP 10

count_1=1
jobid=$($GREP 'Restore Job Id=' ${restore_root_proglog} 2>> ${LOGFILE} | $AWK -F'=' '{print $2}')
if [ ! "${jobid}" ]; then
    err_msg_="Could not get the value for jobid"
    abort_script "${_err_msg_}"
fi
$SLEEP 5

while [ ! "${jobtype}" -a "${count_1}" -le 6 ]; do
    jobtype=$(${NBU_ADMIN}/bpdbjobs -report | $GREP -w ${jobid} | $AWK '{print $2}')
    if [ "${jobtype}" ]; then
        break;
    else
        $SLEEP 10
        count_1=$($EXPR ${count_1} + 1)
        continue
    fi
done
if [ ! "${jobtype}" ]; then
    err_msg_="Could not get the value for jobtype"
    abort_script "${_err_msg_}"
fi
validate_restore ${jobid} $jobtype / /tmp/root_disk ${restore_root_proglog} 60
$CP ${restore_root_proglog} ${ENIQ_CLIENT_CONFIG_DIR}

insert_header_footer foot "Successfully completed ${NEXT_STAGE} stage on ${_hostname_}" ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`

}

### Function: o_ssh_conf###
#
# Setting password less ssh connection
#
# Arguments:
#   none
# Return Values:
#   none
o_ssh_conf()
{
insert_header_footer head "Entering restore stage - ${NEXT_STAGE} on ${_hostname_}" ${LOGFILE}

# Creates a token for security authentication
create_token

_token_value_=`${NBU_BIN}/nbcertcmd -displayToken -name ${_token_name_} | $GREP "Token Value" | $AWK '{print $NF}' | $TEE -a ${_logfile_}`
if [ ! "{_token_value_}" ] ; then
    _err_msg_="Failed to fetch token value"
    abort_script "${_err_msg_}"
fi

#  Change to netbackup directory

$EXPECT <<EOF
set timeout 600
spawn  $BASH /usr/openv/netbackup/bin/install_client_files ssh ${_hostname_}
expect {
"Token (leave blank for no authorization token)"  {send "${_token_value_}\r";exp_continue}
"Java GUI and JRE option:"  {send "2\r";exp_continue}
"ERROR" {send_user "\nERROR!!!\n"; exit 1}
timeout {send_user "\nTIMEOUT!\n"; exit 9}
}
EOF

if [ $? -ne 0 ] ; then
    _err_msg_="Failed to execute the script"
    abort_script "${_err_msg_}"
fi

${NBU_ADMIN}/bpgetconfig -s "${_host_name_}" | $TEE -a ${_logfile_} >>/dev/null 2>&1
_res_2_=`$ECHO ${PIPESTATUS[0]}`
if [ ${_res_2_} -ne 0 ] ; then
    nbu_connectivity_setup
fi

insert_header_footer foot "Successfully completed ${NEXT_STAGE} stage on ${_hostname_}" ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`

}

### Function: password_authentication ###
#
#   Reboot the eniq client
#
# Arguments:
#       $1 - String to display the prompt for taking password input.
#       $2 - Variable that will contain the encrypted password.
#       $3 - username for whom password is authenticated.
# Return Values:
#       none
password_authentication(){
while true; do
    $ECHO "$1"
    _password_1_=$(/usr/bin/perl -e 'system ("stty -echo");my $_temp_password_ =<STDIN>; print $_temp_password_; system ("stty echo");')
    $ECHO "Re-enter password for user $3 "
    _password_2_=$(/usr/bin/perl -e 'system ("stty -echo");my $_temp_password_1 =<STDIN>;print $_temp_password_1; system ("stty echo");')
    if [  $_password_1_ ==  $_password_2_ ]; then
        break
    else
        $ECHO "The passwords do not match.Please enter again."
        continue
    fi
done

encrypted_password=$($ECHO "${_password_2_}" | /usr/bin/openssl enc -aes-256-ctr -md sha512 -a -salt -pass pass:"${STRONG_PASSPHRASE}")
if [ -z "{encrypted_password}" ]; then
    err_msg_="Could not encrypt the password for $3 user"
    abort_script "${_err_msg_}"
fi
eval "$2=\"\${encrypted_password}\""
}


### Function: password_decryption ###
#
#   Reboot the eniq client
#
# Arguments:
#       $1 - Password to be decrypted
#       $2 - Variable which will hold the final password
# Return Values:
#       none
password_decryption()
{
_decrypted_password_=$($ECHO "$1" | /usr/bin/openssl enc -aes-256-ctr -md sha512 -a -d -salt -pass pass:"${STRONG_PASSPHRASE}")
if [ ! "${_decrypted_password_}" ]; then
    _err_msg_="Could not decrypt password $1 "
    abort_script "${_err_msg_}"
fi

_decrypt_pw_=$(/usr/bin/perl -e 'print quotemeta shift(@ARGV)' "${_decrypted_password_}")
if [ ! "${_decrypt_pw_}" ]; then
    _err_msg_="Could not decrypt password $1 "
    abort_script "${_err_msg_}"
fi

eval "$2=\"\$_decrypt_pw_\""
}
### Function: reboot_client ###
#
#   Reboot the eniq client
#
# Arguments:
#       $1 - To identify if this function has been called from e_reboot_client function
# Return Values:
#       none
reboot_client()
{

log_msg -s  "Initiating client reboot on ${_hostname_}" -l ${LOGFILE} -w
_os_version_name_=`$RUN_REM_CMD ${DEFAULT_USER}@${_client_ip_} $UNAME -a | $AWK '{print $1}'`
if [ ! "${_os_version_name_}" ]; then
    _err_msg_="Could not get OS version of ${_host_name_}"
    abort_script "${_err_msg_}"
fi

$RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "$INIT 6" >>/dev/null 2>&1
if [ $? -ne 255 -a "${_os_version_name_}" == "Linux" -o $? -ne 0 -a "${_os_version_name_}" == "SunOS" ]; then
    _err_msg_="Could not reboot server ${_hostname_}"
    abort_script "${_err_msg_}"
else
    log_msg -s "Reboot would take sometime... " -l ${LOGFILE} -w
    $SLEEP 120
    while true;
    do
        $PING -c 1 ${_clientip_} >>/dev/null 2>&1
        if [ $? -ne 0 ]; then
            log_msg -s  "Reboot of ${_hostname_} still in progress, Please wait for some more time...." -l ${LOGFILE} -w
            $SLEEP 30
            continue
        else
            $SLEEP 10
            $RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "$UNAME -a" >>/dev/null 2>&1
            if [ $? -ne 0 ]; then
                _client_password_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_server_details.conf |$AWK  -F "CLIENT_PASSWORD=" '{print $2}'`
                if [ ! "${_client_password_}" ]; then
                    _err_msg_="Could not read value CLIENT_PASSWORD from ${ENIQ_CLIENT_CONFIG_DIR}/${_hostname_}_server_details.conf"
                    abort_script "${_err_msg_}"
                fi
                password_decryption "$_client_password_" _decrypt_pw_
                _decrypt_pw_=${_decrypt_pw_}
_reboot_count_=2
log_msg -s "Establishing password less connectivity with ENIQ." -l ${LOGFILE} 
while [ ${_reboot_count_} -ne 0 ]; do
                $EXPECT <<EOF >>${LOGFILE} 2>&1
                set timeout 600
                spawn  /ericsson/ombsl/bin/ssh_setup --host ${_hostname_}
                expect {
                "Please enter the password for"  {send --  "${_decrypt_pw_}\r";exp_continue}
                "Error" {send_user "\nERROR!!!\n"; exit 1}
                timeout {send_user "\nTIMEOUT!\n"; exit 9}
                }
EOF
                if [ $? -ne 0 ] ; then
                    _reboot_count_=$((_reboot_count_-1))
                    log_msg -s "Failed to establish password less connectivity. Retrying.." -l ${LOGFILE}
                    $SLEEP 20
                else
                    break
                fi
done
                if [ "${_reboot_count_}" -eq 0  ]; then
                    _err_msg_="Failed to execute the  /ericsson/ombsl/bin/ssh_setup script for ${_hostname_} "
                    abort_script "${_err_msg_}"
                fi
            fi
            #Check for the validity of the already created token otherwise create a new one.
            ${NBU_ADMIN}/bpgetconfig -s "${_host_name_}" | $TEE -a ${_logfile_} >>/dev/null 2>&1
            _res_4_=`$ECHO ${PIPESTATUS[0]}`
            if [ ${_res_4_} -ne 0 ]; then
                nbu_connectivity_setup
                log_msg -s "Server reboot has been completed " -l ${LOGFILE} -w
                break
            else
                log_msg -s "Server reboot has been completed" -l ${LOGFILE} -w
                break
            fi
        fi
    done
fi
}  

### Function: restore_build_stage_array ###
#
# it builds the array of restore stage list
#
# Arguments:
#   none
# Return Values:
#   none
restore_build_stage_array()
{

log_msg -s "Determining which stage file to use" -l ${LOGFILE} -w
_stage_file_=${RESTORE_STAGE_FILE}
if [ ! -s ${_stage_file_} ]; then
    log_msg -s "Could not find ${_stage_file_} file, or it is empty" -l ${LOGFILE} -w
    return 1
fi
log_msg -s "Building stage list from ${_stage_file_}\n" -l ${LOGFILE} -w

# Remove stages that are commented out
if [ -f ${ENIQ_CLIENT_CONFIG_DIR}/stage_list_file ]; then
    $RM -rf ${ENIQ_CLIENT_CONFIG_DIR}/stage_list_file
    if [ $? -ne 0 ]; then
        _err_msg_="Could not delete ${ENIQ_CLIENT_CONFIG_DIR}/stage_list_file file"
        abort_script "${_err_msg_}"
    fi
fi

counter=0
while true
do
    $CAT ${_stage_file_} | $EGREP -v '^[    ]*#' | $SED -e 's/ //g' > ${ENIQ_CLIENT_CONFIG_DIR}/stage_list_file
    if [ $? -ne 0 ]; then
        let counter=counter+1
        if [ ${counter} -eq 5 ]; then
            log_msg -s  "Could not remove comments from ${_stage_file_} file" -l ${LOGFILE} -w
            return 1
        fi
    else
        break
    fi
done

_cnt_=0
while read _line_; do
    _inst_stage_=`$ECHO ${_line_} | $AWK '{print $1}' | $SED -e 's/ //g'`
    # Store the details in an array
    ENIQ_CORE_STAGES[${_cnt_}]=${_inst_stage_}
    let _cnt_=_cnt_+1
done < ${ENIQ_CLIENT_CONFIG_DIR}/stage_list_file
}

### Function : restore_ombs_cfg####
#
# Restore /.ENIQ_BACKUP/eniq/ to /eniq
# Arguments:
#       none
# Return Values:
#       none
restore_ombs_cfg()
{
log_msg  -s "Starting to restore ombs_cfg directory on OMBS" -l ${LOGFILE} 

# Initialize variables
_bladetype_=$1

fetch_details_from_conf_file

    if [ "${_bladetype_}" == "stats_coordinator" -o "${_bladetype_}" == "eniq_stats" ]; then
        local count=0
        restore_ombs_cfg_proglog="/usr/openv/netbackup/logs/${_co_hostname_}_ombs_cfg_restore_progress.log"
        $ECHO "ombs_cfg directory  restore progress log" > $restore_ombs_cfg_proglog
        $ECHO "change /.ENIQ_BACKUP/eniq/bkup_sw/ombs_cfg to /ericsson/ombsl/eniq_stats_blade/raw_clients/${_co_hostname_}/conf/ombs_cfg" > /tmp/${_hostname_}_restore_ombs_cfg
        restore_file=/.ENIQ_BACKUP/eniq/bkup_sw/ombs_cfg
        RESTORE_CONF_DATA="${NBU_BIN}/bprestore -s "${_starttime_}" -e "${_endtime_}" -S `hostname` -C ${_co_hostname_} -D `hostname` -L $restore_ombs_cfg_proglog -H -R /tmp/${_hostname_}_restore_ombs_cfg ${restore_file}"
        $RESTORE_CONF_DATA >>${LOGFILE} 2>&1


        if [[ $? -ne 0 ]]; then
            _err_msg_="\nRestore of ombs_cfg data failed. Exiting....\n Check Below log and Netbackup GUI for more details.\n $restore_ombs_cfg_proglog"
            abort_script "${_err_msg_}"
        fi
        $ECHO "Restoring ombs_cfg data. This would take some time...\n"
        count_1=1
        jobid=$($GREP 'Restore Job Id=' ${restore_ombs_cfg_proglog} 2>> ${LOGFILE} | $AWK -F'=' '{print $2}')
        if [ ! "${jobid}" ]; then
            err_msg_="Could not get the value for jobid"
            abort_script "${_err_msg_}"
        fi
        $SLEEP 5
        while [ ! "${jobtype}" -a "${count_1}" -le 6 ]; do
            jobtype=$(${NBU_ADMIN}/bpdbjobs -report | $GREP -w ${jobid} | $AWK '{print $2}')
            if [ "${jobtype}" ]; then
                break;
            else
                $SLEEP 10
                count_1=$($EXPR ${count_1} + 1)
                continue
            fi
        done
        if [ ! "${jobtype}" ]; then
            err_msg_="Could not get the value for jobtype"
            abort_script "${_err_msg_}"
        fi
        ##################################### Need to check#####################
        validate_restore ${jobid} $jobtype ${restore_file} ${restore_file} $restore_ombs_cfg_proglog 60
        $CP ${restore_ombs_cfg_proglog} ${ENIQ_CLIENT_CONFIG_DIR}
        $RM -rf ${restore_ombs_cfg_proglog}
        log_msg  -s "Successfully restored ombs_cfg directory on OMBS" -l ${LOGFILE}
    else
        $ECHO "Skipping ombs_cfg restore as this is non coordinator blade."
    fi

 


}

### function: run_prebackup ###
#
#  execute prebackup to register OMBS on UNITY
#
# Arguments:
#       none
# Return Values:
#       none
run_prebackup()
{
log_msg  -s "Starting to run Prebackup on OMBS" -l ${LOGFILE} 

# Initialize variables
_blade_type_=$1

curr_server_type_=`$CAT ${SERVER_TYPE}`
if [ "${_curr_server_type_}" == "ENIQ_Statistics_Multi_Blade" ]; then
    _co_hostname_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details | $GREP -w stats_coordinator | $AWK -F: '{print $1}'`
    if [ ! "${_co_hostname_}" ]; then
        _err_msg_="Could not read value {_co_hostname_} from ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details"
        abort_script "${_err_msg_}"
    fi
else
    _co_hostname_=${_client_hostname_}
fi

if [ "${_blade_type_}" == "eniq_stats" -o "${_blade_type_}" == "stats_coordinator" ];then 
    _host_name_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details | $GREP ${_blade_type_} | $AWK -F: '{print $1}'`
    if [ -z "${_host_name_}" ];then
        _err_msg_="Could not get hostname from ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details file for ${_blade_type_}"
        abort_script "${_err_msg_}"
    fi

    _ombs_storage_hostname_=`$CAT ${SERVER_DETAILS_INFO_CONF} |$GREP -w SAN_HOST | $AWK -F '=' '{print $2}'`
    if [ -z "${_ombs_storage_hostname_}" ];then
        _err_msg_="Could not get _ombs_storage_hostname_ from ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details file for ${_blade_type_}"
        abort_script "${_err_msg_}"
    fi
    
    _ombs_storage_ip_=`$CAT ${SERVER_DETAILS_INFO_CONF} |$GREP -w OMBS_STORAGE_IP | $AWK -F '=' '{print $2}'`
    if [ -z "${_ombs_storage_ip_}" ];then
        _err_msg_="Could not get _ombs_storage_ip_"
        abort_script "${_err_msg_}"
    fi

    _san_type_=`$CAT ${SERVER_DETAILS_INFO_CONF} |$GREP -w SAN_TYPE |$CUT -d "=" -f2`
    if [ -z "${_san_type_}" ];then
        _err_msg_="Could not get _san_type_ from ${SERVER_DETAILS_INFO_CONF}"
        abort_script "${_err_msg_}"
    fi

    if [ "${_san_type_}" == "vnx" ];then
        _ombs_storage_grp_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/${_co_hostname_}_server_details.conf |$GREP OMBS_SG | $AWK -F '=' '{print $2}'`
        if [ -z "${_ombs_storage_grp_}" ];then
            _err_msg_="Could not get ombs_storage_group from ${RAW_CLIENTS_PATH}/${_host_name_}/conf/ombs_cfg/eniq_backup.conf"
            abort_script "${_err_msg_}"
        fi
    fi

    _ombs_storage_grp_pwd_1=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/${_co_hostname_}_server_details.conf | $AWK -F 'ADMIN_PASSWORD_1=' '{print $2}'`
    if [ -z "${_ombs_storage_grp_pwd_1}" ];then
        _err_msg_="Could not get ADMIN_PASSWORD_1 from ${ENIQ_CLIENT_CONFIG_DIR}/${_co_hostname_}_server_details.conf"
        abort_script "${_err_msg_}"
    fi

    password_decryption "${_ombs_storage_grp_pwd_1}" _ombs_storage_grp_pwd_
    _ombs_storage_grp_pwd_=${_ombs_storage_grp_pwd_}

    if [ "${_san_type_}" == "vnx" ];then
        $EXPECT <<EOF >>${LOGFILE} 2>&1
        set timeout 600
        spawn /ericsson/ombsl/eniq_stats_blade/bin/pre_backup.bsh -c ${_host_name_} -h ${_ombs_storage_hostname_} -i ${_ombs_storage_ip_} -p ${OMBS_CFG_PATH} -s ${_ombs_storage_grp_} -R
        expect {
        "password for"  {send -- "${_ombs_storage_grp_pwd_}\r";exp_continue}
        "Error" {send_user "\nERROR!!!\n"; exit 1}
        timeout {send_user "\nTIMEOUT!\n"; exit 9}
        }
EOF
        if [ $? -ne 0 ];then
            _err_msg_="Failed to run Prebackup on ${_san_type_}"
            abort_script "${_err_msg_}"
        fi
    elif [ "${_san_type_}" != "vnx" ];then
        $EXPECT <<EOF >>${LOGFILE} 2>&1
        set timeout 600
        spawn  /ericsson/ombsl/eniq_stats_blade/bin/pre_backup.bsh -c ${_host_name_} -h ${_ombs_storage_hostname_} -i ${_ombs_storage_ip_} -p ${OMBS_CFG_PATH} -R
        expect {
        "password for"  {send -- "${_ombs_storage_grp_pwd_}\r";exp_continue}
        "Error" {send_user "\nERROR!!!\n"; exit 1}
        timeout {send_user "\nTIMEOUT!\n"; exit 9}
        }
EOF
        if [ $? -ne 0 ];then
            _err_msg_="Failed to run Prebackup on ${_san_type_}"
            abort_script "${_err_msg_}"
        fi
    fi
fi

log_msg  -s "Successfully executed Prebackup on OMBS" -l ${LOGFILE} 

}

### function: attach_detach_luns ###
#
#  Attach ENIQ luns to OMBS as luns host
#
# Arguments: 
#       attach_lun|detach_lun
# Return Values:
#       none
attach_detach_luns()
{
if [ $# -ne 3 ];then
    _err_msg_="Incorrect number of parameters passed to attach_detach_luns"
    abort_script "${_err_msg_}"
fi
_action_=$1
_host_name_=$2
_lun_list_=$3
_san_details_file_=${CLNT_CONF_DIR}/${_host_name_}_san_details

_san_type_=`$CAT ${SERVER_DETAILS_INFO_CONF} |$GREP -w SAN_TYPE |$CUT -d "=" -f2`
if [ -z "${_san_type_}" ];then
    _err_msg_="Could not get _san_type_ from ${SERVER_DETAILS_INFO_CONF}"
    abort_script "${_err_msg_}"
fi

if [ "${_san_type_}" == "vnx" ]; then
	_SAN_SCRIPT_="${SCRIPTHOME}/vnx_toolbox.bsh"
else
	_SAN_SCRIPT_="${SCRIPTHOME}/unity_toolbox.bsh"
fi

$BASH ${_SAN_SCRIPT_} -c ${_host_name_} -a ${_action_} -l ${_lun_list_} -f ${SERVER_DETAILS_INFO_CONF}
if [ $? -ne 0 ];then
    _err_msg_="Could not ${_action_} the ENIQ Luns to OMBS server "
    abort_script "${_err_msg_}"
else
    log_msg -s "Successfully ${_action_}ed the ENIQ Luns to OMBS server " -l ${LOGFILE} -w
fi

}

### Function: run_remote_cmd ###
#
#Runs a command on a remote sever and returns the return value from the command
#
# Arguments:
#   $1 : hostname/ip
#   $2 : command to be ran
#   $3 : optional logfile
#   $4 : optional user, defaults to root
#   $5 : disable force tty. If set to "disable_tty", disable forcing tty.
#        Should be disabled to run a command remotely and leave it
#        running on the remote machine after the calling script disconnects.
# Return Values:
#      : Return value from the command
run_remote_cmd()
{
    if [ "${1}" == "" ]; then
        _err_msg_="Must provide server"
        abort_script "${_err_msg_}"
    fi
    if [ "${2}" == "" ]; then
        _err_msg_="Must provide next available dbfile"
        abort_script "${_err_msg_}"
    fi
    if [ "${3}" != "" ]; then
        local _logfile_="${3}"
    fi
    if [ "${4}" != "" ]; then
        local _user_="${4}"
    else
        local _user_="root"
    fi
    if [ "${5}" != "" ]; then
        local _disable_tty_="${5}"
    else
        local _disable_tty_=""
    fi

    local _server_="${1}"
    local _cmd_="${2}"
    $PING ${_server_} 3 >> /dev/null 2>&1
    if [ $? -ne 0 ]; then
        ${ECHO} "failed to ping server $_server" | $TEE -a ${_logfile_}
        return 1
    fi

    # Default value for tty option is -t -t (unchanged):
    _tty_value="-t -t"
    if [ "${_disable_tty_}" == "disable_tty" ]; then
        _tty_value=""
    fi

    $SSH ${_tty_value} -o StrictHostKeyChecking=no -o BatchMode=yes -q $_user_@$_server_ ${_cmd_}
    return $?
}

### Function: run_restore_stages ###
#
# Execute restore stages as per stage list
#
# Arguments:
#   none
# Return Values:
#   none
run_restore_stages()
{
_hostname_=$1
_bladetype_=$2
_clientip_=$3

#STAGEFILE=${ENIQ_CLIENT_CONFIG_DIR}/current_restore_stage_${_hostname_}

# Create a stage array

restore_build_stage_array
if [ $? -ne 0 ]; then
    _err_msg_="Could not build a stage array for ${CURR_SERVER_TYPE}"
    abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi


if [ "$USER_STAGE" ]; then
    NEXT_STAGE="${USER_STAGE}"
    # Get the element number so we can move along the array
    get_array_element
else
    get_next_stage
fi

# If we read done from the stagefile
if [ "${NEXT_STAGE}" == "done" ]; then
    # We exit unless the user specified that the stage be run again
    if [ ! "$USER_STAGE" ]; then
        $ECHO "Restore stages are already completed "
        exit 0
    fi
fi

if [ -f "${ENIQ_CLIENT_CONFIG_DIR}/.restore_stage_failure_${_hostname_}_${NEXT_STAGE}" ];then
    $RM ${ENIQ_CLIENT_CONFIG_DIR}/.restore_stage_failure_${_hostname_}_${NEXT_STAGE}
fi

# Loop through the stages for restore
while :; do

    # If we read done from the stagefile
    if [ "${NEXT_STAGE}" == "done" ]; then
        break
    fi

    _nxt_stage_="${NEXT_STAGE}"
    ${_nxt_stage_}
    if [ $? -ne 0 ]; then
        _err_msg_="Error in Stage ${NEXT_STAGE}"
        abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
    fi

    # Exit if the user specified to run a specific stage only
    if [ "$USER_STAGE" ]; then
        break
    fi


    # Exit if the user specified to run a stop at a certain stage only
    if [ "${_stop_stage_}" ]; then
        # Exit if the user specified to run a stop at a certain stage only
        if [ "${NEXT_STAGE}" == "${_stop_stage_}" ]; then
            $ECHO "\n\nStopping after stage ${NEXT_STAGE} at user request"
            $RM -f ${ENIQ_CONF_DIR}/extra_params/stop_stage
            break
        fi
    fi

    get_next_stage
done

}

### Function: o_security_authentication ###
#
# Validate the security
#
# Arguments:
#       none
# Return Values:
#       none
o_security_authentication()
{
insert_header_footer head "Entering restore stage - ${NEXT_STAGE} on ${_hostname_}" ${LOGFILE}

# Creates a token for security authentication
create_token

insert_header_footer foot "Successfully completed ${NEXT_STAGE} stage on ${_hostname_}" ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`

}

### Function: set_conf_value ###
#
#   Common function to set value in file
#   having the param=value format
#
# Arguments:
#       $1 : Parameter name
#       $2 : Value
#       $3 : File name
# Return Values:
#       none
set_conf_value()
{
if [ $# -ne 3 ];then
    _err_msg_="Incorrect number of parameters passed to set_conf_value"
    abort_script "${_err_msg_}"
fi

_param_=$1
_value_=$2
_file_=$3

# Update param=value
# Check if the param exists in file

$GREP "^${_param_}=" ${_file_} >> /dev/null 2>&1
if [ $? -ne 0 ];then
    $ECHO "${_param_}=${_value_}" >> ${_file_}
else
    $CAT ${_file_} | $SED -e 's|^[       ]*'${_param_}'=.*|'${_param_}=${_value_}'|' > ${TEM_DIR}/updated_file.$$.$$
    if [ $? -ne 0 ];then
        _err_msg_="Failed to update ${_param_} value in ${_file_}"
        abort_script "${_err_msg_}"
    fi
    $MV ${TEM_DIR}/updated_file.$$.$$ ${_file_}
    if [ $? -ne 0 ];then
        _err_msg_="Failed to save ${_param_} value in ${_file_}"
        abort_script "${_err_msg_}"
    fi
fi
}

### Function: setup_env ###
#
# Set up environment variables for script.
#
# Arguments:
#   none
# Return Values:
#   none
setup_env()
{

#SSH command with options
RUN_REM_CMD="$SSH -o StrictHostKeyChecking=no -o BatchMode=yes"

#SCP with options
SCP="/usr/bin/scp -o StrictHostKeyChecking=no"

# Default user
DEFAULT_USER=root

#temporary Log location
LOG_LOC=/var/tmp

#Eniq core install directory
ENIQ_CORE_INST_DIR=/eniq/installation/core_install

#Setting last restore stage for CO and NON-CO blades
CO_MID_STAGE=done
NON_CO_MID_STAGE=e_reboot_client_1
SECOND_RUN_MID_STAGE=e_reboot_client_1
SECOND_RUN_LAST_STAGE=done

#This file contains restore stage list
RESTORE_STAGE_FILE=${SCRIPTHOME}/../etc/restore_stagelist

#SERVER_TYPE=${ENIQ_CLIENT_CONFIG_DIR}/server_type_file
ENIQ_BASE_DIR=/eniq
ENIQ_ADMIN_BIN_DIR=${ENIQ_BASE_DIR}/admin/bin

BLKCLI=/ericsson/storage/san/bin/blkcli
TMP=/tmp

#Eniq shared file system to OMBS
OMBS_CFG_PATH=/eniq/bkup_sw

#Creating Passphrase for Encryption
STRONG_PASSPHRASE=$(hostname)"@OmBs"

}

### Function: set_next_stage ###
#
# Set up the stage to be run
#
# Arguments:
#   $1 : Stage to be set to. Either numeric value or 'cleanup'
# Return Values:
#   none
set_next_stage()
{
# Do I have to reset stage
if [ "${USER_STAGE}" -a "${NO_RESET_STAGE}" ]; then
    return 0
fi

_stage_time_=`$DATE '+%Y-%b-%d_%H.%M.%S'`
$ECHO "# Setting new stage at ${_stage_time_}" > ${STAGEFILE} | $TEE -a ${LOGFILE}
$ECHO "${ENIQ_CORE_STAGES[$1]} " >> ${STAGEFILE} | $TEE -a ${LOGFILE}
}

### Function: sort_the_array ###
#
# It will sort and array which is used in get_lun_list
#
# Arguments:
#  none
# Return Values:
#   none
sort_the_array () 
{
for ((i=0; i <= $((${#_dsk_size[@]} - 2)); ++i))
do
    for ((j=((i + 1)); j <= ((${#_dsk_size[@]} - 1)); ++j))
    do
        if [[ ${_dsk_size[i]} -gt ${_dsk_size[j]} ]]
        then
            # echo $i $j ${_dsk_size[i]} ${_dsk_size[j]}
            tmp=${_dsk_size[i]}
            _dsk_size[i]=${_dsk_size[j]}
            _dsk_size[j]=$tmp
        fi
    done
done
}

### Function: stage_3_check ###
#
# 
#
# Arguments:
#       none
# Return Values:
#         none
stage_3_check()
{
case $_bladetype_ in
        stats_engine)
            _dependant_hostname_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details |$GREP stats_coordinator |$AWK -F: '{print $1}'`
            ;;
        dwh_reader_1)
            _dependant_hostname_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details |$GREP stats_engine |$AWK -F: '{print $1}'`
            ;;
        dwh_reader_2)
            _dependant_hostname_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details |$GREP dwh_reader_1 |$AWK -F: '{print $1}'`
            ;;
esac

_stagefile_dependent_=${ENIQ_CLIENT_CONFIG_DIR}/current_restore_stage_${_dependant_hostname_}
if [ ! -z "${_stagefile_dependent_}" ]; then
    _dependent_host_curr_val_=`$CAT ${_stagefile_dependent_} |$GREP -v ^# | $SED -e 's| ||g'`
    if [ ! ${_dependent_host_curr_val_} ]; then
        _err_msg_="Failed to get the current stage for ${_dependant_hostname_}"
        abort_script "${_err_msg_}"
    fi
fi



if [ "${_dependent_host_curr_val_}" != "done" ]; then
    log_msg -s  "Restore is not completed on ${_dependant_hostname_}. Cannot proceed ahead until it's completed." -l ${LOGFILE} -w
    exit 0
fi


}
### Function: stop_roll_snap ###
#
# To stop roll snap service.
#
# Arguments:
#       none
# Return Values:
#         none
stop_roll_snap()
{

if [ "${_os_version_name_}" == "Linux" ]; then
    _roll_snap_id_=eniq-roll-snap.service
else
    _roll_snap_id_=roll-snap
fi
log_msg -s "Stopping ${_roll_snap_id_} service on ${_bladetype_}" -l ${LOGFILE} -w
local _command_="${ENIQ_ADMIN_BIN_DIR}/manage_eniq_services.bsh"
log_msg -s "Starting to run $BASH ${_command_} -a stop -s ${_roll_snap_id_} -N" -l ${LOGFILE} -w
$RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "$BASH ${_command_} -a stop -s ${_roll_snap_id_} -N" >/dev/null 2>&1
if [ $? -ne 0 ]; then
    _err_msg_="Exiting... Unable to stop ${_roll_snap_id_} service on ${_bladetype_}\n"
    abort_script "${_err_msg_}"
fi
log_msg -s "Successfully stopped ${_roll_snap_id_} service on ${_bladetype_}" -l ${LOGFILE} -w
}

### Function: stop_ddc_service ###
#
# To stop ddc service.
#
# Arguments:
#       none
# Return Values:
#         none
stop_ddc_service()
{
if [ "${_os_version_name_}" == "Linux" ]; then
    # DDC Service
    _ddc_smf_id_="ddc.service"
    log_msg -s "Stopping ${_ddc_smf_id_} service" -l ${LOGFILE} -w
    $RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "$SYSTEMCTL disable ${_ddc_smf_id_}" >/dev/null 2>&1
    if [ $? -ne 0 ]; then
        _err_msg_="Exiting... Unable to disable  ${_ddc_smf_id_} service \n"
        abort_script "${_err_msg_}"
    fi
    $RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "$SYSTEMCTL stop ${_serv_stop_name_}" >> /dev/null 2>&1
    if [ $? -ne 0 ]; then
        _err_msg_="Exiting... Unable to stop ${_ddc_smf_id_} service \n"
        abort_script "${_err_msg_}"
    fi
    log_msg -s "Successfully stopped ${_ddc_smf_id_} service" -l ${LOGFILE} -w
else
    # DDC Service
    _ddc_smf_id_="svc:/ericsson/eric_monitor/ddc:default"
    log_msg -s "Stopping ${_ddc_smf_id_} service" -l ${LOGFILE} -w
    $RUN_REM_CMD ${DEFAULT_USER}@${_clientip_} "$SVCADM disable ${_ddc_smf_id_}" >/dev/null 2>&1

    if [ $? -ne 0 ]; then
        _err_msg_="Exiting... Unable to stop ${_ddc_smf_id_} service \n"
        abort_script "${_err_msg_}"
    fi
    log_msg -s "Successfully stopped ${_ddc_smf_id_} service" -l ${LOGFILE} -w

fi
}

### Function: user_confirm ###
#
#   Take user confirmation
#
# Arguments:
#   $1 : User display message
# Return Values:
#   User response : YES/NO
user_confirm()
{
if [ $1 ] ;then
    _usr_msg_="$1"
else
    _usr_msg_="\n\nDo you want to proceed? (Yy/Nn)"
fi
unset _response_

while [ 1 ]
do
    $ECHO ${_usr_msg_}
    read ans

    case $ans in
        Y|y|YES|Yes|yes) _response_="YES"
                         break
                         ;;
        N|n|NO|No|no) _response_="NO"
                         break
                         ;;
        *) log_msg -s "\nInvalid input. Enter again." -l ${LOGFILE} -c 31
           ;;
    esac
done

}

### function: validate_raw_restore ###
#
# Validate the restore with Job id
#
# Arguments:
#
# Return Values:
#       none
validate_raw_restore()
{

while true; do
    for _lun_full_path_ in ${_lun_list_}
    do
        _lun_=`$ECHO ${_lun_full_path_} |cut -d "/" -f3`
        job_id=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/${_lun_}_jobid `
        if [ -z "${job_id}" ]; then
            _err_msg_="Could not get jobid for ${_lun_}"
            abort_script "${_err_msg_}"
        fi
        jobid_status=$(${NBU_ADMIN}/bpdbjobs -report | $AWK '{ if($1 == '$job_id') print $3;}')
        jobid_ecode=$(${NBU_ADMIN}/bpdbjobs -report | $AWK '{ if($1 == '$job_id') print $4;}')

        if [ -s "${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status" ]; then
            $GREP ${_lun_} ${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status >>/dev/null 2>&1
            if [ $? -eq 0 ]; then
                $CAT ${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status | $SED -e 's|^[       ]*'${_lun_}':.*|'${_lun_}:${job_id}:${jobid_status}:${jobid_ecode}'|' >${RESTORE_TEMP}/raw_lun_restore_status_temp
                if [ $? -ne 0 ]; then
                    _err_msg_="Could not create ${RESTORE_TEMP}/raw_lun_restore_status_temp "
                    abort_script "${_err_msg_}"
                fi
                $CP ${RESTORE_TEMP}/raw_lun_restore_status_temp ${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status
                if [ $? -ne 0 ]; then
                    _err_msg_="Could not copy ${RESTORE_TEMP}/raw_lun_restore_status_temp to ${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status "
                    abort_script "${_err_msg_}"
                fi
            else
                $ECHO "${_lun_}:${job_id}:${jobid_status}:${jobid_ecode}" >>${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status
                if [ $? -ne 0 ]; then
                    _err_msg_="Could add entry ${_lun_}:${job_id}:${jobid_status}:${jobid_ecode} to ${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status "
                    abort_script "${_err_msg_}"
                fi
            fi
        else
            $ECHO "${_lun_}:${job_id}:${jobid_status}:${jobid_ecode}" >>${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status
            if [ $? -ne 0 ]; then
                _err_msg_="Could add entry ${_lun_}:${job_id}:${jobid_status}:${jobid_ecode} to ${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status "
                abort_script "${_err_msg_}"
            fi
        fi
    done


    _done_count_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status | $EGREP -v "Done|Incomplete" |$WC -l |$TR -d " "`
    if [ ${_done_count_} -eq 0 ]; then
        break
    else
        $ECHO ".\c"
    fi
    $SLEEP 20

done

_failed_count_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status | $GREP -v "Done:0" |$WC -l`
if [ ${_failed_count_} -gt 1 ]; then
    $CAT ${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status | $GREP -v "Done:0" |$AWK '{print $1}'
    _err_msg_="Raw lun restore failed for above given luns  "
    abort_script "${_err_msg_}"
else
    $ECHO "Raw restore done"
fi
}

### function: validate_raw_restore_check ###
#
# Validate the restore with Job id and correct the file before re-run
#
# Arguments:
#
# Return Values:
#       none
validate_raw_restore_check()
{

for _lun_full_path_ in ${_lun_list_check_}
do
    _lun_=`$ECHO ${_lun_full_path_} |cut -d "/" -f3`
    job_id=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/${_lun_}_jobid `
    if [ -z "${job_id}" ]; then
        _err_msg_="Could not get jobid for ${_lun_}"
        abort_script "${_err_msg_}"
    fi
    jobid_status=$(${NBU_ADMIN}/bpdbjobs -report | $AWK '{ if($1 == '$job_id') print $3;}')
    jobid_ecode=$(${NBU_ADMIN}/bpdbjobs -report | $AWK '{ if($1 == '$job_id') print $4;}')

    if [ -s "${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status" ]; then
        $GREP ${_lun_} ${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status >>/dev/null 2>&1
        if [ $? -eq 0 ]; then
            $CAT ${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status | $SED -e 's|^[       ]*'${_lun_}':.*|'${_lun_}:${job_id}:${jobid_status}:${jobid_ecode}'|' >${RESTORE_TEMP}/raw_lun_restore_status_temp
            if [ $? -ne 0 ]; then
                _err_msg_="Could not create ${RESTORE_TEMP}/raw_lun_restore_status_temp "
                abort_script "${_err_msg_}"
            fi
            $CP ${RESTORE_TEMP}/raw_lun_restore_status_temp ${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status
            if [ $? -ne 0 ]; then
                _err_msg_="Could not copy ${RESTORE_TEMP}/raw_lun_restore_status_temp to ${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status "
                abort_script "${_err_msg_}"
            fi
        else
            $ECHO "${_lun_}:${job_id}:${jobid_status}:${jobid_ecode}" >>${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status
            if [ $? -ne 0 ]; then
                _err_msg_="Could add entry ${_lun_}:${job_id}:${jobid_status}:${jobid_ecode} to ${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status "
                abort_script "${_err_msg_}"
            fi
        fi
    else
        $ECHO "${_lun_}:${job_id}:${jobid_status}:${jobid_ecode}" >>${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status
        if [ $? -ne 0 ]; then
            _err_msg_="Could add entry ${_lun_}:${job_id}:${jobid_status}:${jobid_ecode} to ${ENIQ_CLIENT_CONFIG_DIR}/raw_lun_restore_status "
            abort_script "${_err_msg_}"
        fi
    fi
done

}

### function: validate_restore ###
#
# Validate the restore with Job id
#
# Arguments:
#       job_id, job_type, restore_file, dest_path, log, sleep_time
# Return Values:
#       none
validate_restore()
{
local cnt=0
local cnt1=0
job_id=$1
job_type=$2
restore_file=$3
dest_path=$4
log=$5
sleep_time=$6

for((i=0;;i++)); do
    jobid_status=$(${NBU_ADMIN}/bpdbjobs -report | $AWK '{ if($1 == '$job_id') print $3;}')
        for ((j=0;;j++)); do
            jobid_status=$(${NBU_ADMIN}/bpdbjobs -report | $AWK '{ if($1 == '$job_id') print $3;}')
            if [ "${jobid_status}" == "Queued" ]; then
                if [ ${cnt1} == 0 ]; then
                    log_msg -s "Restore is in queued state."
                fi
                cnt1=$($EXPR $cnt1 + 1)
                $SLEEP 30
            else
                break
            fi
        done
        if [ "${jobid_status}" !=  "Active" ]; then
        jobid_ecode=$(${NBU_ADMIN}/bpdbjobs -report | $AWK '{ if($1 == '$job_id') print $4;}')
            if [ "${jobid_status}" == "Done" -a ${jobid_ecode} == 0 ]; then
                $ECHO "##### Restore of ${restore_file} to ${dest_path} logs #####" >>${LOGFILE}
                log_msg -s "\nRestore of ${restore_file} to ${dest_path} is successful." -l ${LOGFILE} -w
                break
            else
                $ECHO "##### Restore of ${restore_file} to ${dest_path} logs #####" >>${LOGFILE}
                log_msg -s "\nRestore of ${restore_file} to ${dest_path} failed.\nExiting..." -l ${LOGFILE} -w
                local failreason="$($GREP -w Status ${log} | $CUT -f2 -d'=')"
                _err_msg_="Restore failed with ${failreason}"
                abort_script "${_err_msg_}"
            fi
        elif [ "${job_type}" == "Restore" ]; then
            for ((j=0;;j++)); do
                jobid_status=$(${NBU_ADMIN}/bpdbjobs -report | $AWK '{ if($1 == '$job_id') print $3;}')
                if [ "${jobid_status}" == "Queued" ]; then
                    if [ ${cnt1} == 0 ]; then
                        log_msg -s "Restore is in queued state."
                    fi
                    cnt1=$($EXPR $cnt1 + 1)
                    $SLEEP 30
                else
                    break
                fi
            done
            if [ ${cnt} == 0 ]; then
                log_msg -s "Restore is in progress"
            else
                $PRINTF ". "
            fi
            cnt=$($EXPR $cnt + 1)
            $SLEEP ${sleep_time} >> /dev/null 2>&1
        else
            _err_msg_="Mismatch in Job ID ${job_id} and Job Type ${job_type}"
            abort_script "${_err_msg_}"
        fi
done

}

# ********************************************************************
#
#   Main body of program
#
# ********************************************************************
#

#Get the absolute path of the script
get_absolute_path

# Set up environment variables for script.
setup_env

# Check that the effective id of the user is root
check_id ${DEFAULT_USER}

while getopts ":c:" arg; do
  case $arg in
    c) ENIQ_CLIENT="$OPTARG"
       RESUME=YES
       ;;
    \?) usage_msg
       exit 1
       ;;
  esac
done
shift `$EXPR $OPTIND - 1`

# Log file
LOGFILE=${LOG_LOC}/user_input.log

# Create a temporary Directory
TEM_DIR=/tmp/ombs_restore.$$.$$
$RM -rf ${TEM_DIR}
$MKDIR -p ${TEM_DIR}
if [ $? -ne 0 ]; then
    _err_msg_="Could not create directory ${TEM_DIR}"
    abort_script "${_err_msg_}"
fi

#This will skip getting user input ,if inputs are already present
if [ "${RESUME}" != "YES" ];then
    get_user_input
else
    ENIQ_CLIENT_CONFIG_DIR=/ericsson/ombsl/eniq_stats_blade/etc/${ENIQ_CLIENT}
    if [ ! -d ${ENIQ_CLIENT_CONFIG_DIR} ];then
        _err_msg_="ENIQ config directory ${ENIQ_CLIENT_CONFIG_DIR} does not exist,cannot resume eniq restore"
        abort_script "${_err_msg_}"
    fi
    SERVER_TYPE=${ENIQ_CLIENT_CONFIG_DIR}/server_type_file
    RAW_CLIENTS_PATH=${SCRIPTHOME}/../raw_clients
    CLIENT_DIR=${RAW_CLIENTS_PATH}/${ENIQ_CLIENT}
    CLNT_CONF_DIR=${CLIENT_DIR}/conf
    CLNT_CONF_OMBS_DIR=${CLNT_CONF_DIR}/ombs_cfg

fi



while true
do
    $ECHO "The root password for OMBS server: \n"
    read -s _ombs_password_
    if [ ! -z ${_ombs_password_} ]; then
        break
    fi
done
$ECHO "unixpwd" > ${SCRIPTHOME}/../etc/ombs_server_info
$ECHO `hostname` >> ${SCRIPTHOME}/../etc/ombs_server_info
$ECHO "root" >> ${SCRIPTHOME}/../etc/ombs_server_info
$ECHO "${_ombs_password_}" >> ${SCRIPTHOME}/../etc/ombs_server_info

_curr_server_type_=`$CAT ${SERVER_TYPE}`
if [ "${_curr_server_type_}" != "ENIQ_Statistics_Multi_Blade" ]; then
    _client_list_="eniq_stats"
else
    _client_list_="stats_engine dwh_reader_1 dwh_reader_2 stats_coordinator"
fi

if [ ${_curr_server_type_} != "ENIQ_Statistics_Rack_Server" ]; then
    for _client_ in `$CAT ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details | $EGREP "stats_engine|dwh_reader_1|dwh_reader_2|stats_coordinator|eniq_stats" | $AWK -F: '{print $1}'`
    do
        if [ ! -s ${ENIQ_CLIENT_CONFIG_DIR}/${_client_}_lun_details ]; then
            _err_msg_="${ENIQ_CLIENT_CONFIG_DIR}/${_client_}_lun_details is not created. Please rerun script using command bash eniq_ombs_restore.bsh"
            abort_script "${_err_msg_}"
        fi
    done
fi


## First loop ,It will run upto stage 3 for NON-CO blades and upto stage 6 for CO blade ################
for _blade_type_ in  ${_client_list_}
do
    _host_name_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details | $GREP ${_blade_type_} | $AWK -F: '{print $1}'`
    if [ -z "${_host_name_}" ];then
        _err_msg_="Could not get hostname from ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details file for ${_blade_type_}"
        abort_script "${_err_msg_}"
    fi


    _bkup_opt_=`$CAT ${CLNT_CONF_OMBS_DIR}/eniq_backup.conf |$GREP -w BKUP_OPTION_STR | $AWK -F '=' '{print $2}'`
    if [ -z "${_bkup_opt_}" ]; then
        _err_msg_="Could not read value {_bkup_opt_} from ${CLNT_CONF_OMBS_DIR}/eniq_backup.conf"
        abort_script "${_err_msg_}"
     fi


    _client_ip_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details | $GREP ${_blade_type_} | $AWK -F: '{print $3}'`
    if [ -z "${_host_name_}" ];then
        _err_msg_="Could not get IP address from ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details file for ${_blade_type_}"
        abort_script "${_err_msg_}"
    fi


    SERVER_DETAILS_INFO_CONF="${ENIQ_CLIENT_CONFIG_DIR}/${_host_name_}_server_details.conf"
    LOGFILE=${ENIQ_CLIENT_CONFIG_DIR}/restore_${_host_name_}.log
    STAGEFILE=${ENIQ_CLIENT_CONFIG_DIR}/current_restore_stage_${_host_name_}
    _storage_type_=`$CAT ${SERVER_DETAILS_INFO_CONF} |$GREP STORAGE_TYPE | $AWK -F '=' '{print $2}'`
    if [ "${_blade_type_}" == "eniq_stats" -o "${_blade_type_}" == "stats_coordinator" ];then
        insert_header_footer head  "Starting restore on ${_host_name_} ${_blade_type_}" ${LOGFILE}
        check_run_restore_stages_status
        #Check if thread for CO is already running
        if [ "${PROC_STATUS}" == "RUNNING" ];then
            log_msg -s "First Thread for ${_blade_type_} is already running" -l ${LOGFILE} -c 33
        else
            if [ "${MID_STAGE}" ==  "HIGHER" ];then
                $ECHO $$ >${ENIQ_CLIENT_CONFIG_DIR}/pid_${_host_name_}
                if [ ! -s "${ENIQ_CLIENT_CONFIG_DIR}/pid_${_host_name_}" ];then
                    _err_msg_="Could not create pid file pid_${_host_name_} for ${_host_name_}"
                    abort_script "${_err_msg_}"
                fi
                _os_version_name_=`$RUN_REM_CMD ${DEFAULT_USER}@${_client_ip_} $UNAME -a | $AWK '{print $1}'`
                if [ ! "${_os_version_name_}" ]; then
                    _err_msg_="Could not get OS version of ${_host_name_}"
                    abort_script "${_err_msg_}"
                fi

                if [ ${_curr_server_type_} == "ENIQ_Statistics_Rack_Server" ]; then
                    if [ "${_os_version_name_}" == "Linux" ]; then
                        _storage_type_="fs"
                    else
                        _storage_type_="zfs"
                    fi
                fi
                run_restore_stages ${_host_name_} ${_blade_type_} ${_client_ip_} |$TEE -a ${LOGFILE}
            else
                log_msg -s "\nRestore Thread for ${_blade_type_} is already completed" -l ${LOGFILE} -c 32
            fi
        fi
    else
        check_run_restore_stages_status
        if [ "${PROC_STATUS}" == "RUNNING" ];then
            insert_header_footer head  "Starting restore on ${_host_name_} ${_blade_type_} " ${LOGFILE}
            log_msg -s "\nRestore thread for ${_blade_type_} is already running" -l ${LOGFILE} -c 33
        else
            if [ "${MID_STAGE}" ==  "HIGHER" ];then
                insert_header_footer head  "Starting restore on ${_host_name_} ${_blade_type_} " ${LOGFILE}
                log_msg -s "Restore stages for ${_blade_type_} started to run in background. \n\nRefer to ${LOGFILE} for detailed logging" -l ${LOGFILE}
                _os_version_name_=`$RUN_REM_CMD ${DEFAULT_USER}@${_client_ip_} $UNAME -a | $AWK '{print $1}'`
                if [ ! "${_os_version_name_}" ]; then
                    _err_msg_="Could not get OS version of ${_host_name_}"
                    abort_script "${_err_msg_}"
                fi

                if [ ${_curr_server_type_} == "ENIQ_Statistics_Rack_Server" ]; then
                    if [ "${_os_version_name_}" == "Linux" ]; then
                        _storage_type_="fs"
                    else
                        _storage_type_="zfs"
                    fi
                fi
                run_restore_stages ${_host_name_} ${_blade_type_} ${_client_ip_} >>${LOGFILE} &
                $ECHO $! >${ENIQ_CLIENT_CONFIG_DIR}/pid_${_host_name_}
                if [ ! -s "${ENIQ_CLIENT_CONFIG_DIR}/pid_${_host_name_}" ];then
                    _err_msg_="Could not create pid file pid_${_host_name_} for ${_host_name_}"
                    abort_script "${_err_msg_}"
                fi
            elif [ "${MID_STAGE}" ==  "EQUAL" ];then
                log_msg -s "\nRestore stage for ${_blade_type_} is already completed upto stage3" -l ${LOGFILE} -c 32
            else
                insert_header_footer head  "Restore completed on ${_host_name_} ${_blade_type_} " ${LOGFILE}

            fi
        fi
    fi
done

_co_stage_=`$CAT $STAGEFILE | $GREP -v ^#|$TR -d " "`
if [ "${_curr_server_type_}" == "ENIQ_Statistics_Multi_Blade" -a "${_co_stage_}" == "done" ]; then
    for _blade_type_ in  `$ECHO ${_client_list_} |$SED 's/stats_coordinator//g' `
    do
        _host_name_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details | $GREP ${_blade_type_} | $AWK -F: '{print $1}'`
        if [ -z "${_host_name_}" ];then
            _err_msg_="Could not get hostname from ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details file for ${_blade_type_}"
            abort_script "${_err_msg_}"
        fi
        _client_ip_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details | $GREP ${_blade_type_} | $AWK -F: '{print $3}'`
        if [ -z "${_host_name_}" ];then
            _err_msg_="Could not get ip address from ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details file for ${_blade_type_}"
            abort_script "${_err_msg_}"
        fi
        SERVER_DETAILS_INFO_CONF="${ENIQ_CLIENT_CONFIG_DIR}/${_host_name_}_server_details.conf"
        LOGFILE=${ENIQ_CLIENT_CONFIG_DIR}/restore_${_host_name_}.log
        STAGEFILE=${ENIQ_CLIENT_CONFIG_DIR}/current_restore_stage_${_host_name_}

        case $_blade_type_ in
        stats_engine)
            _dependant_hostname_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details |$GREP stats_coordinator |$AWK -F: '{print $1}'`
            ;;
        dwh_reader_1)
            _dependant_hostname_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details |$GREP stats_engine |$AWK -F: '{print $1}'`
            ;;
        dwh_reader_2)
            _dependant_hostname_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details |$GREP dwh_reader_1 |$AWK -F: '{print $1}'`
            ;;
        esac

        STAGEFILE=${ENIQ_CLIENT_CONFIG_DIR}/current_restore_stage_${_host_name_}
        if [ ! -s "${STAGEFILE}" ];then
            _err_msg_="Could not get current_restore_stage_${_host_name_} file for ${_blade_type_}"
            abort_script "${_err_msg_}"
        fi

        check_for_second_run current_restore_stage_${_dependant_hostname_} current_restore_stage_${_host_name_}
        if [ "${SECOND_RUN}" == "YES" ];then
            insert_header_footer head  "Starting restore on ${_host_name_} ${_blade_type_} " ${LOGFILE}
            $ECHO $$ >${ENIQ_CLIENT_CONFIG_DIR}/pid_${_host_name_}
            run_restore_stages $_host_name_ $_blade_type_ $_client_ip_ |$TEE -a ${LOGFILE}
        fi
    done
fi

if [ "${_curr_server_type_}" == "ENIQ_Statistics_Multi_Blade" ]; then
    _reader2_hostname_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details | $GREP dwh_reader_2 | $AWK -F: '{print $1}'`
    if [ ! "${_reader2_hostname_}" ]; then
        _err_msg_="Could not fetch reader2 hostname from ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details"
        abort_script "${_err_msg_}"
    fi

    _final_stage_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/current_restore_stage_${_reader2_hostname_} | $GREP -v ^#|$TR -d " "`
    if [ ! "${_final_stage_}" ]; then
        _err_msg_="Could not fetch final stage for reader2 from current_restore_stage_${_reader2_hostname_}"
        abort_script "${_err_msg_}"
    fi

    if [ "${_final_stage_}" == "done" ]; then
        _dir_zip_=YES
    fi
else
    if [ "${_co_stage_}" == "done" ]; then
        _dir_zip_=YES
    fi
fi

if [ "${_dir_zip_}" == "YES" ]; then
    $SLEEP 10
    _server_name_=`$CAT ${ENIQ_CLIENT_CONFIG_DIR}/eniq_client_details  | $EGREP -w 'stats_coordinator|eniq_stats' | $AWK  -F":" '{print $1}'`
    _monitor_pid_=`$PS all | $EGREP monitor_restore_status.bsh | $EGREP -w ${_server_name_} | $AWK  -F" " '{print $3}'`
    if [ ! -z ${_monitor_pid_} ]; then
        $KILL -9 ${_monitor_pid_}
    fi
    $SLEEP 10
    _date_=`$DATE '+%d_%m_%Y'`
     $TAR -czf ${ENIQ_CLIENT_CONFIG_DIR}_${_date_}.tar.gz ${ENIQ_CLIENT_CONFIG_DIR}
    if [ $? -ne 0 ]; then
     $ECHO "Could not gtar ${ENIQ_CLIENT_CONFIG_DIR}_${_date_} file. Please run the following command to create gtar manually: $TAR -czf ${ENIQ_CLIENT_CONFIG_DIR}_${_date_}.tar.gz ${ENIQ_CLIENT_CONFIG_DIR} and remove the ${ENIQ_CLIENT_CONFIG_DIR} using the command $RM -rf ${ENIQ_CLIENT_CONFIG_DIR}"
    else
        if [ -f ${ENIQ_CLIENT_CONFIG_DIR}_${_date_}.tar.gz ];then
            log_msg -s "Successfully created zip of ${ENIQ_CLIENT_CONFIG_DIR}_${_date_} file" -l ${LOGFILE}
            if [ -d "${ENIQ_CLIENT_CONFIG_DIR}" ]; then
                $RM -rf ${ENIQ_CLIENT_CONFIG_DIR}
                if [ $? -ne 0 ]; then
                    $ECHO "Could not remove ${ENIQ_CLIENT_CONFIG_DIR}. Run the following command to remove it manually:\n $RM -rf ${ENIQ_CLIENT_CONFIG_DIR}"
                else
                    $ECHO "Successfully removed ${ENIQ_CLIENT_CONFIG_DIR} directory. Restore is successfully completed."
                fi
            fi
        fi
    fi
fi

exit 0