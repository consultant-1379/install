#!/bin/bash
# ********************************************************************
# Ericsson Radio Systems AB                                     SCRIPT
# ********************************************************************
#
#
# (c) Ericsson Radio Systems AB 2023 - All rights reserved.
#
# The copyright to the computer program(s) herein is the property
# of Ericsson Radio Systems AB, Sweden. The programs may be used 
# and/or copied only with the written permission from Ericsson Radio 
# Systems AB or in accordance with the terms and conditions stipulated 
# in the agreement/contract under which the program(s) have been 
# supplied.
#
# ********************************************************************
# Name    : update_cell_node_count.bsh
# Date    : 11/10/2023
# Revision: main\29
# Purpose : Script to determine number of nodes to be managed,
#            whether to mirror storage pool, and to lay out disks
#            and node numbers in ini files
#
# Usage   : update_cell_node_count.bsh
#
# ********************************************************************
#
#     Command Section
#
# ********************************************************************
AWK=/usr/bin/awk
BASENAME=/usr/bin/basename
BC=/usr/bin/bc
CAT=/usr/bin/cat
CHMOD=/usr/bin/chmod
CP=/usr/bin/cp
DATE=/usr/bin/date
DF=/usr/bin/df
DIRNAME=/usr/bin/dirname
ECHO="/usr/bin/echo -e"
EGREP=/usr/bin/egrep
ENV=/usr/bin/env
EXPR=/usr/bin/expr
GETENT=/usr/bin/getent
GREP=/usr/bin/grep
HEAD=/usr/bin/head
HOSTNAME=/usr/bin/hostname
ID=/usr/bin/id
LS=/usr/bin/ls
MKDIR=/usr/bin/mkdir
MULTIPATH=/usr/sbin/multipath
PRINTF=/usr/bin/printf
PWD=/usr/bin/pwd
RAW=/usr/bin/raw
RM=/usr/bin/rm
SED=/usr/bin/sed
SORT=/usr/bin/sort
SLEEP=/usr/bin/sleep
SU=/usr/bin/su
TAIL=/usr/bin/tail
TEE=/usr/bin/tee
TOUCH=/usr/bin/touch
UDEVADM=/usr/sbin/udevadm
WC=/usr/bin/wc
ZFS=/usr/sbin/zfs
ZPOOL=/usr/sbin/zpool

# ********************************************************************
#
#       Configuration Section
#
# ********************************************************************
# Name of SunOS & ENIQ ini Files
ENIQ_ENV=niq.rc
ENIQ_INI=niq.ini
SUNOS_INI=SunOS.ini
SYM_INI=sym_links.ini

# List of available network types
AVAIL_NETWORK_TYPES="CORE GRAN WRAN"

# Minimum size in MBytes that IQ sys main can be
IQ_SYS_MAIN_MIN_SIZE=25600

# ********************************************************************
#
#       Pre-execution Operations
#
# ********************************************************************

# ********************************************************************
#
#     Functions
#
# ********************************************************************
### Function: abort_script ###
#
#   This will is called if the script is aborted thru an error
#   error signal sent by the kernel such as CTRL-C or if a serious
#   error is encountered during runtime
#
# Arguments:
#       $1 - Error message from part of program (Not always used)
# Return Values:
#       none
abort_script()
{
if [ "$1" ]; then
    _err_msg_=$1
else
    _err_msg_="Script aborted.......\n"    
fi

# Check if log_msg() is defined
type log_msg > /dev/null 2>&1
if [ $? -gt 0 ]; then
    if [ "${LOGFILE}" ]; then
        $ECHO "\n${_err_msg_}\n" |$TEE -a ${LOGFILE}
    else
        $ECHO "\n${_err_msg_}\n"
    fi
else
    if [ "${LOGFILE}" ]; then
        log_msg -s "\n${_err_msg_}\n" ${LOG_OUT_STR}
    else
        log_msg -s "\n${_err_msg_}\n"
    fi
fi

cd $SCRIPTHOME

$RM -rf ${conn_str_dbping_enc}							  
$RM -rf ${TEM_DIR}

if [ "$2" ]; then
    ${2}
else
    exit 1
fi
}

### Function: calculate_iq_sys_main_details ###
#
# Calculate number of IQ SYS dbspaces required and the
# size of each dbspace
#
# Arguments:
#       none
# Return Values:
#       none
calculate_iq_sys_main_details()
{
local _chk_
unset NEXT_SYS_MAIN_DBSPACE_NUM

if [ -s ${TEM_DIR}/dbspace_file_loc_ini ]; then 
    # Determine if there more than one entry. If there is there will be a file that will end in
    # iq_system_main_[1-9].iq
    _chk_=`$CAT ${TEM_DIR}/dbspace_file_loc_ini|$EGREP '^[[:blank:]]*DWH_SYSTEM_MAIN_[1-9].*_[1-9]+\.iq[[:blank:]]*$'`

    if [ "${_chk_}" ]; then
        NEXT_SYS_MAIN_DBSPACE_NUM=`$CAT ${TEM_DIR}/dbspace_file_loc_ini|$EGREP '^[[:blank:]]*DWH_SYSTEM_MAIN_[1-9]' \
           |$AWK  '{print $2}'|$SED -e 's|\(.*_\)\(.*\)\(\.iq\)|\2|'|$SORT -n|$TAIL -1`
        NEXT_SYS_MAIN_DBSPACE_NUM=`$EXPR ${NEXT_SYS_MAIN_DBSPACE_NUM} + 1`
    else
    NEXT_SYS_MAIN_DBSPACE_NUM=1
    fi
else
    _err_msg_="No IQ SYS MAIN DBspace details read from IQ"
    abort_script "$_err_msg_" 
fi

if [ ! "${NEXT_SYS_MAIN_DBSPACE_NUM}" ]; then
    _err_msg_="Could not determine next IQ SYS MAIN DBspace number"
    abort_script "$_err_msg_" 
fi
}

### Function: calculate_main_dbspace_details ###
#
# Calculate number of main dbspaces required and the
# size of each dbspace
#
# Arguments:
#       none
# Return Values:
#       none
calculate_main_dbspace_details()
{
unset NUM_MAIN_DBSPACES
unset MAIN_SPACE_PER_DBSPACE
unset START_MAIN_DBSPACE_NUM

if [ "${MAIN_USER_NUM_SPACE}" ]; then
    NUM_MAIN_DBSPACES=${MAIN_USER_NUM_SPACE}
else
    NUM_MAIN_DBSPACES=10
fi

MAIN_SPACE_PER_DBSPACE=`$EXPR ${1} / ${NUM_MAIN_DBSPACES}`
if [ ${MAIN_SPACE_PER_DBSPACE} -eq 0 ]; then
    MAIN_SPACE_PER_DBSPACE=1
fi

if [ -s ${TEM_DIR}/dbspace_file_loc_ini ]; then 
    START_MAIN_DBSPACE_NUM=`$CAT ${TEM_DIR}/dbspace_file_loc_ini|$EGREP '^[[:blank:]]*DWH_DBSPACES_MAIN_[1-9]' \
           |$AWK  '{print $2}'|$SED -e 's|\(.*_\)\(.*\)\(\.iq\)|\2|'|$SORT -n|$TAIL -1`
    START_MAIN_DBSPACE_NUM=`$EXPR ${START_MAIN_DBSPACE_NUM} + 1`
else
    START_MAIN_DBSPACE_NUM=1
fi

if [ ! "${START_MAIN_DBSPACE_NUM}" ]; then
    _err_msg_="Could not determine next Main DBspace number"
    abort_script "$_err_msg_" 
fi
}

### Function: calculate_temp_dbspace_details ###
#
# Calculate number of temp dbspaces required and the
# size of each dbspace
#
# Arguments:
#       none
# Return Values:
#       none
calculate_temp_dbspace_details()
{
unset NUM_TEMP_DBSPACES
unset TEMP_SPACE_PER_DBSPACE
unset START_TEMP_DBSPACE_NUM

if [ "${TEMP_USER_NUM_SPACE}" ]; then
    NUM_TEMP_DBSPACES=${TEMP_USER_NUM_SPACE}
else
    NUM_TEMP_DBSPACES=5
fi

TEMP_SPACE_PER_DBSPACE=`$EXPR ${1} / ${NUM_TEMP_DBSPACES}`
if [ ${TEMP_SPACE_PER_DBSPACE} -eq 0 ]; then
    TEMP_SPACE_PER_DBSPACE=1
fi

if [ -s ${TEM_DIR}/dbspace_file_loc_ini ]; then 
    START_TEMP_DBSPACE_NUM=`$CAT ${TEM_DIR}/dbspace_file_loc_ini|$EGREP '^[[:blank:]]*DWH_DBSPACES_TEMP_[1-9]' \
           |$AWK  '{print $2}'|$SED -e 's|\(.*_\)\(.*\)\(\.iqtmp\)|\2|'|$SORT -n|$TAIL -1`
    START_TEMP_DBSPACE_NUM=`$EXPR ${START_TEMP_DBSPACE_NUM} + 1`
else
    START_TEMP_DBSPACE_NUM=1
fi

if [ ! "${START_TEMP_DBSPACE_NUM}" ]; then
    _err_msg_="Could not determine next Temp DBspace number"
    abort_script "$_err_msg_" 
fi
}

### Function: check_disk_space ###
#
# Check that the there is adequate disk space
# for the cell/node configuration.
#
# Arguments:
#       $1 : none
# Return Values:
#       none
check_disk_space()
{
# Check if we need to updated IQ SYS MAIN Size
chk_iq_sys_main_size

if [ "${UPDATE_SYS_MAIN_DBSPACE_FLAG}" ]; then
    # Get the next IQ SYS MAIN NUMBER
    calculate_iq_sys_main_details ${IQ_SYS_MAIN_UPDATE_SPACE}
fi

# The % of total ZFS space we will reserve for ZFS itself and for taking 
# Snapshots etc.
_zfs_buf_size_=`iniget SunOS_ZFS_BUF_SIZE -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v zfs_buf_size`
if [ $? -ne 0 ]; then
    _err_msg_="Could not get ZFS buffer information from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
    abort_script "$_err_msg_"
fi

# Total disk space available
_tot_disk_space_=0
_zfs_filesys_name_=`$DF -k ${CLI_CONF_DIR}|$TAIL -1|$AWK '{print $1}'`
_pool_avail_=`$ZFS list -H -o avail ${_zfs_filesys_name_}`

_char_=`$ECHO ${_pool_avail_: -1}`
_pool_avail_=`$ECHO ${_pool_avail_}|$SED -e 's|[MKGT]||g'`

if [ ! "${_char_}" ]; then
    _avail_in_mbytes_=0
else
    if [ "${_char_}" == "K" ]; then
        _avail_in_mbytes_=0
    elif [ "${_char_}" == "M" ]; then
        _avail_in_mbytes_=`$ECHO "${_pool_avail_} "|$AWK -F\. '{print$1}'`
    elif [ "${_char_}" == "G" ]; then
        _avail_in_mbytes_=`$ECHO "${_pool_avail_} * 1024 "|$BC|$AWK -F\. '{print$1}'`
    elif [ "${_char_}" == "T" ]; then
        _avail_in_mbytes_=`$ECHO "${_pool_avail_} * 1024 * 1024"|$BC|$AWK -F\. '{print$1}'`
    else
        _err_msg_="Unrecognised character returned from $ZFS list command"
        abort_script "$_err_msg_"
    fi
fi
log_msg -s "\nTotal amount of space available in Zpool is ${_avail_in_mbytes_}Mb" ${LOG_OUT_STR} -q

_tot_pool_size_=0
for _pool_name_ in  `$ZPOOL list -H -o name | $GREP -v rpool`; do
    _pool_size_=`$ZPOOL list -H -o size ${_pool_name_}`

    # Get the last character. I need to know if I am dealing with KB,MB etc
    _char_=`$ECHO ${_pool_size_: -1}`
    _pool_size_=`$ECHO ${_pool_size_}|$SED -e 's|[MKGT]||g'`

    if [ ! "${_char_}" ]; then
        _pool_size_in_mbytes_=0
    else
        if [ "${_char_}" == "K" ]; then
            _pool_size_in_mbytes_=0
        elif [ "${_char_}" == "M" ]; then
            _pool_size_in_mbytes_=`$ECHO "${_pool_size_}" |$AWK -F\. '{print$1}'`
        elif [ "${_char_}" == "G" ]; then
            _pool_size_in_mbytes_=`$ECHO "${_pool_size_} * 1024 "|$BC|$AWK -F\. '{print$1}'`
        elif [ "${_char_}" == "T" ]; then
            _pool_size_in_mbytes_=`$ECHO "${_pool_size_} * 1024 * 1024"|$BC|$AWK -F\. '{print$1}'`
        else
            _err_msg_="Unrecognised character returned from $ZPOOL list command"
            abort_script "$_err_msg_"
        fi
    fi
    let _tot_pool_size_=_tot_pool_size_+${_pool_size_in_mbytes_}
done
log_msg -s "Total Zpool size is ${_tot_pool_size_}Mb" ${LOG_OUT_STR} -q

_zfs_buf_size_in_mbytes_=`$ECHO "${_tot_pool_size_} * .${_zfs_buf_size_}\)"|$BC|$AWK -F\. '{print$1}'`
log_msg -s "\nZFS buffer size is ${_zfs_buf_size_in_mbytes_}Mb" ${LOG_OUT_STR} -q
_avail_in_mbytes_=`$ECHO "${_avail_in_mbytes_} - ${_zfs_buf_size_in_mbytes_} - ${IQ_SYS_MAIN_UPDATE_SPACE}"|$BC|$AWK -F\. '{print$1}'`
log_msg -s "Total space available for expansion is ${_avail_in_mbytes_}Mb" ${LOG_OUT_STR} -q

if [ ${_avail_in_mbytes_} -le 0 ]; then
    log_msg -s "\nExiting........No Space available in Zpool for expansion" ${LOG_OUT_STR}
    exit 1   
fi    

#Checking the ratio of existing IQ_MAIN and IQ_TEMP
factor=`$ECHO "scale=1; ${TOTAL_MAIN_SYB_IQ_DBSPACE_SIZE}/${TOTAL_TEMP_SYB_IQ_DBSPACE_SIZE}" |$BC`
if [ $? -ne 0 ]; then
    _err_msg_="Could not calculate the existing ratio of IQ_MAIN to IQ_TEMP"
    abort_script "${_err_msg_}"
fi
factor_round_off=`$ECHO "($factor + 0.5)/1" |$BC`
if [ $? -ne 0 ]; then
    _err_msg_="Could not calculate the round off value of $factor" 
    abort_script "${_err_msg_}"
fi

#Calculate the value of IQ_TEMP to be added
EXPAND_IQ_TEMP=`$ECHO "${_avail_in_mbytes_} / (${factor_round_off} + 1)" | $BC | $AWK -F\. '{print$1}'`
if [ $? -ne 0 ]; then
    _err_msg_="Could not calculate the value to expand IQ_TEMP" 
    abort_script "${_err_msg_}"
else
    UPDATE_TEMP_DBSPACE_FLAG=Y
fi

#Calculate the value of IQ_MAIN to be added
EXPAND_IQ_MAIN=`$ECHO "${_avail_in_mbytes_} - ${EXPAND_IQ_TEMP}" | $BC | $AWK -F\. '{print$1}'`
if [ $? -ne 0 ]; then
    _err_msg_="Could not calculate the value to expand IQ_MAIN" 
    abort_script "${_err_msg_}"
else
    UPDATE_MAIN_DBSPACE_FLAG=Y
fi

if [ "${UPDATE_MAIN_DBSPACE_FLAG}" ]; then
    # Calculate number of main dbspaces required and the
    # size of each dbspace
    calculate_main_dbspace_details ${EXPAND_IQ_MAIN}
fi

if [ "${UPDATE_TEMP_DBSPACE_FLAG}" ]; then
    # Calculate number of temp dbspaces required and the
    # size of each dbspace
    calculate_temp_dbspace_details ${EXPAND_IQ_TEMP}
fi
}

### Function: check_exist_dbspaces ###
#
# Check the existing DBSPACES. Check that all dbspaces in the
# ini file exist and that all dbspaces exist in the ini file
#
# Arguments:
#       $1 : User ID name
# Return Values:
#       none
check_exist_dbspaces()
{
local _size_

SYBASEMSG=$TEM_DIR/sybasemsg.$$
##skip this step if the server is a reader, only do it if it's not a reader
if [ "${READER_SERVER_TYPE}" != "YES" ]; then
    test_iq_login dwhdb 0
    $CP $SYBASEMSG /tmp/iq_det
fi

# Define the sections I am interested in
local ini_sections="DWH_SYSTEM_MAIN DWH_DBSPACES_MAIN DWH_DBSPACES_TEMP"
##skip this step if the server is a reader
if [ "${READER_SERVER_TYPE}" != "YES" ]; then
    # Get a list of dbspace file paths referenced in Sybase IQ
    if [ $NEW ]; then
        # for 15.2 new output from sybase
        $CAT $SYBASEMSG|$AWK '{print $3}'|$EGREP '^\/' > ${TEM_DIR}/dbspace_file_loc_iq
        if [ $? -ne 0 ]; then
            _err_msg_="Cannot create list of dbspaces referenced in Sybase IQ"
            abort_script "$_err_msg_"
        fi
    else
        $CAT $SYBASEMSG|$AWK '{print $2}'|$EGREP '^\/' > ${TEM_DIR}/dbspace_file_loc_iq
        if [ $? -ne 0 ]; then
            _err_msg_="Cannot create list of dbspaces referenced in Sybase IQ"
            abort_script "$_err_msg_" 
        fi
    fi
fi

# Get a list of dbspace file paths referenced in niq.ini and 
$RM -f ${TEM_DIR}/dbspace_file_loc_ini
for _ini_ in ${ini_sections}; do
    _sub_sections_=`iniget ${_ini_} -f ${TEM_DIR}/${SYM_INI}`
    for _section_ in ${_sub_sections_}; do
        _file_path_=`iniget ${_section_} -f ${TEM_DIR}/${SYM_INI} -v Path`
    if [ ! "${_file_path_}" ]; then
        _err_msg_="No Path defined for ${_section_} in\n${TEM_DIR}/${SYM_INI}."
        abort_script "$_err_msg_" 
    fi
    ##Do this step if the server is a reader
    if [ "${READER_SERVER_TYPE}" == "YES" ]; then
        if [ ! -h ${_file_path_} ]; then
            _err_msg_="${_file_path_} defined for ${_section_} in\n${TEM_DIR}/${SYM_INI} does not exist or is empty."
            abort_script "$_err_msg_" 
        fi
    else
        if [ ! -c ${_file_path_} ]; then
            _err_msg_="${_file_path_} defined for ${_section_} in\n${TEM_DIR}/${SYM_INI} does not exist or is empty."
            abort_script "$_err_msg_" 
        fi
    fi
    $ECHO "${_section_} ${_file_path_}" >> ${TEM_DIR}/dbspace_file_loc_ini
    if [ $? -ne 0 ]; then
        _err_msg_="Cannot create list of dbspaces referenced in \n${TEM_DIR}/${SYM_INI}"
        abort_script "$_err_msg_" 
    fi
    done
done
##skip this step if the server is a reader
if [ "${READER_SERVER_TYPE}" != "YES" ]; then
    # Check that all dbspaces referenced in ${SYM_INI} exist in Sybase IQ
    while read _section_ _file_path_; do
        $EGREP "${_file_path_}" ${TEM_DIR}/dbspace_file_loc_iq >> /dev/null 2>&1
        if [ $? -ne 0 ]; then
            _err_msg_="${_file_path_} defined for ${_section_} in\n${SYM_INI} does not exist in IQ."
            abort_script "$_err_msg_" 
        fi
    done < ${TEM_DIR}/dbspace_file_loc_ini

    # Check that all dbspaces referenced in Sybase IQ exist in ${SYM_INI}
    while read _file_path_; do
        $EGREP "${_file_path_}" ${TEM_DIR}/dbspace_file_loc_ini >> /dev/null 2>&1
        if [ $? -ne 0 ]; then
            _err_msg_="${_file_path_} defined in Sybase IQ dies not exist in\n${SYM_INI}"
            abort_script "$_err_msg_" 
        fi
    done < ${TEM_DIR}/dbspace_file_loc_iq

    # Build up a total of all MAIN dbspace already allocated to Sybase IQ
    if [ $NEW ]; then
        # for 15.2 new output from sybase
        unset TOTAL_MAIN_SYB_IQ_DBSPACE_SIZE
        for _file_path_ in `$CAT $SYBASEMSG|$AWK '{if(($1 == "IQ_MAIN") || ($1 == "iq_main")) print $3}'`; do
            _size_=`$LS -l ${_file_path_}|$AWK '{print $5}'`
            let TOTAL_MAIN_SYB_IQ_DBSPACE_SIZE=TOTAL_MAIN_SYB_IQ_DBSPACE_SIZE+${_size_}
        done

        # Build up a total of all MAIN dbspace already allocated to Sybase IQ
        unset TOTAL_TEMP_SYB_IQ_DBSPACE_SIZE
        for _file_path_ in `$CAT $SYBASEMSG|$AWK '{if($1 == "IQ_SYSTEM_TEMP") print $3}'`; do
            _size_=`$LS -l ${_file_path_}|$AWK '{print $5}'`
            let TOTAL_TEMP_SYB_IQ_DBSPACE_SIZE=TOTAL_TEMP_SYB_IQ_DBSPACE_SIZE+${_size_}
        done
            
    else
        unset TOTAL_MAIN_SYB_IQ_DBSPACE_SIZE
        for _file_path_ in `$CAT $SYBASEMSG|$AWK '{if($3 == "MAIN") print $2}'`; do
            _size_=`$LS -l ${_file_path_}|$AWK '{print $5}'`
            let TOTAL_MAIN_SYB_IQ_DBSPACE_SIZE=TOTAL_MAIN_SYB_IQ_DBSPACE_SIZE+${_size_}
        done 

        # Build up a total of all MAIN dbspace already allocated to Sybase IQ
        unset TOTAL_TEMP_SYB_IQ_DBSPACE_SIZE
        for _file_path_ in `$CAT $SYBASEMSG|$AWK '{if($3 == "TEMPORARY") print $2}'`; do
            _size_=`$LS -l ${_file_path_}|$AWK '{print $5}'`
            let TOTAL_TEMP_SYB_IQ_DBSPACE_SIZE=TOTAL_TEMP_SYB_IQ_DBSPACE_SIZE+${_size_}
        done 
    fi
fi
}

### Function: check_id ###
#
#   Check that the effective id of the user is correct
#   If not print error msg and exit.
#
# Arguments:
#       $1 : User ID name
# Return Values:
#       none
check_id()
{
_get_id_=`$ENV |$GREP -w SUDO_USER | $EGREP "^[[:blank:]]*SUDO_USER="|$AWK -F\= '{print $2}'|$SED -e 's|"||g'`

_check_id_=`$ID | $AWK -F\( '{print $2}' | $AWK -F\) '{print $1}'`

_check_group_=`$ID $_get_id_ | $AWK -F\( '{print $3}' | $AWK -F\) '{print $1}'`


    if [ "${_get_id_}" == "" ]; then

        if [ "${_check_id_}" == "root" ]; then
           # Set 1 for true
           _user_root=1

        else
           _err_msg_="You must be root or admin to execute this script."
           abort_script "${_err_msg_}"
        fi
          else
            if [ "${_check_group_}" == "ENIQ_ADMIN_ROLE" ]; then
               # Set 0 for false
               _user_root=0

            else
               _err_msg_="You must be root or admin to execute this script." 
               abort_script "${_err_msg_}"
            fi
    fi

}

### Function: check_sys_main_ini_structure ###
#
# Check the sys main ini structure is correct
#
# Arguments:
#    none
# Return Values:
#    none
check_sys_main_ini_structure()
{
local _chk_

$CP ${ENIQ_CONF_DIR}/${SYM_INI} ${TEM_DIR}/${SYM_INI}
# Has there been enough IQ SYS MAIN already allocated 
_chk_=`iniget DWH_SYSTEM_MAIN -f ${TEM_DIR}/${SYM_INI} \
           |$HEAD -1|$EGREP '_[0-9]+[[:blank:]]*$'`

if [ "${_chk_}" ]; then
    return 0
fi

# Create the addition file
$RM -f ${TEM_DIR}/ins_sys_main_det ${TEM_DIR}/${SYM_INI}_update_1 ${TEM_DIR}/${SYM_INI}_update_2
$ECHO "\n;--------------------------------------------------------------------------" >> ${TEM_DIR}/ins_sys_main_det
$ECHO "; DWH SYSTEM MAIN DBSPACE information" >> ${TEM_DIR}/ins_sys_main_det
$ECHO ";--------------------------------------------------------------------------" >> ${TEM_DIR}/ins_sys_main_det
$ECHO "[DWH_SYSTEM_MAIN]" >> ${TEM_DIR}/ins_sys_main_det
$ECHO "DWH_SYSTEM_MAIN_1\n" >> ${TEM_DIR}/ins_sys_main_det
$ECHO "[DWH_SYSTEM_MAIN_1]" >> ${TEM_DIR}/ins_sys_main_det
iniget DWH_SYSTEM_MAIN -f ${TEM_DIR}/${SYM_INI} >> ${TEM_DIR}/ins_sys_main_det
$ECHO "" >> ${TEM_DIR}/ins_sys_main_det

# Make a working copy without DWH_SYSTEM_MAIN
${ENIQ_ADMIN_DIR}/lib/inidel.pl -p DWH_SYSTEM_MAIN -i ${TEM_DIR}/${SYM_INI} -o ${TEM_DIR}/${SYM_INI}_update_1 >> /dev/null 2>&1
if [ $? -ne 0 ]; then
    _err_msg_="Could not remove DWH_SYSTEM_MAIN refrences from ${SYM_INI}"
    abort_script "$_err_msg_"
fi

# Re-Add the details in correct structure
$CAT ${TEM_DIR}/ins_sys_main_det >> ${TEM_DIR}/${SYM_INI}_update_1

# Tidy up ini file by removing duplicate blank lines
$CAT ${TEM_DIR}/${SYM_INI}_update_1|$AWK '/^$/{ if (! blank++) print; next } { blank=0; print }' > ${TEM_DIR}/${SYM_INI}_update_2
 
# Copy the file back in
$CP ${TEM_DIR}/${SYM_INI}_update_2 ${ENIQ_CONF_DIR}/${SYM_INI}

# Delete tem files
$RM -f ${TEM_DIR}/ins_sys_main_det ${TEM_DIR}/${SYM_INI}_update_1 ${TEM_DIR}/${SYM_INI}_update_2 ${TEM_DIR}/${SYM_INI}
}

### Function: chk_create_logfile ###
#
# Check/Create Logfile
#
# Arguments:
#    none
# Return Values: 
#    none
chk_create_logfile()
{
$MKDIR -p `$DIRNAME ${LOGFILE}`
if [ $? -ne 0 ]; then
    unset LOGFILE
    _err_msg_="Could not create directory `$DIRNAME ${LOGFILE}`"
    abort_script "$_err_msg_"
fi    

$TOUCH -a ${LOGFILE}
if [ $? -ne 0 ]; then
    unset LOGFILE
    _err_msg_="Could not write to file ${LOGFILE}"
    abort_script "$_err_msg_"
fi
}

### Function: chk_iq_sys_main_ini ###
#
# Check if we need to updated IQ SYS MAIN Size
#
# Arguments:
#    $1 : Optional parameter stating full Main DB size
# Return Values:
#    none
chk_iq_sys_main_size()
{
local _tot_main_db_size_
if [ "${1}" ]; then
    _tot_main_db_size_=${1}
fi

# We need to get the path to IQ SYS MAIN
_iq_sys_main_db_=`iniget DWH_SYSTEM_MAIN -f ${TEM_DIR}/${SYM_INI}|$HEAD -1`
if [ ! "${_iq_sys_main_db_}" ]; then
    _err_msg_="Could not read DWH_SYSTEM_MAIN details from ${SYM_INI}"
    abort_script "$_err_msg_" 
fi

IQ_SYS_MAIN_DB_PATH=`iniget ${_iq_sys_main_db_} -f ${TEM_DIR}/${SYM_INI} -v Path`
if [ ! "${IQ_SYS_MAIN_DB_PATH}" ]; then
    _err_msg_="Could not read ${_iq_sys_main_db_}/Path parameter from ${SYM_INI}"
    abort_script "$_err_msg_" 
fi

IQ_SYS_MAIN_DB_PATH=`$DIRNAME ${IQ_SYS_MAIN_DB_PATH}|$SED -e 's/\/[\/]*/\//g' -e 's/[\/]*$//g'`

# Was I passed in MAIN DB Size. If not I will calculate from ini file
if [ ! "${_tot_main_db_size_}" ]; then
    _iq_main_db_list_=`iniget DWH_DBSPACES_MAIN -f ${TEM_DIR}/${SYM_INI}`
    _tot_main_db_size_=0
    for _iq_main_db_ in ${_iq_main_db_list_}; do
        _iq_main_size_=`iniget ${_iq_main_db_} -f ${TEM_DIR}/${SYM_INI} -v Size`
        _tot_main_db_size_=`$EXPR ${_tot_main_db_size_} + ${_iq_main_size_}`
    done
fi

# Has there been enough IQ SYS MAIN already allocated 
_sys_main_db_list_=`iniget DWH_SYSTEM_MAIN -f ${TEM_DIR}/${SYM_INI}`
_tot_sys_main_size_=0
for _sys_main_db_ in ${_sys_main_db_list_}; do
    _sys_main_size_=`iniget ${_sys_main_db_} -f ${TEM_DIR}/${SYM_INI} -v Size`
    _tot_sys_main_size_=`$EXPR ${_tot_sys_main_size_} + ${_sys_main_size_}`
done

# Get the required IQ SYS MAIN Size
_req_sys_main_db_size_=`$ECHO "${_tot_main_db_size_} * .02"|$BC|$AWK -F\. '{print$1}'`

if [ ${_req_sys_main_db_size_} -lt ${IQ_SYS_MAIN_MIN_SIZE} ]; then
    _req_sys_main_db_size_=${IQ_SYS_MAIN_MIN_SIZE}
fi

# Do we already have enough
if [ ${_tot_sys_main_size_} -ge ${_req_sys_main_db_size_} ]; then
    log_msg -s "Sufficient IQ SYS MAIN Space has already been allocated to Sybase IQ" ${LOG_OUT_STR}
    let EXIT_FLAG_CNT=EXIT_FLAG_CNT+1
    IQ_SYS_MAIN_UPDATE_SPACE=0
else
    # Get the amount of space I need to add. It will be a minimum of ${IQ_SYS_MAIN_MIN_SIZE} MBytes added
    # to stop unnecessary fragmentation of IQ SYS MAIN
    _sys_main_update_space_=`$EXPR ${_req_sys_main_db_size_} - ${_tot_sys_main_size_}`

    if [ ${_tot_sys_main_size_} -ge ${IQ_SYS_MAIN_MIN_SIZE} ]; then
        if [ ${_sys_main_update_space_} -lt ${IQ_SYS_MAIN_MIN_SIZE} ]; then
            _sys_main_update_space_=${IQ_SYS_MAIN_MIN_SIZE}
        fi
    fi

    IQ_SYS_MAIN_UPDATE_SPACE=${_sys_main_update_space_}
    UPDATE_SYS_MAIN_DBSPACE_FLAG=Y
fi
}

### Function: clear ### 
#
# To clear the screen
#
# Arguments:
#   none
# Return Values:
#   none
clear()
{

# Clearing the screen without removing scrollback buffer
$PRINTF '\33[H\33[2J'

}

### Function: confirm_user_input ###
#
# Confirm with user that values entered are correct
#
# Arguments:
#       none
# Return Values:
#       none
confirm_user_input()
{
MAIN_DB_PATH=`iniget DWH_DBSPACES_LOCATION -f ${TEM_DIR}/${SYM_INI} -v MAIN_DB_PATH`
if [ ! "${MAIN_DB_PATH}" ]; then
    _err_msg_="Could not find MAIN_DB_PATH in ${SYM_INI}"
    abort_script "$_err_msg_" 
fi

TEMP_DB_PATH=`iniget DWH_DBSPACES_LOCATION -f ${TEM_DIR}/${SYM_INI} -v TEMP_DB_PATH`
if [ ! "${TEMP_DB_PATH}" ]; then
    _err_msg_="Could not find TEMP_DB_PATH in ${SYM_INI}"
    abort_script "$_err_msg_" 
fi

DB_DIR_NAME_TEMPL=`iniget DWH_DBSPACES_LOCATION -f ${TEM_DIR}/${SYM_INI} -v DB_DIR_NAME_TEMPL`
if [ ! "${DB_DIR_NAME_TEMPL}" ]; then
    _err_msg_="Could not find DB_DIR_NAME_TEMPL in ${SYM_INI}"
    abort_script "$_err_msg_" 
fi

_disp_file_=${TEM_DIR}/disp_file
$RM -f ${_disp_file_}

local _dir_num_
local _loop_cnt_

if [ "${UPDATE_SYS_MAIN_DBSPACE_FLAG}" ]; then
    if [ ${UPDATE_RAW_DB} ];then
        $PRINTF "%-10s\n" 'Adding the following ' >> ${_disp_file_}
        $PRINTF "%-10s%s\n"'IQ SYS MAIN DBSPACE file '>> ${_disp_file_}
        Path="${IQ_SYS_MAIN_DB_PATH}/iq_system_main_${NEXT_SYS_MAIN_DBSPACE_NUM}.iq"
        $PRINTF "%-10s%s\n" ${Path} >> ${_disp_file_}
        $PRINTF "%-10s%s\n" >> ${_disp_file_}
        
    else
        $PRINTF "%-10s\n" 'Size in' >> ${_disp_file_}
        $PRINTF "%-10s%s\n" 'MBytes' 'IQ SYS MAIN DBSPACE file(s)'>> ${_disp_file_}
        Path="${IQ_SYS_MAIN_DB_PATH}/iq_system_main_${NEXT_SYS_MAIN_DBSPACE_NUM}.iq"
        Size="${IQ_SYS_MAIN_UPDATE_SPACE}"
        $PRINTF "%-10s%s\n" ${Size} ${Path} >> ${_disp_file_}
fi
fi

if [ "${UPDATE_MAIN_DBSPACE_FLAG}" ]; then
    if [ ${UPDATE_RAW_DB} ];then
        $PRINTF "%-10s\n" 'Adding the following ' >> ${_disp_file_}
        $PRINTF "%-10s%s\n" 'MAIN DBSPACE file(s)'>> ${_disp_file_}
        let _loop_cnt_=${START_MAIN_DBSPACE_NUM}+${NUM_MAIN_DBSPACES}-1
        for (( i=${START_MAIN_DBSPACE_NUM}; i<=${_loop_cnt_}; i++)); do
            # Get the last digit
            _last_dig_=`$ECHO ${i: -1}`
            if [ ${_last_dig_} -eq 0 ]; then
                _dir_num_=10
            else
                _dir_num_=${_last_dig_}
            fi
            
            Path=${MAIN_DB_PATH}/${DB_DIR_NAME_TEMPL}${_dir_num_}/main_${i}.iq
            $PRINTF "%-10s%s\n" ${Path} >> ${_disp_file_}
        done
    else
        $PRINTF "%-10s\n" 'Size in' >> ${_disp_file_}
        $PRINTF "%-10s%s\n" 'MBytes' 'MAIN DBspace file'>> ${_disp_file_}
        let _loop_cnt_=${START_MAIN_DBSPACE_NUM}+${NUM_MAIN_DBSPACES}-1
        for (( i=${START_MAIN_DBSPACE_NUM}; i<=${_loop_cnt_}; i++)); do
            # Get the last digit
            _last_dig_=`$ECHO ${i: -1}`
        if [ ${_last_dig_} -eq 0 ]; then
            _dir_num_=10
        else
            _dir_num_=${_last_dig_}
        fi
        
        Path=${MAIN_DB_PATH}/${DB_DIR_NAME_TEMPL}${_dir_num_}/main_${i}.iq
        Size=${MAIN_SPACE_PER_DBSPACE}
        $PRINTF "%-10s%s\n" ${Size} ${Path} >> ${_disp_file_}
        done

        _chk_size_=`$EXPR ${TOTAL_MAIN_SYB_IQ_DBSPACE_SIZE} / 1024 / 1024`
        $ECHO "TOTAL OLD MAIN IQ ${_chk_size_} Mbytes" >> ${_disp_file_}
        
        TOTAL_NODE_MAIN_SPACE=`$ECHO "${_chk_size_} + ${EXPAND_IQ_MAIN}"|$BC`
        $ECHO "TOTAL NEW MAIN IQ ${TOTAL_NODE_MAIN_SPACE} Mbytes" >> ${_disp_file_}
    fi
fi

if [ "${UPDATE_TEMP_DBSPACE_FLAG}" ]; then

    if [ ${UPDATE_RAW_DB} ];then
        $PRINTF "%-10s\n\n" 'Adding the following ' >> ${_disp_file_}
        $PRINTF "%-10s%s\n" 'TEMP DBSPACE file(s)'>> ${_disp_file_}
        let _loop_cnt_=${START_TEMP_DBSPACE_NUM}+${NUM_TEMP_DBSPACES}-1
        for (( i=${START_TEMP_DBSPACE_NUM}; i<=${_loop_cnt_}; i++)); do
            # Get the last digit
            _last_dig_=`$ECHO ${i: -1}`
            case ${_last_dig_} in
                1|6) _dir_num_=1
                ;;
                2|7) _dir_num_=2
                ;;
                3|8) _dir_num_=3
                ;;
                4|9) _dir_num_=4
                ;;
                5|0) _dir_num_=5
                ;;
            esac
                if [ "${READER_SERVER_TYPE}" == "YES" ]; then
                    _hname_=`$HOSTNAME`
                    _ip_addr_=`$HOSTNAME -i | $AWK '{print $1}' | $HEAD -1`
                    if [ ! "${_ip_addr_}" ]; then
                        _err_msg_="Could not determine Reader IP address"
                        abort_script "$_err_msg_"
                    fi

                    _reader_name_=`$CAT ${CLI_CONF_DIR}/service_names|$EGREP "^[[:blank:]]*${_ip_addr_}::.+dwh_reader" |$AWK -F"::" '{print $NF}'`
                    if [ ! "${_reader_name_}" ]; then
                        _err_msg_="Could not read reader name from ${CLI_CONF_DIR}/service_names"
                        abort_script "$_err_msg_"
                    fi


                    Path=${TEMP_DB_PATH}/${DB_DIR_NAME_TEMPL}${_dir_num_}/${_reader_name_}_temp_${i}.iqtmp
                    $PRINTF "%-10s%s\n" ${Path} >> ${_disp_file_}
                else
                    Path=${TEMP_DB_PATH}/${DB_DIR_NAME_TEMPL}${_dir_num_}/temp_${i}.iqtmp
                    $PRINTF "%-10s%s\n" ${Path} >> ${_disp_file_}
                fi 
        done
    else
    
        $PRINTF "\n\n%-10s\n" 'Size in' >> ${_disp_file_}
        $PRINTF "%-10s%s\n" 'MBytes' 'TEMP DBspace file'>> ${_disp_file_}
        let _loop_cnt_=${START_TEMP_DBSPACE_NUM}+${NUM_TEMP_DBSPACES}-1
        for (( i=${START_TEMP_DBSPACE_NUM}; i<=${_loop_cnt_}; i++)); do
            # Get the last digit
        _last_dig_=`$ECHO ${i: -1}`
        case ${_last_dig_} in
            1|6) _dir_num_=1
            ;;
            2|7) _dir_num_=2
            ;;
            3|8) _dir_num_=3
            ;;
            4|9) _dir_num_=4
            ;;
            5|0) _dir_num_=5
            ;;
        esac
        
        Path=${TEMP_DB_PATH}/${DB_DIR_NAME_TEMPL}${_dir_num_}/temp_${i}.iqtmp
        Size=${TEMP_SPACE_PER_DBSPACE}
        $PRINTF "%-10s%s\n" ${Size} ${Path} >> ${_disp_file_}
        done
            
        _chk_size_=`$EXPR ${TOTAL_TEMP_SYB_IQ_DBSPACE_SIZE} / 1024 / 1024`
        $ECHO "TOTAL OLD TEMP IQ ${_chk_size_} Mbytes" >> ${_disp_file_}
        
        TOTAL_NODE_TEMP_SPACE=`$ECHO "${_chk_size_} + ${EXPAND_IQ_TEMP}"|$BC`
        $ECHO "TOTAL NEW TEMP IQ ${TOTAL_NODE_TEMP_SPACE} Mbytes" >> ${_disp_file_}
        
    fi
fi

while :; do
    clear
    $CAT ${_disp_file_}
    $ECHO "\nAre the values above correct (Yy/Nn)"
    #Automated in case flag for autmation is 1 else ask for input.
    if [ "${automation_flag}" == "true" ]; then
        USER_CONF="y"
    else
        read USER_CONF
    fi

    # If the User hit nothing and there is a default. that will do
    if [ ! "${USER_CONF}" ]; then
        continue
    fi

    # Did the user input (Y/y) 
    if [ "${USER_CONF}" == "Y" -o "${USER_CONF}" == "y" ]; then
        break
    elif [ "${USER_CONF}" == "N" -o "${USER_CONF}" == "n" ]; then
    exit 2    
    else
        :
    fi
done
}

### Function: get_absolute_path ###
#
# Determine absolute path to software
#
# Arguments:
#    none
# Return Values:
#    none
get_absolute_path() 
{
_dir_=`$DIRNAME $0`
SCRIPTHOME=`cd $_dir_ 2>/dev/null && pwd || $ECHO $_dir_`
}

## Function: read_storage_type ###
#
# Arguments:
#   none
# Return Values:
#   set varibale STORAGE_TYPE
read_storage_type()
{
# Read the storage type
if [ -s ${ENIQ_CONF_DIR}/${SUNOS_INI} ]; then
    STORAGE_TYPE=`iniget STOR_TYPE -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v STORAGE_TYPE`
else
    if [ -s ${ENIQ_CONF_DIR}/san_details ]; then
        STORAGE_TYPE=`$CAT ${ENIQ_CONF_DIR}/san_details | $EGREP "^STORAGE_TYPE=" | $AWK -F\= '{print $2}'`
    fi
fi

if [ ! "${STORAGE_TYPE}" ]; then
    _err_msg_="Could not read STORAGE_TYPE paramater from ${ENIQ_CONF_DIR}/${SUNOS_INI} or ${ENIQ_CONF_DIR}/san_details"
    abort_script "$_err_msg_"
fi
}



### Function: register_raw_device ###
#
# Register the disk with raw device
#
# Arguments:
#    none
# Return Values:
#    none
register_raw_device()
{

if [ "${STORAGE_TYPE}" == "raw" ]; then
    _san_device_=`$CAT ${ENIQ_CONF_DIR}/san_details | $EGREP "^SAN_DEVICE=" | $AWK -F\= '{print $2}'`
    if [ ! "${_san_device_}" ]; then
        _err_msg_="Could not get the value of SAN device"
        abort_script "$_err_msg_" "${EXEC_SHELL_CMD}"
    fi
fi
$TOUCH ${TEM_DIR}/symlink.txt

if [ "${UPDATE_MAIN_DBSPACE_FLAG}" ]; then
    $ECHO "${_main_dev_}" > ${TEM_DIR}/symlink.txt
fi

if [ "${UPDATE_TEMP_DBSPACE_FLAG}" ]; then
    $ECHO "${_temp_dev_}" > ${TEM_DIR}/symlink.txt
fi



$SED -i 's/ /\n/g' ${TEM_DIR}/symlink.txt
if [ $? -ne 0 ]; then
    _err_msg_="Could not align the content in ${TEM_DIR}/symlink.txt"
    abort_script "$_err_msg_" "${EXEC_SHELL_CMD}"
fi

count=`$CAT ${UDEV_FILE} | $GREP "RUN+=" | $WC -l`
count=`$EXPR ${count} + 1`
while read line
do
    $SED -ie "s/^\($line\)$/\1:\/dev\/raw\/raw$count/g" ${TEM_DIR}/symlink.txt 
    if [ $? -ne 0 ]; then
        _err_msg_="Could not append raw device with ${line} in ${TEM_DIR}/symlink.txt"
        abort_script "$_err_msg_" "${EXEC_SHELL_CMD}"
    fi
done < ${TEM_DIR}/symlink.txt

#####registering raw devices
$CP ${UDEV_FILE} ${TEM_DIR}/99-iq-raw-devs.rules
if [ $? -ne 0 ]; then
    _err_msg_="Could not take backup of UDEV rules file"
    abort_script "$_err_msg_" "${EXEC_SHELL_CMD}"
fi


$CP ${UDEV_FILE} ${TEM_DIR}/99-iq-raw-devs.rules_cpy
if [ $? -ne 0 ]; then
    _err_msg_="Could not take backup of UDEV rules file"
    abort_script "$_err_msg_" "${EXEC_SHELL_CMD}"
fi


_line_no=0 

while read line
    do
        if [ ${_san_device_} == "local" ]; then
            _disk_=`$ECHO $line | $AWK -F":" '{print $1}'`
            _raw_disk_=`$ECHO $line | $AWK -F":" '{print $2}'`
            _uuid_=`$SCSI_ID -g -u -d /dev/${_disk_}1`
            _line_no=`$GREP -n "KERNEL==" ${TEM_DIR}/99-iq-raw-devs.rules | $TAIL -1 | $AWK -F":" '{print $1}'`
            $SED -i "${_line_no}i "KERNEL=="\"sd*[0-9]\"",' 'PROGRAM=="\"scsi_id -g -u -d %N\"",' 'RESULT=="\"${_uuid_}\"",' 'RUN+="\"/usr/bin/raw ${_raw_disk_} %N\""""  ${TEM_DIR}/99-iq-raw-devs.rules
        else
            _disk_=`$ECHO $line | $AWK -F":" '{print $1}'`
            _raw_disk_=`$ECHO $line | $AWK -F":" '{print $2}'`
            _uuid_=`$UDEVADM  info --query=all --name=/dev/mapper/${_disk_}1 | $GREP -iw DM_UUID | $AWK -F"=" '{print $2}'`
            _line_no=`$GREP -n "KERNEL==" ${TEM_DIR}/99-iq-raw-devs.rules | $TAIL -1 | $AWK -F":" '{print $1}'`
            $SED -i "${_line_no}i "ENV{DM_UUID}=="\"${_uuid_}\"",' 'RUN+="\"/bin/raw ${_raw_disk_} %M %m\""""  ${TEM_DIR}/99-iq-raw-devs.rules
        fi

    done < ${TEM_DIR}/symlink.txt

$CP ${TEM_DIR}/99-iq-raw-devs.rules ${UDEV_FILE} 
if [ $? -ne 0 ]; then
    _err_msg_="Could not update ${UDEV_FILE} file"
    abort_script "$_err_msg_" "${EXEC_SHELL_CMD}"
fi

#Activate the raw device created in udev rules
$UDEVADM control --reload-rules
if [ $? -ne 0 ];then
    _err_msg_="Could not reload udev rules for raw device"
    abort_script "$_err_msg_" "${EXEC_SHELL_CMD}"
fi

$UDEVADM trigger --type=devices --action=change
if [ $? -ne 0 ];then
    _err_msg_="Could not trigger udev rules for raw devices"
    abort_script "$_err_msg_" "${EXEC_SHELL_CMD}"
fi


# Check if the raw devices are created or not
_max_count_=0
$CAT  ${UDEV_FILE}| $GREP raw$count >> /dev/null 2>&1
if [ $? -eq 0 ];then
    while :;do
    $RAW -a | $GREP raw$count >> /dev/null 2>&1
    if [ $? -eq 0  ];then
        break
    else
        $SLEEP 1
        _max_count_=`$EXPR ${_max_count_} + 1`
        if [ ${_max_count_} -eq 60 ]; then
            $CP ${TEM_DIR}/99-iq-raw-devs.rules_cpy ${UDEV_FILE}
            if [ $? -ne 0 ]; then
                _err_msg_="Could not restore back the ${UDEV_FILE} file"
                abort_script "$_err_msg_" "${EXEC_SHELL_CMD}"
            fi
            #Activate the raw device created in udev rules
            $UDEVADM control --reload-rules
            if [ $? -ne 0 ];then
                _err_msg_="Could not reload udev rules for raw device"
                abort_script "$_err_msg_" "${EXEC_SHELL_CMD}"
            fi

            $UDEVADM trigger --type=devices --action=change
            if [ $? -ne 0 ];then
                _err_msg_="Could not trigger udev rules for raw devices"
                abort_script "$_err_msg_" "${EXEC_SHELL_CMD}"
            fi
            err_msg_="Could not create raw device"
            abort_script "$_err_msg_" "${EXEC_SHELL_CMD}"
        fi
        continue
    fi
    
    done
else
    _err_msg_="Could not update ${UDEV_FILE} file for raw device"
    abort_script "$_err_msg_" "${EXEC_SHELL_CMD}"
fi


}

### Function: set_dbspace_per_node ###
#
# Okay I need to set up the amount of dbspace I will allocate per 
# node/cell of each network type managed
#
# Arguments:
#    $1 : File containing the list of managed network types
# Return Values:
#    none
set_dbspace_per_node()
{
for _network_ in `$CAT ${1}|$SORT -u`; do
    _net_desig_=`iniget NETWORK_DESIGNATION -f ${TEM_DIR}/${ENIQ_INI} -v ${_network_}_NET`
    if [ $? -ne 0 ]; then
        _err_msg_="Could not find ${_network_}_NET in ${CLI_CONF_DIR}/${ENIQ_INI}"
        abort_script "$_err_msg_" 
    fi
    # Have these values been set already?
    _old_main_space_=`iniget DWH_DBSPACES_SPACE_PER_NODE -f ${TEM_DIR}/${ENIQ_INI} -v DWH_DBSPACES_SPACE_PER_NODE_MAIN_${_network_}`
    if [ "${_old_main_space_}" ]; then
        # Test for numeric
        $ECHO ${_old_main_space_} | $EGREP '[^0-9]' >> /dev/null 2>&1
        if [ $? -eq 0 ]; then
            unset _old_main_space_
        fi
        if [ ${_old_main_space_} -eq 0 ]; then            
            unset _old_main_space_
        fi
    fi
    _old_temp_space_=`iniget DWH_DBSPACES_SPACE_PER_NODE -f ${TEM_DIR}/${ENIQ_INI} -v DWH_DBSPACES_SPACE_PER_NODE_TEMP_${_network_}`
    if [ "${_old_temp_space_}" ]; then
        # Test for numeric
        $ECHO ${_old_temp_space_} | $EGREP '[^0-9]' >> /dev/null 2>&1
        if [ $? -eq 0 ]; then
            unset _old_temp_space_
        fi
        if [ ${_old_temp_space_} -eq 0 ]; then            
            unset _old_temp_space_
        fi
    fi

    while :; do
    clear
    
        $ECHO "\nPlease enter the amount of MAIN DBSPACE space in MBytes to create" 
        $ECHO "for each ${_network_} ${_net_desig_} you are going to manage"
        $ECHO "This value should be derived from the ENIQ Configuration Directions"
    
    if [ "${_old_main_space_}" ]; then
        $ECHO "\nThe existing default value set is ${_old_main_space_} and this value"
        $ECHO "will be used if no value is entered"
    fi
    read _node_main_space_
    
        # Test for numeric
        $ECHO ${_node_main_space_} | $EGREP '[^0-9]' >> /dev/null 2>&1
    if [ $? -eq 0 ]; then
        continue 
    fi
    
    # If the User hit nothing and there is an existing value
    # then use that, otherwise loop
    if [ ! "${_node_main_space_}" ]; then
        if [ "${_old_main_space_}" ]; then
            _node_main_space_=${_old_main_space_}
        else
            continue
        fi
    fi
    
    # Zero size not allowed
    if [ ${_node_main_space_} -eq 0 ]; then
        continue
    fi
    
    $ECHO "\n\nPlease enter the amount of TEMP DBSPACE space to create" 
    $ECHO "for each ${_network_} ${_net_desig_} you are going to manage\n"
    $ECHO "This value should be derived from the ENIQ Configuration Directions"
    
    if [ "${_old_temp_space_}" ]; then
        $ECHO "\nThe existing default value set is ${_old_temp_space_} and this value"
        $ECHO "will be used if no value is entered"
    fi
    read _node_temp_space_
    
    # Test for numeric
    $ECHO ${_node_temp_space_} | $EGREP '[^0-9]' >> /dev/null 2>&1
    if [ $? -eq 0 ]; then
        continue 
    fi
    
    # If the User hit nothing and there is an existing value
    # then use that, otherwise loop
    if [ ! "${_node_temp_space_}" ]; then
        if [ "${_old_temp_space_}" ]; then
        _node_temp_space_=${_old_temp_space_}
        else
        continue
        fi
    fi
    
    # Zero size not allowed
    if [ ${_node_temp_space_} -eq 0 ]; then
        continue
    fi
    
    break
    done  
    log_msg -s "\nSetting DWH_DBSPACES_SPACE_PER_NODE_MAIN_${_network_} to ${_node_main_space_} in ${TEM_DIR}/${ENIQ_INI}" ${LOG_OUT_STR} -q
    iniset DWH_DBSPACES_SPACE_PER_NODE -f ${TEM_DIR}/${ENIQ_INI} DWH_DBSPACES_SPACE_PER_NODE_MAIN_${_network_}=${_node_main_space_}
    if [ $? -ne 0 ]; then
        _err_msg_="Could not set value for DWH_DBSPACES_SPACE_PER_NODE_MAIN_${_network_} in ${TEM_DIR}/${ENIQ_INI}"
        abort_script "$_err_msg_" 
    fi
    log_msg -s "Setting DWH_DBSPACES_SPACE_PER_NODE_TEMP_${_network_} to ${_node_main_space_} in ${TEM_DIR}/${ENIQ_INI}\n" ${LOG_OUT_STR} -q
    iniset DWH_DBSPACES_SPACE_PER_NODE -f ${TEM_DIR}/${ENIQ_INI} DWH_DBSPACES_SPACE_PER_NODE_TEMP_${_network_}=${_node_temp_space_}
    if [ $? -ne 0 ]; then
        _err_msg_="Could not set value for DWH_DBSPACES_SPACE_PER_NODE_TEMP_${_network_} in ${TEM_DIR}/${ENIQ_INI}"
        abort_script "$_err_msg_" 
    fi
done
    
}

### Function: setup_env ###
#
# Setup up path environment etc
#
# Arguments:
#   none
# Return Values:
#   none
setup_env()
{
if [ ! "${ENIQ_BASE_DIR}" ]; then
    ENIQ_BASE_DIR=/eniq
fi

ENIQ_CONF_DIR=${ENIQ_BASE_DIR}/installation/config
if [ ! -s ${ENIQ_CONF_DIR}/${SUNOS_INI} ]; then
    _err_msg_="Could not locate file ${ENIQ_CONF_DIR}/${SUNOS_INI}"
    abort_script "$_err_msg_"
fi

# Main Directory for the Core Installation SW
ENIQ_INST_DIR=${ENIQ_BASE_DIR}/installation/core_install

ENIQ_ADMIN_DIR=${ENIQ_BASE_DIR}/admin

DEF_CLI_CONF_DIR=`$CAT ${ENIQ_CONF_DIR}/${ENIQ_ENV} | $EGREP "^[     ]*CONF_DIR="|$AWK -F\= '{print $2}'|$SED -e 's|"||g'`
if [ ! "${DEF_CLI_CONF_DIR}" ]; then
    _err_msg_="Could not read CONF_DIR parameter from ${ENIQ_CONF_DIR}/${ENIQ_ENV}"
    abort_script "$_err_msg_"
fi

BKUP_DB_FILESYS_LIST="`$DIRNAME ${SCRIPTHOME}`/backup/etc/db_filesystem_list"
if [ ! -s ${BKUP_DB_FILESYS_LIST} ]; then
    BKUP_DB_FILESYS_LIST="/eniq/bkup_sw/etc/asa_filesystem_list"
    BKUP_IQ_FILESYS_LIST="/eniq/bkup_sw/etc/iq_filesystem_list"
    if [ ! -s ${BKUP_DB_FILESYS_LIST} ]; then
        _err_msg_="Could not locate file ${BKUP_DB_FILESYS_LIST}"
        abort_script "$_err_msg_"
    fi
fi

CURR_SERVER_TYPE=`$CAT $ENIQ_CONF_DIR/installed_server_type | $EGREP -v  '^[[:blank:]]*#' | $SED -e 's/ //g'`
READER_SERVER_TYPE=NO
if [ "${CURR_SERVER_TYPE}" = "stats_iqr" -o "${CURR_SERVER_TYPE}" = "eniq_iqr"  ]; then
    READER_SERVER_TYPE=YES
fi

UDEV_FILE=/etc/udev/rules.d/99-iq-raw-devs.rules

# Set the log directory
LOG_DIR=`iniget LOG_FILE_DIR -f ${ENIQ_CONF_DIR}/${ENIQ_INI} -v Logfile_Location`
LOGFILE_DIR="$LOG_DIR/expansion_log"

#Fetching IP Type from ipmp.ini file.
check_ip_type

if [ ! "${_ip_type_}" ]; then
    _err_msg_="Could not read parameter _IP_TYPE_ from file ${ENIQ_CONF_DIR}/${IPMP_INI}"
    abort_script "$_err_msg_"
fi
}

### Function: setup_sybase_env ###
#
# Set up Sybase environment
#
# Arguments:
#   none
# Return Values:
#   none
setup_sybase_env()
{
SYSUSER=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${SYSUSER}" ]; then
    _err_msg_="Could not read System User from  ${ENIQ_CONF_DIR}/${SUNOS_INI}"
    abort_script "$_err_msg_"
fi

SYSGRP=`$ID ${SYSUSER}|$AWK '{print $2}'|$AWK -F\( '{print $2}'|$AWK -F\) '{print $1}'`
if [ ! "${SYSGRP}" ]; then
    _err_msg_="Could not determine group id of ${SYSUSER}"
    abort_script "$_err_msg_"
fi    

$SU - ${SYSUSER} >> /dev/null -c "$ENV |$EGREP '^(SYBASE|ASDIR|IQDIR|ASALOGDIR|SQLANY)' > $TEM_DIR/sybase_det.$$" >> /dev/null 2>&1

# Source the environment
set -a
. $TEM_DIR/sybase_det.$$ >> /dev/null 2>&1
set +a

if [ ! "${SYBASE}" ]; then 
    _err_msg_="Could not determine Sybase environment variable \${SYBASE}"
    abort_script "$_err_msg_"
fi

if [ ! "${SYBASE_OCS}" ]; then
    _err_msg_="Could not determine Sybase environment variable \${SYBASE_OCS}"
    abort_script "$_err_msg_"
fi
if [ ! "${ASDIR}" ]; then
   SYBASE_OCS_BIN=${SYBASE}/${SYBASE_OCS}/bin
   ISQL=$SYBASE_OCS_BIN/isql 
   DBPING=$IQDIR/bin64/dbping
   export LD_LIBRARY_PATH=$IQDIR/lib64
   NEW=true
else
   ISQL=$SYBASE/$SYBASE_OCS/bin/isql
   DBPING=${ASDIR}/bin/dbping
   export LD_LIBRARY_PATH=${ASDIR}/lib
fi


if [ ! -x "$ISQL" ]; then
    _err_msg_="$ISQL commands not found or not executable."
    abort_script "$_err_msg_"
fi

SYB_DBA=dba

SYB_PASS=`inigetpassword DB -f ${TEM_DIR}/${ENIQ_INI} -v DBAPassword`
if [ ! "${SYB_PASS}" ]; then
    _err_msg_="Could not read IQ DBA password from ${CLI_CONF_DIR}/${ENIQ_INI}"
    abort_script "$_err_msg_"
fi    
}

### Function: test_iq_login ###
#
# Test that I can log into sybase IQ
#
# Arguments:
#    $1 : Database to check
#    $2 : Flag to indicate rolling snapshot or not (0/1)
#    $3 : Flag to indicate quiet/verbose operation
# Return Values:
#    none
test_iq_login()
{
local _bkup_quiet_ _db_up_res_code_ _roll_snap_flag_ 
local _dbspace_list_ _dbspace_err_

_dblist_=${1}
_roll_snap_flag_=${2}
if [ "${3}" ]; then
    _bkup_quiet_="-q"
fi

_db_up_res_code_=0

for _db_ in ${_dblist_}; do
    # Is the database up. If not assume it is safe to backup

    log_msg -s "Testing database ${_db_} is running" ${LOG_OUT_STR} ${_bkup_quiet_}

    INI_SECTION=`$CAT ${BKUP_IQ_FILESYS_LIST}|$EGREP -v '^[     ]*#'    \
                     |$EGREP "^[     ]*${_db_}::"|$AWK -F"::" '{print $2}'`
    if [ ! "${INI_SECTION}" ]; then
        _err_msg_="Could not read INI_SECTION param for ${_db_} from ${BKUP_DB_FILESYS_LIST}"
        abort_script "$_err_msg_"
    fi

    _port_=`iniget ${INI_SECTION} -f ${TEM_DIR}/${ENIQ_INI} -v PortNumber`
    _srvname_=`iniget ${INI_SECTION} -f ${TEM_DIR}/${ENIQ_INI} -v ServerName`

	conn_str_dbping_dec="-c \"con=${_db_};eng=${_srvname_};links=tcpip{host=localhost;port=${_port_};dobroadcast=none;verify=no};uid=${SYB_DBA};pwd=${SYB_PASS}\""
	conn_str_dbping_enc=${TEM_DIR}/conn_str_updt_cell_dbping.`uuidgen`

	# encrypt the connection string.
	get_encrypt_file "${conn_str_dbping_dec}" "${conn_str_dbping_enc}"

    _up_=`${DBPING} -q @${conn_str_dbping_enc} 2>/dev/null`

    if [ $? -ne 0 ]; then
        # If this is a rolling snapshot then all databases must be up
        if [ ${_roll_snap_flag_} -eq 1 ]; then
            _err_msg_="Rolling Snapshot not possible.\nDatabase ${_db_} is not running"
            abort_script "$_err_msg_"
        else
            _err_msg_="Database ${_db_} is not running"
            abort_script "$_err_msg_"
        fi
    fi

    log_msg -s "Testing login of database ${_db_}" ${LOG_OUT_STR} ${_bkup_quiet_}
    $RM -f $SYBASEMSG
    if [ $NEW ]; then
        ## for 15.2 new output from sybase
        $ISQL -b -w 500000 -Udba -P${SYB_PASS} -S${_db_} <<EOISQL >>  $SYBASEMSG
sp_iqfile
go
EOISQL
# Do not put a space after EOISQL
        if [ $? -ne 0 ]; then
            _err_msg_="Error logging on to database ${_db_} on IQ server."
            abort_script "$_err_msg_"
        fi
        
    else
    $ISQL -b -w 500000 -Udba -P${SYB_PASS} -S${_db_} <<EOISQL >>  $SYBASEMSG
sp_iqdbspace
go
EOISQL
# Do not put a space after EOISQL
        if [ $? -ne 0 ]; then
            _err_msg_="Error logging on to database ${_db_} on IQ server."
            abort_script "$_err_msg_"
        fi    
    fi

    # Check for any reported errors
    $EGREP 'Msg [0-9][0-9]*\, Level ([0-9][0-9]*)' $SYBASEMSG >> /dev/null 2>&1

    if [ $? -eq 0 ]; then
        _err_msg_="Error logging on to database ${_db_} on IQ server."
        abort_script "$_err_msg_"
    fi

    # If this is a rolling snapshot then we check that all dbspaces exist etc.
    if [ ${_roll_snap_flag_} -eq 1 ]; then
    # Get the list of dbspaces
        _dbspace_list_=`$CAT $SYBASEMSG|$AWK '{print $2}'|$EGREP '^\/'`
        if [ ! "${_dbspace_list_}" ]; then
            _err_msg_="Rolling Snapshot not possible.\nNo IQ dbspaces found associated with database ${_db_}"
            abort_script "$_err_msg_"
        fi
    
    # Check that each dbspace exists and has a size greater than 0
        _dbspace_err_=0
        for _dbspace_ in ${_dbspace_list_}; do
            if [ ! -s ${_dbspace_} ]; then
                _dbspace_err_=1
                log_msg -s "${_dbspace_} not found or empty"
            fi
        done
        if [ ${_dbspace_err_} -eq 1 ]; then
            _err_msg_="Rolling Snapshot not possible.\nSome dbspaces are missing"
            abort_script "$_err_msg_"
        fi
    fi
done
return ${_db_up_res_code_}
}

### Function: update_cell_count ###
#
# update Cell managed count
#
# Arguments:
#    none
# Return Values:
#    none
update_cell_count()
{
MAIN_DB_PATH=`iniget DWH_DBSPACES_LOCATION -f ${TEM_DIR}/${SYM_INI} -v MAIN_DB_PATH`
if [ ! "${MAIN_DB_PATH}" ]; then
    _err_msg_="Could not find MAIN_DB_PATH in ${SYM_INI}"
    abort_script "$_err_msg_" 
fi

TEMP_DB_PATH=`iniget DWH_DBSPACES_LOCATION -f ${TEM_DIR}/${SYM_INI} -v TEMP_DB_PATH`
if [ ! "${TEMP_DB_PATH}" ]; then
    _err_msg_="Could not find TEMP_DB_PATH in ${SYM_INI}"
    abort_script "$_err_msg_" 
fi

DB_DIR_NAME_TEMPL=`iniget DWH_DBSPACES_LOCATION -f ${TEM_DIR}/${SYM_INI} -v DB_DIR_NAME_TEMPL`
if [ ! "${DB_DIR_NAME_TEMPL}" ]; then
    _err_msg_="Could not find DB_DIR_NAME_TEMPL in ${SYM_INI}"
    abort_script "$_err_msg_" 
fi

# Flag to show whether customer is using all available network types 
_all_nets_used_=1

# Find what network types have been installed
$RM -rf ${TEM_DIR}/used_network_types
for _net_type_ in `$ECHO $AVAIL_NETWORK_TYPES`; do
    _type_=`iniget ENIQ_NET_INFO -f ${TEM_DIR}/${ENIQ_INI} -v ManagedNodes${_net_type_}`
    if [ $? -ne 0 ]; then
        _err_msg_="Could not find ManagedNodes${_net_type_} in ${CLI_CONF_DIR}/${ENIQ_INI}"
        abort_script "$_err_msg_" 
    fi
    if [ "${_type_}" == "" ]; then
        _all_nets_used_=0
        continue
    else
        $ECHO ${_net_type_} >> ${TEM_DIR}/used_network_types
    fi
done

# Are all available net types selected. If not, allow user to
# add more
if [ ${_all_nets_used_} -eq 0 ]; then
    # Does the user want to add new network types
    while :; do
    unset _opt_
    unset _network_array
    $RM -f ${TEM_DIR}/network_types
        clear
    $ECHO "Available network types"
    $ECHO "-----------------------"
    
    unset _def_opt_
    _cnt_=1
    for _net_type_ in `$ECHO $AVAIL_NETWORK_TYPES`; do
        $ECHO "[${_cnt_}]  ${_net_type_}"
        _network_array[${_cnt_}]=${_net_type_}
        
        # Build up a list of the nets already managed 
        $GREP -w ${_net_type_} ${TEM_DIR}/used_network_types >> /dev/null 2>&1
        if [ $? -eq 0 ]; then
            if [ ! "${_def_opt_}" ]; then
                _def_opt_=${_cnt_}
            else
                _def_opt_="${_def_opt_},${_cnt_}"
            fi
        fi
        let _cnt_=_cnt_+1
    done
    
    $ECHO "\n\nPlease enter the network types you are\ngoing to manage in the form (n,n....n) e.g. 1,2,3 \n"
    if [ "${_def_opt_}" ]; then
        $ECHO "Default selection will be already managed networks [${_def_opt_}]"    
    fi
    read _opt_
    
    # If the User hit nothing and there is a default. that will do
    if [ ! "${_opt_}"  ]; then
        if [ ! "${_def_opt_}" ]; then
        continue
        else
            _opt_=${_def_opt_}
        fi
    else
        if [ "${_def_opt_}" ]; then
            _tem_opt_=""
        # Check that the value the user input, contains at least all the 
        # existing managed network types
            _chk_net_list_=`$ECHO ${_opt_}|$SED -e 's|,| |g'`
        for _chknet_ in ${_chk_net_list_}; do
            $ECHO ${_def_opt_}|$GREP -w ${_chknet_} >> /dev/null 2>&1
            if [ $? -ne 0 ]; then
                _def_opt_="${_def_opt_},${_chknet_}"
            fi
        done
            _opt_=${_def_opt_}
        fi
    fi
    
    _numerror_=0
    for _num_ in `$ECHO ${_opt_} | $SED "s|,| |g"`; do
        $ECHO ${_num_} | $EGREP '[^0-9]' >> /dev/null 2>&1
        if [ $? -eq 0 ]; then
            _numerror_=1
        break
        fi        
        if [ ${_num_} -lt 1 -o ${_num_} -ge ${_cnt_} ]; then
            _numerror_=1
        break
        fi
        
        # Okay I should have a valid choice now. Output details to
        # output file. I will output the desc as well as I might 
        # show the user
        $GREP -w "${_network_array[${_num_}]}" ${TEM_DIR}/network_types >> /dev/null 2>&1
        if [ $? -ne 0 ]; then
            $ECHO "${_network_array[${_num_}]}" >> ${TEM_DIR}/network_types
        fi
    done
    if [ ${_numerror_} -eq 0 ]; then
        break
    fi    
    done
else
    $CP ${TEM_DIR}/used_network_types ${TEM_DIR}/network_types
fi

# Okay I need to set up the amount of dbspace I will allocate per 
# node/cell of each network type managed
set_dbspace_per_node ${TEM_DIR}/network_types

unset CORE_COUNT GRAN_COUNT WRAN_COUNT TOTAL_NODE_COUNT
unset TOTAL_NODE_MAIN_SPACE TOTAL_NODE_TEMP_SPACE

_net_updated_=0
for _network_ in `$CAT ${TEM_DIR}/network_types|$SORT -u`; do
    _node_main_space_=`iniget DWH_DBSPACES_SPACE_PER_NODE -f ${TEM_DIR}/${ENIQ_INI} -v DWH_DBSPACES_SPACE_PER_NODE_MAIN_${_network_}`
    if [ $? -ne 0 ]; then
        _err_msg_="Could not find DWH_DBSPACES_SPACE_PER_NODE_MAIN_${_network_} in ${CLI_CONF_DIR}/${ENIQ_INI}"
        abort_script "$_err_msg_" 
    fi
        _node_temp_space_=`iniget DWH_DBSPACES_SPACE_PER_NODE -f ${TEM_DIR}/${ENIQ_INI} -v DWH_DBSPACES_SPACE_PER_NODE_TEMP_${_network_}`
    if [ $? -ne 0 ]; then
        _err_msg_="Could not find DWH_DBSPACES_SPACE_PER_NODE_TEMP_${_network_} in ${CLI_CONF_DIR}/${ENIQ_INI}"
        abort_script "$_err_msg_" 
    fi
    
    _net_desig_=`iniget NETWORK_DESIGNATION -f ${TEM_DIR}/${ENIQ_INI} -v ${_network_}_NET`
    if [ $? -ne 0 ]; then
        _err_msg_="Could not find ${_network_}_NET in ${CLI_CONF_DIR}/${ENIQ_INI}"
        abort_script "$_err_msg_" 
    fi
    
    while :; do
    # Get the existing number managed 
    _old_node_cnt_=`iniget ENIQ_NET_INFO -f ${TEM_DIR}/${ENIQ_INI} -v ManagedNodes${_network_}`
    if [ "${_old_node_cnt_}" ]; then
        $ECHO ${_old_node_cnt_} | $EGREP '[^0-9]' >> /dev/null 2>&1
        if [ $? -eq 0 ]; then
            _err_msg_="Non numeric value read for ManagedNodes${_network_} in ${CLI_CONF_DIR}/${ENIQ_INI}"
            abort_script "$_err_msg_" 
        fi
    fi
    
    clear
    $ECHO "\n\nPlease enter the number of ${_network_} ${_net_desig_}s you are going to manage\n"
    $ECHO "Main DBSPACE Requirement is ${_node_main_space_} MBytes per ${_net_desig_}"
    $ECHO "Temp DBSPACE Requirement is ${_node_temp_space_} MBytes per ${_net_desig_}"
    if [ "${_old_node_cnt_}" ]; then
        $ECHO "Default number will be already managed ${_network_} ${_net_desig_}s (${_old_node_cnt_})"    
    fi
    read _node_cnt_
    
    if [ ! "${_node_cnt_}" ]; then
        if [ ! "${_old_node_cnt_}" ]; then
        continue
        else
        _node_cnt_=${_old_node_cnt_}
        fi
    fi
    
    # Test for numeric
    $ECHO ${_node_cnt_} | $EGREP '[^0-9]' >> /dev/null 2>&1
    if [ $? -eq 0 ]; then
        continue 
    fi
    
    # Is the number entered than the number already managed
    if [ "${_old_node_cnt_}" ]; then
        if [ ${_node_cnt_} -lt ${_old_node_cnt_} ]; then
            continue 
        elif [ ${_node_cnt_} -gt ${_old_node_cnt_} ]; then
            _net_updated_=1
        else
        :
        fi
    else
        _net_updated_=1
    fi
    
    # Record the number of Managed Nodes
    log_msg -s "Setting ManagedNodes${_network_} to ${_node_cnt_} in ${TEM_DIR}/${ENIQ_INI}" ${LOG_OUT_STR} -q
    iniset ENIQ_NET_INFO -f ${TEM_DIR}/${ENIQ_INI} ManagedNodes${_network_}=${_node_cnt_}
    if [ $? -ne 0 ]; then
        _err_msg_="Could not update ${TEM_DIR}/${ENIQ_INI} with ManagedNodes${_network_}=${_node_cnt_}"
        abort_script "$_err_msg_" 
    fi    
    break
    done  

    let TOTAL_NODE_COUNT=TOTAL_NODE_COUNT+${_node_cnt_}
    if [ "${_network_}" == "CORE" ]; then
        CORE_COUNT=${_node_cnt_}
    fi
    if [ "${_network_}" == "GRAN" ]; then
        GRAN_COUNT=${_node_cnt_}
    fi
    if [ "${_network_}" == "WRAN" ]; then
        WRAN_COUNT=${_node_cnt_}
    fi
    
    _main_space_required_=`$EXPR ${_node_main_space_} \* ${_node_cnt_}`
    _temp_space_required_=`$EXPR ${_node_temp_space_} \* ${_node_cnt_}`

    let TOTAL_NODE_MAIN_SPACE=TOTAL_NODE_MAIN_SPACE+${_main_space_required_}
    let TOTAL_NODE_TEMP_SPACE=TOTAL_NODE_TEMP_SPACE+${_temp_space_required_}
done

# Has there been enough MAIN DBspace already allocated 
EXIT_FLAG_CNT=0
unset UPDATE_MAIN_DBSPACE_FLAG
_chk_size_=`$EXPR ${TOTAL_NODE_MAIN_SPACE} \* 1024 \* 1024`
if [ ${TOTAL_MAIN_SYB_IQ_DBSPACE_SIZE} -ge ${_chk_size_} ]; then
    log_msg -s "Sufficient MAIN Space has already been allocated to Sybase IQ" ${LOG_OUT_STR}
    let EXIT_FLAG_CNT=EXIT_FLAG_CNT+1
    MAIN_UPDATE_SPACE=0
else
    MAIN_UPDATE_SPACE=`$ECHO \(${_chk_size_} - ${TOTAL_MAIN_SYB_IQ_DBSPACE_SIZE}\) / 1024 / 1024 | $BC`
    UPDATE_MAIN_DBSPACE_FLAG=Y
fi

# Has there been enough TEMP DBspace already allocated 
unset UPDATE_TEMP_DBSPACE_FLAG
_chk_size_=`$EXPR ${TOTAL_NODE_TEMP_SPACE} \* 1024 \* 1024`
if [ ${TOTAL_TEMP_SYB_IQ_DBSPACE_SIZE} -ge ${_chk_size_} ]; then
    log_msg -s "Sufficient TEMP Space has already been allocated to Sybase IQ" ${LOG_OUT_STR}
    let EXIT_FLAG_CNT=EXIT_FLAG_CNT+1
    TEMP_UPDATE_SPACE=0
else
    TEMP_UPDATE_SPACE=`$ECHO \(${_chk_size_} - ${TOTAL_TEMP_SYB_IQ_DBSPACE_SIZE}\) / 1024 / 1024 | $BC`
    UPDATE_TEMP_DBSPACE_FLAG=Y
fi

# Check if we need to updated IQ SYS MAIN Size
chk_iq_sys_main_size

if [ ${EXIT_FLAG_CNT} -eq 3 ]; then
    # Clean up
    $RM -rf ${TEM_DIR}
    exit 0
fi

# Check that the there is adequate disk space
# for the cell/node configuration.
_req_main_temp_space_MB_=`$EXPR  ${MAIN_UPDATE_SPACE} + ${TEMP_UPDATE_SPACE} + ${IQ_SYS_MAIN_UPDATE_SPACE}`
check_disk_space ${_req_main_temp_space_MB_}

if [ "${UPDATE_SYS_MAIN_DBSPACE_FLAG}" ]; then
    # Get the next IQ SYS MAIN NUMBER
    calculate_iq_sys_main_details ${IQ_SYS_MAIN_UPDATE_SPACE}
fi

if [ "${UPDATE_MAIN_DBSPACE_FLAG}" ]; then
    # Calculate number of main dbspaces required and the
    # size of each dbspace
    calculate_main_dbspace_details ${MAIN_UPDATE_SPACE}
fi

if [ "${UPDATE_TEMP_DBSPACE_FLAG}" ]; then
    # Calculate number of temp dbspaces required and the
    # size of each dbspace
    calculate_temp_dbspace_details ${TEMP_UPDATE_SPACE}
fi
}

### Function: update_dbspace_ini ###
#
# Update the ${SYM_INI} with the dbspaces
#
# Arguments:
#    none
# Return Values:
#    none
update_dbspace_ini()
{
local _dir_num_
local _loop_cnt_
local _disc_cnt
if [ ! ${FS_TYPE} ];then
    FS_TYPE=fs
fi

if [ "${UPDATE_MAIN_DBSPACE_FLAG}" ]; then
    let _loop_cnt_=${START_MAIN_DBSPACE_NUM}+${NUM_MAIN_DBSPACES}-1
    let _disc_cnt=${NUM_MAIN_DBSPACES}-1
    for (( i=${START_MAIN_DBSPACE_NUM}; i<=${_loop_cnt_}; i++)); do
        # Get the directory number. If the last character is 1 then go to dbspace_dir_1,
        # if the last character is 2 then go to dbspace_dir_2....
        # if the last character is 0 then go to dbspace_dir_10....
    
        # Get the last digit
        _last_dig_=`$ECHO ${i: -1}`
        if [ ${_last_dig_} -eq 0 ]; then
            _dir_num_=10
        else
            _dir_num_=${_last_dig_}
        fi
    
        $RM -f ${TEM_DIR}/ins_det
        $ECHO "[DWH_DBSPACES_MAIN_${i}]" >> ${TEM_DIR}/ins_det
        $ECHO "Path=${MAIN_DB_PATH}/${DB_DIR_NAME_TEMPL}${_dir_num_}/main_${i}.iq" >> ${TEM_DIR}/ins_det
        if [ "${FS_TYPE}" == "raw" ]; then
            # Get the last Lun added to the MAINDB_DISKS 
            _main_dev_=`iniget DB_DISK_ALLOC -f ${TEM_DIR}/${SYM_INI} -v MAINDB_DISKS | $AWK  '{print $(NF-'${_disc_cnt}')}'`
            _main_lun_id_=`$CAT ${TEM_DIR}/listluns.txt|$EGREP "${_main_dev_}"|$AWK -F\; '{print $1}'`
            if [ ! "${_main_lun_id_}" ]; then
                _err_msg_="Could not read LUN ID for ${_main_dev_} from \n${TEM_DIR}/listluns.txt"
                abort_script "$_err_msg_"
            fi
            let _disc_cnt=${_disc_cnt}-1
            $ECHO "Lun_ID=${_main_lun_id_}" >> ${TEM_DIR}/ins_det
            $ECHO "Size=" >> ${TEM_DIR}/ins_det
        else
            $ECHO "Lun_ID=" >> ${TEM_DIR}/ins_det
            $ECHO "Size=${MAIN_SPACE_PER_DBSPACE}" >> ${TEM_DIR}/ins_det
        fi
        $ECHO "Type=${FS_TYPE}" >> ${TEM_DIR}/ins_det

        if [ "${FS_TYPE}" == "raw" ]; then
                read_storage_type 
                register_raw_device
                _main_sys_link_="/dev/raw/raw${count}"
                $ECHO "Link=${_main_sys_link_}" >> ${TEM_DIR}/ins_det

        fi
        if [ "${FS_TYPE}" == "raw" ]; then
            _disk_name_="${_main_dev_}1"
            $ECHO "Disk=${_disk_name_}">> ${TEM_DIR}/ins_det
        fi  
            
        if [ "${FS_TYPE}" == "raw" ]; then
                _wwn_id_=`$MULTIPATH -l | $GREP -w ${_main_dev_} | $AWK -F "(" '{print $2}' | $AWK -F ")" '{print $1}'`
                $ECHO "WWN=${_wwn_id_}">> ${TEM_DIR}/ins_det
        fi 

        $RM -f  ${TEM_DIR}/${SYM_INI}_tmp
        if [ "${LOG_OUT_STR}" ]; then
            log_msg -s "Updating ${TEM_DIR}/${SYM_INI} with DWH_DBSPACES_MAIN_${i}" ${LOG_OUT_STR} ${_bkup_quiet_}
        fi
        ${ENIQ_ADMIN_DIR}/lib/iniadd.pl -g DWH_DBSPACES_MAIN -p DWH_DBSPACES_MAIN_${i} -i ${TEM_DIR}/${SYM_INI} -d ${TEM_DIR}/ins_det -o ${TEM_DIR}/${SYM_INI}_tmp
        if [ $? -ne 0 ]; then
            _err_msg_="Error adding DWH_DBSPACES_MAIN_${i} to ${TEM_DIR}/${SYM_INI}"
            abort_script "$_err_msg_" 
        fi
    
        $CP ${TEM_DIR}/${SYM_INI}_tmp ${TEM_DIR}/${SYM_INI}
    done
fi

if [ "${UPDATE_TEMP_DBSPACE_FLAG}" ]; then
    let _loop_cnt_=${START_TEMP_DBSPACE_NUM}+${NUM_TEMP_DBSPACES}-1
    local _disc_cnt=0
    for (( i=${START_TEMP_DBSPACE_NUM}; i<=${_loop_cnt_}; i++)); do
        # Get the directory number. If the last character is 1 then go to dbspace_dir_1,
        # if the last character is 2 then go to dbspace_dir_2....
        # if the last character is 0 then go to dbspace_dir_10....
    
        # Get the last digit
        _last_dig_=`$ECHO ${i: -1}`
        case ${_last_dig_} in
        1|6) _dir_num_=1
            ;;
        2|7) _dir_num_=2
            ;;
        3|8) _dir_num_=3
            ;;
        4|9) _dir_num_=4
            ;;
        5|0) _dir_num_=5
            ;;
        esac
    
        $RM -f ${TEM_DIR}/ins_det
        $ECHO "[DWH_DBSPACES_TEMP_${i}]" >> ${TEM_DIR}/ins_det
            if [ "${READER_SERVER_TYPE}" == "YES" ]; then
                _hname_=`$HOSTNAME`
                _ip_addr_=`$HOSTNAME -i | $AWK '{print $1}' | $HEAD -1`
                if [ ! "${_ip_addr_}" ]; then
                    _err_msg_="Could not determine Reader IP address"
                    abort_script "$_err_msg_"
                fi

                _reader_name_=`$CAT ${CLI_CONF_DIR}/service_names|$EGREP "^[[:blank:]]*${_ip_addr_}::.+dwh_reader" |$AWK -F"::" '{print $NF}'` 
                if [ ! "${_reader_name_}" ]; then
                    _err_msg_="Could not read reader name from ${CLI_CONF_DIR}/service_names"
                    abort_script "$_err_msg_"
                fi

                $ECHO "Path=${TEMP_DB_PATH}/${DB_DIR_NAME_TEMPL}${_dir_num_}/${_reader_name_}_temp_${i}.iqtmp" >> ${TEM_DIR}/ins_det

            else
 
            $ECHO "Path=${TEMP_DB_PATH}/${DB_DIR_NAME_TEMPL}${_dir_num_}/temp_${i}.iqtmp" >> ${TEM_DIR}/ins_det
            fi 
            if [ "${FS_TYPE}" == "raw" ]; then
                # Get the last Lun added to the TEMPDB_DISKS 
                _temp_dev_=`iniget DB_DISK_ALLOC -f ${TEM_DIR}/${SYM_INI} -v TEMPDB_DISKS | $AWK  '{print $(NF-'${_disc_cnt}')}'`
                _temp_lun_id_=`$CAT ${TEM_DIR}/listluns.txt|$GREP -w "${_temp_dev_}"|$AWK -F\; '{print $1}'`
                if [ ! "${_temp_lun_id_}" ]; then
                    _err_msg_="Could not read LUN ID for ${_temp_dev_} from \n${TEM_DIR}/listluns.txt"
                    abort_script "$_err_msg_"
                fi
                let _disc_cnt=${_disc_cnt}+1
                $ECHO "Lun_ID=${_temp_lun_id_}" >> ${TEM_DIR}/ins_det
                $ECHO "Size=" >> ${TEM_DIR}/ins_det
            else 
                $ECHO "Lun_ID=${_temp_lun_id_}" >> ${TEM_DIR}/ins_det
                $ECHO "Size=${TEMP_SPACE_PER_DBSPACE}" >> ${TEM_DIR}/ins_det
            fi
            $ECHO "Type=${FS_TYPE}" >> ${TEM_DIR}/ins_det
            if [ "${FS_TYPE}" == "raw" ]; then
               read_storage_type
               register_raw_device
            _temp_sys_link_="/dev/raw/raw${count}"
            fi
            $ECHO "Link=${_temp_sys_link_}" >> ${TEM_DIR}/ins_det
        
        if [ "${FS_TYPE}" == "raw" ]; then
            _disk_name_="${_temp_dev_}1"
            $ECHO "Disk=${_disk_name_}">> ${TEM_DIR}/ins_det
        fi  
            
        if [ "${FS_TYPE}" == "raw" ]; then
                _wwn_id_=`$MULTIPATH -l | $GREP -w ${_temp_dev_} | $AWK -F "(" '{print $2}' | $AWK -F ")" '{print $1}'`
                $ECHO "WWN=${_wwn_id_}">> ${TEM_DIR}/ins_det
                   
        fi 
        
        $RM -f ${TEM_DIR}/${SYM_INI}_tmp
    
        if [ "${LOG_OUT_STR}" ]; then
        log_msg -s "Updating ${TEM_DIR}/${SYM_INI} with DWH_DBSPACES_TEMP_${i}" ${LOG_OUT_STR} ${_bkup_quiet_}
        fi
        ${ENIQ_ADMIN_DIR}/lib/iniadd.pl -g DWH_DBSPACES_TEMP -p DWH_DBSPACES_TEMP_${i} -i ${TEM_DIR}/${SYM_INI} -d ${TEM_DIR}/ins_det -o ${TEM_DIR}/${SYM_INI}_tmp
        if [ $? -ne 0 ]; then
            _err_msg_="Error adding DWH_DBSPACES_TEMP_${i} to ${TEM_DIR}/${SYM_INI}"
            abort_script "$_err_msg_" 
        fi
    
        $CP ${TEM_DIR}/${SYM_INI}_tmp ${TEM_DIR}/${SYM_INI}
    done
fi


if [ "${UPDATE_SYS_MAIN_DBSPACE_FLAG}" ]; then
    $RM -f ${TEM_DIR}/ins_det

    # Get the next DWH_SYSTEM_MAIN Parent number
    _iq_parent_num_=`iniget DWH_SYSTEM_MAIN -f ${TEM_DIR}/${SYM_INI} |$AWK -F\_ '{print $NF}'|$SORT -n|$TAIL -1`
    let _iq_parent_num_=_iq_parent_num_+1

    $ECHO "[DWH_SYSTEM_MAIN_${_iq_parent_num_}]" >> ${TEM_DIR}/ins_det
    $ECHO "Path=${IQ_SYS_MAIN_DB_PATH}/iq_system_main_${NEXT_SYS_MAIN_DBSPACE_NUM}.iq" >> ${TEM_DIR}/ins_det
    if [ "${FS_TYPE}" == "raw" ]; then
        # Get the last Lun added to the IQ_SYS_MAIN_DISKS 
        _iq_sys_dev_=`iniget DB_DISK_ALLOC -f ${TEM_DIR}/${SYM_INI} -v IQ_SYS_MAIN_DISKS | $AWK  '{print $NF}'`
        _iq_lun_id_=`$CAT ${TEM_DIR}/listluns.txt|$GREP -w "${_iq_sys_dev_}"|$AWK -F\; '{print $1}'`
        if [ ! "${_iq_lun_id_}" ]; then
            _err_msg_="Could not read LUN ID for ${_iq_sys_dev_} from \n${TEM_DIR}/listluns.txt"
            abort_script "$_err_msg_"
        fi

    fi
    $ECHO "Lun_ID=${_iq_lun_id_}" >> ${TEM_DIR}/ins_det
    $ECHO "Type=${FS_TYPE}" >> ${TEM_DIR}/ins_det
    $ECHO "Size=${IQ_SYS_MAIN_UPDATE_SPACE}" >> ${TEM_DIR}/ins_det
    if [ "${FS_TYPE}" == "raw" ]; then
        _iq_sys_link_="/dev/rdsk/${_iq_sys_dev_}s0"
    fi
    $ECHO "Link=${_iq_sys_link_}" >> ${TEM_DIR}/ins_det
    $RM -f ${TEM_DIR}/${SYM_INI}_tmp
    if [ "${LOG_OUT_STR}" ]; then
        log_msg -s "Updating ${TEM_DIR}/${SYM_INI} with DWH_SYSTEM_MAIN_${_iq_parent_num_}" ${LOG_OUT_STR} ${_bkup_quiet_}
    fi
    ${ENIQ_ADMIN_DIR}/lib/iniadd.pl -g DWH_SYSTEM_MAIN -p DWH_SYSTEM_MAIN_${_iq_parent_num_} -i ${TEM_DIR}/${SYM_INI} -d ${TEM_DIR}/ins_det -o ${TEM_DIR}/${SYM_INI}_tmp
    if [ $? -ne 0 ]; then
        _err_msg_="Error adding DWH_DBSPACES_TEMP_${i} to ${TEM_DIR}/${SYM_INI}"
        abort_script "$_err_msg_" 
    fi
    $CP ${TEM_DIR}/${SYM_INI}_tmp ${TEM_DIR}/${SYM_INI}
fi
}

### Function: usage_msg ###
#
#   Print out the usage message
#
# Arguments:
#    none
# Return Values:
#    none
usage_msg() 
{
clear
$ECHO "
Usage: `$BASENAME $0` [ -d <path_to_niq_ini_dir> ] [ -l <path_to_logfile> ] [-c]
                      
options:

-c  : Optional parameter to run a consistency check. 

-d  : Optional parameter specifying the full path to the directory containing
      the niq.ini file to be updated. 

-l  : Optional parameter specifying the full path to logfile.
"
}

# ********************************************************************
#
#     Main body of program
#
# ********************************************************************
#
RUN_TIME=`$DATE '+%Y-%b-%d_%H.%M.%S'`

# Determine absolute path to software
get_absolute_path

# Check that the effective id of the user is root
check_id 

while getopts ":cd:f:l:m:Nsrt:SMTk:a:" arg; do
    case $arg in
    c) CHK_ONLY="YES" 
        ;;
    d) CLI_CONF_DIR="$OPTARG" 
        ;;
    f) IQ_SYS_MAIN_CHNG_FILE="$OPTARG"
        ;;
    l) LOGFILE="$OPTARG"
        ;;
    m) MAIN_USER_NUM_SPACE="$OPTARG"
        ;;
    N) NO_CONFIRM="YES"
        ;;
    s) UPDATE_SYS_MAIN_ONLY="YES"
        ;;
    r) UPDATE_RAW_DB="YES"
        ;;
    t) TEMP_USER_NUM_SPACE="$OPTARG"
        ;;
    S) RAW_UPDATE_SYS_MAIN_FLAG="YES"
        ;;
    M) RAW_UPDATE_MAIN_FLAG="YES"
        ;;
    T) RAW_UPDATE_TEMP_FLAG="YES"
        ;;
    a) AUTOMATION="YES"
        ;;
    \?) usage_msg
       exit 1
       ;;
    esac
done
shift `$EXPR $OPTIND - 1`

if [ ! -s $SCRIPTHOME/../lib/common_functions.lib ]; then
    _err_msg_="Cannot locate $SCRIPTHOME/../lib/common_functions.lib"
    abort_script "$_err_msg_" 
else
    . $SCRIPTHOME/../lib/common_functions.lib
fi

# Setup up path environment etc
setup_env

if [ ! "${LOGFILE}" ]; then
    LOGFILE=${LOGFILE_DIR}/update_cell_count.log
fi

#Setting the automation flag
if [ "${AUTOMATION}" == "YES" ]; then
   automation_flag="true"
else
   automation_flag="false"
fi

# Check/Create Logfile
chk_create_logfile
LOG_OUT_STR="-l ${LOGFILE}"

log_msg -s "\n-------------------------------------------------------" ${LOG_OUT_STR}
log_msg -s "${RUN_TIME} - Starting to execute $0" ${LOG_OUT_STR}
log_msg -s "-------------------------------------------------------" ${LOG_OUT_STR}

if [ ! "${CLI_CONF_DIR}" ]; then
    CLI_CONF_DIR=${DEF_CLI_CONF_DIR}
fi

if [ ! -s ${CLI_CONF_DIR}/${ENIQ_INI} ]; then
    _err_msg_="File ${CLI_CONF_DIR}/${ENIQ_INI} not found or empty"
    abort_script "$_err_msg_"
fi

if [ "${MAIN_USER_NUM_SPACE}" ]; then
    $ECHO ${MAIN_USER_NUM_SPACE} | $EGREP '[^0-9]' >> /dev/null 2>&1
    if [ $? -eq 0 ]; then
        _err_msg_="Numeric value only for number of main spaces"
        abort_script "$_err_msg_" 
    fi
    if [ ${MAIN_USER_NUM_SPACE} -eq 0 ]; then
        _err_msg_="Numeric value greater than zero for number of main spaces"
        abort_script "$_err_msg_" 
    fi
fi

if [ "${TEMP_USER_NUM_SPACE}" ]; then
    $ECHO ${TEMP_USER_NUM_SPACE} | $EGREP '[^0-9]' >> /dev/null 2>&1
    if [ $? -eq 0 ]; then
        _err_msg_="Numeric value only for number of temp spaces"
        abort_script "$_err_msg_" 
    fi
    if [ ${TEMP_USER_NUM_SPACE} -eq 0 ]; then
        _err_msg_="Numeric value greater than zero for number of temp spaces"
        abort_script "$_err_msg_" 
    fi
fi

# Create a temporary Directory
TEM_DIR=/tmp/update_cell_node_count.$$
$RM -rf ${TEM_DIR}
$MKDIR -p ${TEM_DIR}
if [ $? -ne 0 ]; then
    _err_msg_="Could not create directory ${TEM_DIR}"
    abort_script "$_err_msg_"
fi    

$CHMOD 777 ${TEM_DIR}
if [ $? -ne 0 ]; then
    _err_msg_="Could not update directory ${TEM_DIR} permissions"
    abort_script "$_err_msg_"
fi  

# Check the sys main ini structure is correct
check_sys_main_ini_structure

log_msg -s "\nMaking a copy of ${CLI_CONF_DIR}/${ENIQ_INI} and ${ENIQ_CONF_DIR}/${SYM_INI} in ${TEM_DIR}" ${LOG_OUT_STR}
$CP ${CLI_CONF_DIR}/${ENIQ_INI} ${TEM_DIR}/${ENIQ_INI}
$CP ${ENIQ_CONF_DIR}/${SYM_INI} ${TEM_DIR}/${SYM_INI}

# Set up Sybase environment
setup_sybase_env

# Check the existing DBSPACES. Check that all dbspaces in the
# ini file exist and that all dbspaces exist in the ini file
check_exist_dbspaces

if [ ! "${CHK_ONLY}" ]; then
    if [ "${UPDATE_SYS_MAIN_ONLY}" ]; then
        chk_iq_sys_main_size
        if [ "${UPDATE_SYS_MAIN_DBSPACE_FLAG}" ]; then
                # Get the next IQ SYS MAIN NUMBER
                calculate_iq_sys_main_details ${IQ_SYS_MAIN_UPDATE_SPACE}
        fi
    else
        if [ "${UPDATE_RAW_DB}" ];then
            
            # Is this on Raw, so do some RAW setup
            FS_TYPE=raw
            # We need to get the path to IQ SYS MAIN
            
            _iq_sys_main_db_=`iniget DWH_SYSTEM_MAIN -f ${TEM_DIR}/${SYM_INI}|$HEAD -1`
            if [ ! "${_iq_sys_main_db_}" ]; then
                _err_msg_="Could not read DWH_SYSTEM_MAIN details from ${SYM_INI}"
                abort_script "$_err_msg_" 
            fi
            IQ_SYS_MAIN_DB_PATH=`iniget ${_iq_sys_main_db_} -f ${TEM_DIR}/${SYM_INI} -v Path`
            if [ ! "${IQ_SYS_MAIN_DB_PATH}" ]; then
                _err_msg_="Could not read ${_iq_sys_main_db_}/Path parameter from ${SYM_INI}"
                abort_script "$_err_msg_" 
            fi            
            IQ_SYS_MAIN_DB_PATH=`$DIRNAME ${IQ_SYS_MAIN_DB_PATH}|$SED -e 's/\/[\/]*/\//g' -e 's/[\/]*$//g'`
            MAIN_DB_PATH=`iniget DWH_DBSPACES_LOCATION -f ${TEM_DIR}/${SYM_INI} -v MAIN_DB_PATH`
            if [ ! "${MAIN_DB_PATH}" ]; then
                _err_msg_="Could not find MAIN_DB_PATH in ${SYM_INI}"
                abort_script "$_err_msg_" 
            fi
            
            TEMP_DB_PATH=`iniget DWH_DBSPACES_LOCATION -f ${TEM_DIR}/${SYM_INI} -v TEMP_DB_PATH`
            if [ ! "${TEMP_DB_PATH}" ]; then
                _err_msg_="Could not find TEMP_DB_PATH in ${SYM_INI}"
                abort_script "$_err_msg_" 
            fi
            
            DB_DIR_NAME_TEMPL=`iniget DWH_DBSPACES_LOCATION -f ${TEM_DIR}/${SYM_INI} -v DB_DIR_NAME_TEMPL`
            if [ ! "${DB_DIR_NAME_TEMPL}" ]; then
                _err_msg_="Could not find DB_DIR_NAME_TEMPL in ${SYM_INI}"
                abort_script "$_err_msg_" 
            fi
            
            _stor_api_cmd_=`iniget STOR_API -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v STOR_API_CMD`
            if [ ! "${_stor_api_cmd_}" ]; then
                _err_msg_="Could not read STOR_API_CMD param from ${INI_DIR}/${SUNOS_INI}"
                abort_script "$_err_msg_"
            fi
            $RM -f ${TEM_DIR}/listluns.txt
            ${_stor_api_cmd_} --action listluns >> ${TEM_DIR}/listluns.txt
            if [ $? -ne 0 ]; then
                _err_msg_="Error getting list of luns for Lun Map ini creation"
                abort_script "$_err_msg_"
            fi
            
        
            if [ "${RAW_UPDATE_SYS_MAIN_FLAG}" ]; then
                # Get the next IQ SYS MAIN NUMBER
                calculate_iq_sys_main_details ${IQ_SYS_MAIN_UPDATE_SPACE}
                UPDATE_SYS_MAIN_DBSPACE_FLAG="YES"
            fi
            
            if [ "${RAW_UPDATE_MAIN_FLAG}" ]; then
                # Calculate number of main dbspaces required and the
                # size of each dbspace
                MAIN_UPDATE_SPACE=10
                calculate_main_dbspace_details ${MAIN_UPDATE_SPACE}
                UPDATE_MAIN_DBSPACE_FLAG="YES"
            fi
            
            if [ "${RAW_UPDATE_TEMP_FLAG}" ]; then
                # Calculate number of temp dbspaces required and the
                # size of each dbspace
                TEMP_UPDATE_SPACE=10
                calculate_temp_dbspace_details ${TEMP_UPDATE_SPACE}
                UPDATE_TEMP_DBSPACE_FLAG="YES"
            fi
        else
        # Get the value of IQ_MAIN and IQ_TEMP to be expanded
        check_disk_space
    fi
    fi

    if [ "${UPDATE_SYS_MAIN_DBSPACE_FLAG}" -o "${UPDATE_MAIN_DBSPACE_FLAG}" -o "${UPDATE_TEMP_DBSPACE_FLAG}" ]; then
        _upd_flag_=0 
        if [ ! "$NO_CONFIRM" ]; then
            # Confirm the User Input
            confirm_user_input
            
            if [ "${USER_CONF}" == "Y" -o "${USER_CONF}" == "y" ]; then
                _upd_flag_=1
            fi
        else
            _upd_flag_=1
        fi
        
        if [ ${_upd_flag_} -eq 1 ]; then
                # Update the ${SYM_INI} with the dbspaces
            update_dbspace_ini 
    
                # Catch any interrupts at this stage
            trap "abort_script" 1 2 3 14 15
    
            log_msg -s "Creating backup of ${CLI_CONF_DIR}/${ENIQ_INI} and ${ENIQ_CONF_DIR}/${SYM_INI} in ${ENIQ_CONF_DIR}/backup" ${LOG_OUT_STR} ${_bkup_quiet_}
            $MKDIR -p ${ENIQ_CONF_DIR}/backup
            $CP ${CLI_CONF_DIR}/${ENIQ_INI} ${ENIQ_CONF_DIR}/backup/${ENIQ_INI}.${RUN_TIME}
            $CP ${ENIQ_CONF_DIR}/${SYM_INI} ${ENIQ_CONF_DIR}/backup/${SYM_INI}.${RUN_TIME}
            ## Make the updated one's live
            $CP ${TEM_DIR}/${ENIQ_INI} ${ENIQ_CONF_DIR}/${ENIQ_INI}
            $CP ${TEM_DIR}/${SYM_INI} ${ENIQ_CONF_DIR}/${SYM_INI}
            $CP ${TEM_DIR}/${ENIQ_INI} ${CLI_CONF_DIR}/${ENIQ_INI}
        fi
    fi
else
    log_msg -s "\nConsistency check passed\n" ${LOG_OUT_STR}    
fi

if [ "${IQ_SYS_MAIN_CHNG_FILE}" -a "${UPDATE_SYS_MAIN_DBSPACE_FLAG}" ]; then
    $TOUCH ${IQ_SYS_MAIN_CHNG_FILE} >> /dev/null 2>&1
fi

# Clean up
$RM -rf ${conn_str_dbping_enc}							  
$RM -rf ${TEM_DIR}

exit 0

