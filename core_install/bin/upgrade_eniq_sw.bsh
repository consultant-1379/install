#!/usr/bin/bash
#********************************************************************
# Ericsson Radio Systems AB SCRIPT
#********************************************************************
#
# (c) Ericsson Radio Systems AB 2023- All rights reserved.
#
# The copyright to the computer program(s) herein is the property
# of Ericsson Radio Systems AB, Sweden. The programs may be used
# and/or copied only with the written permission from Ericsson Radio
# Systems AB or in accordance with the terms and conditions stipulated
# in the agreement/contract under which the program(s) have been
# in the agreement/contract under which the program(s) have been
# supplied.
#
#********************************************************************
# Name     : upgrade_eniq_sw.bsh
# Date     : 19/10/2023
# Revision : \main\115
# Purpose  : A wrapper script to Resize NAS Sybase iq and sw File Systems,
#            disable oss mounts, unpack the core sw, to prepare server for
#            upgrade, to upgrade the Core Installer SW, Sybase ASA, Sybase
#            IQ and Platform Upgrade, perform the post upgrade steps
#            and Rollback from coordinator across all the server(s) in the 
#            deployment.
# Usage    : upgrade_eniq_sw.bsh -A <action_type> -D <eniq_sw_dir> 
#            -O <om_media_location> -P <new_sw_extraction_loc> [ -M <sol_om_media_location> ] [ -l <path_to_logfile> ]
#
#********************************************************************
#
#       Command Section
#
#********************************************************************
AWK=/usr/bin/awk
BASENAME=/usr/bin/basename
CAT=/usr/bin/cat
CHMOD=/usr/bin/chmod
CLEAR=/usr/bin/clear
CP=/usr/bin/cp
DATE=/usr/bin/date
DIRNAME=/usr/bin/dirname
ECHO=/usr/bin/echo
EXPR=/usr/bin/expr
EGREP=/usr/bin/egrep
ENV=/usr/bin/env
EXPECT=/usr/bin/expect
GETENT=/usr/bin/getent
GREP=/usr/bin/grep
HEAD=/usr/bin/head
ID=/usr/bin/id
LS=/usr/bin/ls
LVS=/usr/sbin/lvs
MYHOSTNAME=/usr/bin/hostname
MKDIR=/usr/bin/mkdir
PERL=/usr/bin/perl
PS=/usr/bin/ps
PYTHON=/usr/bin/python
RM=/usr/bin/rm
RPM=/usr/bin/rpm
SCP=/usr/bin/scp
SED=/usr/bin/sed
SORT=/usr/bin/sort
SLEEP=/usr/bin/sleep
SU=/usr/bin/su
SUDO=/usr/bin/sudo
SYSTEMCTL=/usr/bin/systemctl
TEE=/usr/bin/tee
TOUCH=/usr/bin/touch
TR=/usr/bin/tr
UNIQ=/usr/bin/uniq


# ********************************************************************
#
#       Configuration Section
#
# ********************************************************************

# Default user
DEFAULT_USER=root

# Name of SunOS File
SUNOS_INI=SunOS.ini
ENIQ_INI=niq.ini

# Name of Storage INI File
STORAGE_INI=storage.ini

# Cmd to exec a shell and drop user to it in case of an error
EXEC_SHELL_CMD="exec /bin/bash -o emacs"

# NAS SMF
NAS_MILESTONE_SMF_ID="NAS-online.service"
NASd_SMF_ID="NASd.service"

# Service SMFs
DDC_SMF_ID="ddc.service"

#********************************************************************
#
#       Functions Section
#
#********************************************************************
### Function: abort_script ###
#
# This Function will abort the script if any issues or errors.
#
# Arguments:
#       $1 - Error message from part of program (Not always used)
#        $2 - Exec Shell cmd (Not always used)
# Return Values:
#       none
abort_script()
{
ABORT_TIME=`$DATE '+%Y-%b-%d_%H.%M.%S'`
if [ "$1" ]; then
    _err_msg_=$1
else
    _err_msg_="$ABORT_TIME - ERROR : Script aborted.......\n"
fi

if [ -d ${TEM_DIR} ]; then
    $RM -rf ${TEM_DIR}
    if [ $? -ne 0 ]; then
        _err_msg_="Could not delete directory $TEM_DIR. Please delete it manually."
    fi
fi

if [ "${LOGFILE}" ]; then
    $ECHO "\n${ABORT_TIME} - ERROR : $_err_msg_\n" | $TEE -a ${LOGFILE}
else
    $ECHO "\n${ABORT_TIME} - ERROR : $_err_msg_\n"
fi

if [ -s /eniq/sw/conf/.repdb_user_password_change ];then 
    $RM -rf /eniq/sw/conf/.repdb_user_password_change 
fi
if [ -s /eniq/sw/conf/ETLCServer.properties_bkp ];then
    $RM -rf /eniq/sw/conf/ETLCServer.properties_bkp
fi

if [ "$2" ]; then
    ${2}
    exit 1
else
    exit 1
fi
}

### Function: check_for_file ###
#
# To check whether file or directory exist or not and to test the basic file operations.
# 
# Arguments: 
#       $1 : File operations
#        $2 : File qualified path
# Return Values:
#         none
check_for_file()
{
if [ ! $1 $2 ]; then
    _err_msg_="$2 does not exist"
    abort_script "$_err_msg_"
fi
} 

### Function: check_nas_sybase_iq_size ###
#
# To check NAS file system size for sybase_iq
#
# Arguments:
#       none
# Return Values:
#       none
check_nas_sybase_iq_size()
{
insert_header_footer head "Entering Upgrade stage - ${NEXT_STAGE}" ${LOGFILE}

if [ "${STORAGE_TYPE}" == "fs" ]; then
    insert_header_footer foot "INFO: Skipping Upgrade Stage - ${NEXT_STAGE} for Rack" ${LOGFILE} 
    set_next_stage `$EXPR ${ARRAY_ELEM}+1`
    return 0
fi

# Fetch current NAS FS size of Sybase IQ
SYS_ID=`iniget Storage_NAS_GENERAL -f ${ENIQ_CONF_DIR}/${STORAGE_INI} -v SYS_ID`
if [ ! "${SYS_ID}" ]; then
    _err_msg_="Could not determine SYS_ID from ${ENIQ_CONF_DIR}/${STORAGE_INI}"
    abort_script "$_err_msg_"
fi

log_msg -s "Checking current size of NAS Sybase IQ File System." -l ${LOGFILE}
_curr_sybase_iq_nas_size_=`/ericsson/storage/bin/nascli list_fs raw - ${SYS_ID} | $GREP "${SYS_ID}-sybase_iq " | $AWK '{print \$3}' | $CUT -d'.' -f1`
if [ ! "${_curr_sybase_iq_nas_size_}" ]; then
    _err_msg_="Could not determine current NAS Sybase IQ File System size."
    abort_script "$_err_msg_"
fi

log_msg -s "Current size of NAS Sybase IQ File System: ${_curr_sybase_iq_nas_size_}G" -l ${LOGFILE}
# Check if current NAS FS size of Sybase IQ is less than 5G
if [ "${_curr_sybase_iq_nas_size_}" -lt 5 ]; then
    log_msg -s "Current NAS FS size for Sybase IQ is < 5.00G" -l ${LOGFILE}
    $TOUCH ${VAR_TMP_DIR}/resize_iq_required
    if [ $? -ne 0 ]; then
        _err_msg_="Could not create ${VAR_TMP_DIR}/resize_iq_required. 
        Failed at ${NEXT_STAGE}. Please refer logs: ${LOGFILE}"
        abort_script "$_err_msg_"
    fi
fi

insert_header_footer foot "Successfully checked NAS Sybase iq File System size." ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}
    
### Function: check_nas_sw_size ###
#
# To check NAS file system size for /eniq/sw
#
# Arguments:
#       none
# Return Values:
#       none
check_nas_sw_size()
{
insert_header_footer head "Entering Upgrade stage - ${NEXT_STAGE}" ${LOGFILE}

if [ "${STORAGE_TYPE}" == "fs" ]; then
    insert_header_footer foot "INFO: Skipping Upgrade Stage - ${NEXT_STAGE} for Rack " ${LOGFILE} 
    set_next_stage `$EXPR ${ARRAY_ELEM}+1`
    return 0
fi

if [ "${CURR_SERVER_TYPE}" != "eniq_stats" -a "${CURR_SERVER_TYPE}" != "stats_coordinator" ]; then
    insert_header_footer foot "INFO: Skipping Upgrade Stage - ${NEXT_STAGE} for ${CURR_SERVER_TYPE}  " ${LOGFILE} 
    set_next_stage `$EXPR ${ARRAY_ELEM}+1`
    return 0
fi

SYS_ID=`iniget Storage_NAS_GENERAL -f ${ENIQ_CONF_DIR}/${STORAGE_INI} -v SYS_ID` 
if [ ! "${SYS_ID}" ]; then
    _err_msg_="Could not determine SYS_ID from ${ENIQ_CONF_DIR}/${STORAGE_INI}"
    abort_script "$_err_msg_"
fi

# Check current NAS FS size of SW 
log_msg -s "Checking current size of NAS /eniq/sw File System" -l ${LOGFILE}
_curr_sw_nas_size_=`/ericsson/storage/bin/nascli list_fs raw - ${SYS_ID} | $GREP "${SYS_ID}-sw " | $AWK '{print \$3}' | $CUT -d'.' -f1`
if [ ! "${_curr_sw_nas_size_}" ]; then
    _err_msg_="Could not determine current NAS /eniq/sw File System size."
    abort_script "$_err_msg_"
fi

log_msg -s "Current size of NAS /eniq/sw File System : ${_curr_sw_nas_size_}G" -l ${LOGFILE}

if [ "${_curr_sw_nas_size_}" -lt 6 ]; then
    log_msg -s "Current NAS FS size for /eniq/sw is < 6.00G" -l ${LOGFILE}
    $TOUCH ${VAR_TMP_DIR}/resize_sw_required
    if [ $? -ne 0 ]; then
        _err_msg_="Could not create ${VAR_TMP_DIR}/resize_sw_required. 
        Failed at ${NEXT_STAGE}. Please refer logs: ${LOGFILE}"
        abort_script "$_err_msg_"
    fi
fi

insert_header_footer foot "Successfully checked NAS /eniq/sw File System size.  " ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}


### Function: check_absolute_path ###
#
# Determine absolute path to software
#
# Arguments:
#   none
# Return Values:
#   none
check_absolute_path()
{
_dir_=`$DIRNAME $0`
SCRIPTHOME=`cd $_dir_ 2>/dev/null && pwd || $ECHO $_dir_`

if [ "${ACTION_TYPE}" == "rollback" -o "${ACTION_TYPE}" == "rollback_platform_only" ]; then
    if [[ ! "$SCRIPTHOME" =~ ^/var/tmp/upgrade.* ]]; then
        usage_msg
        $ECHO "Script should be placed and run from a directory under /var/tmp/upgrade/${UPG_SW_DIR}.\n"
        exit 1
    fi
fi
}

### Function: check_multiple_instances ###     
#
# Multiple instances of the same script should not run
#
# Arguments:
#   none
# Return Values:
#   none
check_multiple_instances()
{
if [ -s "${VAR_TMP_DIR}/pid_of_upgrade_process" ]; then 
    PREV_PID=`$CAT "${VAR_TMP_DIR}/pid_of_upgrade_process"`
    if [ ! -z "${PREV_PID}" ]; then
        $PS -eaf | $GREP -w "upgrade_eniq_sw.bsh" | $GREP -wv $GREP | $GREP "${PREV_PID}" >> /dev/null 2>&1
        if [ $? -eq 0 ]; then
            $ECHO "Exiting... Another instance of upgrade is already in progress."
            exit 0
        fi    
    fi    
fi

CURRENT_PID=`$ECHO $$`
$RM -rf "${VAR_TMP_DIR}/pid_of_upgrade_process"
$ECHO "${CURRENT_PID}" >> "${VAR_TMP_DIR}/pid_of_upgrade_process"
}

### Function: check_params ###
#
# Check Input Params
#
# Arguments:
#    none
# Return Values:
#    none
check_params()
{
# Check that we got the required action type
if [ -z "${ACTION_TYPE}" ]; then
    usage_msg
    $ECHO "\nERROR: Action type is not provided."
    exit 1
fi

if [ "${ACTION_TYPE}" != "upgrade" -a "${ACTION_TYPE}" != "post_upgrade_feature_only" -a "${ACTION_TYPE}" != "post_upgrade" -a "${ACTION_TYPE}" != "post_upgrade_platform_only" -a "${ACTION_TYPE}" != "rollback" -a "${ACTION_TYPE}" != "rollback_feature_only" -a "${ACTION_TYPE}" != "rollback_platform_only" -a "${ACTION_TYPE}" != "upgrade_feature_only" ]; then
    if [ "${CURR_SERVER_TYPE}" == "eniq_stats" -o "${CURR_SERVER_TYPE}" == "stats_coordinator" ] ; then
        if [ "${ACTION_TYPE}" != "upgrade_platform_only" ]; then
            usage_msg
            $ECHO "\nERROR: Not a valid action type"
            exit 1
        fi
    else
        usage_msg
        $ECHO "\nERROR: Not a valid action type"
        exit 1
    fi
fi

# Check if -u option has been passed for required action types only.
if [ "${ACTION_TYPE}" != "upgrade_feature_only" -a "${ACTION_TYPE}" != "post_upgrade_feature_only" -a "${ACTION_TYPE}" != "rollback_feature_only" ]; then
    if [ "${ADMIN_UI}" == YES ]; then
        $ECHO "\nERROR: Please run the script without -u parameter\n"
        exit 1
    fi
fi


# Check if required paths are passed or not for different action types
if [ "${ACTION_TYPE}" == "upgrade" ]; then
    if [ ! "${BASE_SW_DIR}" -o ! "${OM_SW_DIR}" -o ! "${UPG_SW_DIR}" ]; then
            usage_msg
            $ECHO "\nERROR: Parameters required for upgrade are not provided.\n"
            exit 1
    else
        if [ "${CURR_SERVER_TYPE}" == "eniq_stats" -o "${CURR_SERVER_TYPE}" == "stats_coordinator" ]; then
            if [ ! "${FEATURE_SW_DIR}" ]; then
                usage_msg
                $ECHO "\nERROR: Parameters required for upgrade are not provided.\n"
                exit 1
            fi
        fi
    fi
elif [ "${ACTION_TYPE}" == "post_upgrade" -o "${ACTION_TYPE}" == "post_upgrade_platform_only" ]; then
    if [ ! "${BASE_SW_DIR}" ]; then            
            usage_msg
            $ECHO "\nERROR:  Path to eniq_sw_dir is not provided.\n"
            exit 1
        fi
elif [ "${ACTION_TYPE}" == "rollback" -o "${ACTION_TYPE}" == "rollback_platform_only" ]; then
        if [ ! "${UPG_SW_DIR}" ]; then
            usage_msg
            $ECHO "\nERROR: Parameters required for rollback are not provided.\n"
            exit 1
        fi
elif [ "${ACTION_TYPE}" == "upgrade_platform_only" ]; then
        if [ ! "${BASE_SW_DIR}" -o ! "${OM_SW_DIR}" -o ! "${UPG_SW_DIR}" ]; then
            usage_msg
            $ECHO "\nERROR: Parameters required for platform only upgrade are not provided.\n" 
            exit 1
        fi
elif [ "${ACTION_TYPE}" == "upgrade_feature_only" ]; then
        if [ ! "${FEATURE_SW_DIR}" ]; then
            usage_msg
            $ECHO "\nERROR: Parameters required for feature only upgrade are not provided.\n"
            exit 1
        fi
fi

# Check that <upg_sw_dir> exists under /var/tmp/upgrade
if [ "${ACTION_TYPE}" != "post_upgrade" -a "${ACTION_TYPE}" != "post_upgrade_feature_only" -a "${ACTION_TYPE}" != "post_upgrade_platform_only" -a "${ACTION_TYPE}" != "rollback_feature_only" -a "${ACTION_TYPE}" != "upgrade_feature_only" ]; then
    if [ ! -d "${UPG_VAR_TMP_DIR}/${UPG_SW_DIR}" ]; then
        $ECHO "\n ERROR: ${UPG_VAR_TMP_DIR}/${UPG_SW_DIR} does not exists \n"    
        exit 1
    fi
fi
}

### Function: check_server ###
#
# Check if the script is run on the coordinator
#
# Arguments:
#       none
# Return Values:
#       none
check_server()
{
# Directory on the root file system
ENIQ_BASE_DIR=/eniq
    
# Main Directory for the Core Installation SW
ENIQ_INST_DIR=${ENIQ_BASE_DIR}/installation

# Directory for the Core Installation SW
ENIQ_CORE_INST_DIR=${ENIQ_INST_DIR}/core_install 

# Templates Directory
ENIQ_TEMPL_DIR="${ENIQ_CORE_INST_DIR}/templates/stats" 

# ENIQ Config Directory
ENIQ_CONF_DIR=${ENIQ_INST_DIR}/config

# Set temporary upgrade directory
VAR_TMP_DIR=/var/tmp
UPG_VAR_TMP_DIR=${VAR_TMP_DIR}/upgrade

CURR_SERVER_TYPE=`$CAT $ENIQ_CONF_DIR/installed_server_type | $EGREP -v '^[[:blank:]]*#' | $SED -e 's/ //g'`
if [ ! "${CURR_SERVER_TYPE}" ]; then
    _err_msg_="Could not determine which server type this is"
    abort_script "$_err_msg_"
fi

if [ "${CURR_SERVER_TYPE}" == "stats_coordinator" \
     -o "${CURR_SERVER_TYPE}" == "eniq_stats" ]; then
    SERVER_TYPE="CO"
fi

if [ "$SERVER_TYPE" != "CO" ]; then
    _err_msg_="You must be on coordinator to execute this script."
    abort_script "$_err_msg_"
fi
}

### Function: check_upgrade_required ###
#
#   If ENIQ_Installation package version of upgrade release is greater than that of current release, core sw upgrade is performed.
#   If ENIQ_Installation package version of current release is greater than that of upgrade release, this stage is skipped.
#
#
# Arguments:
#   none
# Return Values:
#   none
check_upgrade_required()
{
log_msg -t -h -s "Checking if upgrade is required" -l ${LOGFILE}

_current_version_=`$CAT ${ENIQ_CORE_VER_DIR}/pkginfo | $GREP -w "VERSION" | $AWK -F\= '{print $2}'`
_upgrade_version_=`$CAT ${UPG_VAR_TMP_DIR}/${UPG_SW_DIR}/core_install/version/pkginfo | $GREP -w "VERSION" | $AWK -F\= '{print $2}'`

if [ -z "${_current_version_}" -o -z "${_upgrade_version_}" ]; then
    _err_msg_="Could not determine the R-state of ENIQ_Installation package of current or upgrade release"
    abort_script "$_err_msg_"
else
    log_msg -s "ENIQ_Installation package version of current release: ${_current_version_}" -l ${LOGFILE}
    log_msg -s "ENIQ_Installation package version of upgrade release: ${_upgrade_version_}" -l ${LOGFILE}
fi

_cur_ver_1_=`$ECHO ${_current_version_} | $AWK -F "[A-Z]" '{print $2}'`
_cur_ver_2_=`$ECHO ${_current_version_} | $AWK -F "[0-9]" '{print $2,$3}' | $SED 's/^ //g'`
_cur_ver_3_=`$ECHO ${_current_version_} | $AWK -F "[A-Z]" '{print $3}' | $AWK -F "_" '{print $1}'`
_cur_ver_4_=`$ECHO ${_current_version_} | $AWK -F "_EC" '{print $2}'`

_upg_ver_1_=`$ECHO ${_upgrade_version_} | $AWK -F "[A-Z]" '{print $2}'`
_upg_ver_2_=`$ECHO ${_upgrade_version_} | $AWK -F "[0-9]" '{print $2,$3}' | $SED 's/^ //g'`
_upg_ver_3_=`$ECHO ${_upgrade_version_} | $AWK -F "[A-Z]" '{print $3}' | $AWK -F "_" '{print $1}'`
_upg_ver_4_=`$ECHO ${_upgrade_version_} | $AWK -F "_EC" '{print $2}'`

_upgrade_required_=0
if [ "${_upg_ver_1_}" -gt "${_cur_ver_1_}" ]; then
    _upgrade_required_=1
elif [ "${_upg_ver_1_}" -eq "${_cur_ver_1_}" ]; then
    if [ "${_upg_ver_2_}" \> "${_cur_ver_2_}" ]; then
        _upgrade_required_=1
    elif [ "${_upg_ver_2_}" == "${_cur_ver_2_}" ]; then
        if [ "${_upg_ver_3_}" -gt "${_cur_ver_3_}" ]; then
            _upgrade_required_=1
        elif [ "${_upg_ver_3_}" -eq "${_cur_ver_3_}" ]; then
            if [ "${_upg_ver_4_}" ]; then
                if [ ! "${_cur_ver_4_}" ]; then
                    _upgrade_required_=1
                elif [ "${_upg_ver_4_}" -gt "${_cur_ver_4_}" ]; then
                    _upgrade_required_=1
                fi
            fi
        fi
    fi
fi
}

### Function: check_user_id ###
#
#   Check that the effective id of the user is correct
#   If not print error msg and exit.
#
# Arguments:
#       $1 : User ID name
# Return Values:
#       none
check_user_id()
{

_get_id_=`$ENV |$GREP -w SUDO_USER | $EGREP "^[[:blank:]]*SUDO_USER="|$AWK -F\= '{print $2}'|$SED -e 's|"||g'`

_check_id_=`$ID | $AWK -F\( '{print $2}' | $AWK -F\) '{print $1}'`

_check_group_=`$ID $_get_id_ | $AWK -F\( '{print $3}' | $AWK -F\) '{print $1}'`


    if [ "${_get_id_}" == "" ]; then

        if [ "${_check_id_}" == "root" ]; then
           # Set 1 for true
           _user_root=1

        else
           _err_msg_="You must be root or admin to execute this script."
           abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
        fi
          else
            if [ "${_check_group_}" == "ENIQ_ADMIN_ROLE" ]; then
               # Set 0 for false
               _user_root=0

            else
               _err_msg_="You must be root or admin to execute this script." 
               abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
            fi
    fi
}

### Function: copy_shadow_file ###
#
# To copy the shadow file 
#
# Arguments:
#       none
# Return Values:
#       none
copy_shadow_file()
{
# Get an ordered list of servers based on the server_list file:
_deployed_servers_="${TEM_DIR}/deployed_servers.$$.tmp"
$PERL ${GET_IP_ORDER_SCRIPT} -f ${_deployed_servers_}

for _line_ in `$CAT ${_deployed_servers_}`; do
    unset _ip_address_ _serv_hostname_ _serv_type_ _count_
	local _ip_address_ _serv_hostname_ _serv_type_ _count_
	_count_=`$ECHO "${_line_}" | grep -o "::" | wc -l`

	if [ "${_ip_type_}" == "IPv6" ] && [ "${_count_}" == 3 ]; then
		_ip_address_=`$ECHO ${_line_} | grep -oE '([a-fA-F0-9]{1,4}::?){1,7}[a-fA-F0-9]{1,4}' | head -n 1 | awk -F "::" '{ print $1 "::" $2}'`
		_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
		_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $4}'`
	else
		_ip_address_=`$ECHO ${_line_} | $AWK -F"::" '{print $1}'`
		_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $2}'`
		_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
	fi
    if [ ! "${_ip_address_}" -o ! "${_serv_hostname_}" -o ! "${_serv_type_}" ]; then
        _err_msg_="Unable to retrieve IP or hostname or server type.\n"
        abort_script "${_err_msg_}"
    fi

    # If the IP found in the order file matches my IP, run locally
    if [ "${_ip_address_}" == "${HOST_IP}" ]; then
        $CP -p /etc/shadow /etc/shadow_bkup  
        _copy_check_=$?
        if [ "${_copy_check_}" -ne 0 ]; then
            _err_msg_="Could not copy /etc/shadow to ${CLI_CONF_DIR}/shadow_bkup in ${_ip_address_}"
            abort_script "${_err_msg_}"
        fi
    else
        if [ "${_user_root}" == 1 ]; then			
			run_remote_cmd "${_serv_hostname_}" "$CP -p /etc/shadow /etc/shadow_bkup"
			_copy_file_check=$?
			if [ "${_copy_file_check}" -ne 0 ]; then
				_err_msg_="Failed to copy the shadow file"
				abort_script "${_err_msg_}"
			fi
		else
			run_remote_cmd "${_serv_hostname_}" "$SUDO $CP -p /etc/shadow /etc/shadow_bkup" "" "$_get_id_"
			_copy_file_check=$?
			if [ "${_copy_file_check}" -ne 0 ]; then
				_err_msg_="Failed to copy the shadow file"
				abort_script "${_err_msg_}"
			fi
		fi 
    fi
done
}
### Function: check_default_dcuser_password ###
#
# To check if default dcuser password is stored in repdb.
# Ask user input to change default dcuser password.
#
# Arguments:
#    none
# Return Values:
#     none
check_default_dcuser_password()
{
# Check if dbisql utility is present or not
DBISQL="$(ls /eniq/sybase_iq/IQ-*/bin64/dbisql)"
if [ ! -x "$DBISQL" ]; then
    _err_msg_="$DBISQL commands not found or not executable."
    abort_script "${_err_msg_}"
fi

# Get DBA Password
DBA_PASSWORD=`inigetpassword DB -f ${CLI_CONF_DIR}/${ENIQ_INI} -v DBAPassword`
if [ ! ${DBA_PASSWORD} ]; then
    if [ -f ${ENIQ_BASE_DIR}/sw/installer/dbusers ]; then
        DBA_PASSWORD=`${ENIQ_BASE_DIR}/sw/installer/dbusers dba dwh`
        if [ ! "${DBA_PASSWORD}" ] ; then
            _err_msg_="Could not get DBA Password"
            abort_script "${_err_msg_}"
        fi
    fi
fi

passphrase=`$CAT /eniq/sw/conf/strong_passphrase`

if [ -f  /eniq/sw/conf/dcuser_password_file ]; then
    _old_dcuser_pwd_1=`$CAT /eniq/sw/conf/dcuser_password_file`
    dcuser_encryption_flag=`iniget SunOS_USER_1 -v dcuser_encryption_flag -f /eniq/installation/config/SunOS.ini`
    _user_passwd_=`iniget SunOS_USER_1 -f /eniq/installation/config/SunOS.ini -v password`
	
    if [ "${dcuser_encryption_flag}" = "yy" ]; then
        _old_dcuser_pwd_=`$ECHO ${_old_dcuser_pwd_1} | openssl enc -aes-256-ctr -md sha512 -a -d -salt -pass pass:${passphrase}`
        default_dcuser_password=`$ECHO ${_user_passwd_} | openssl enc -aes-256-ctr -md sha512 -a -d -salt -pass pass:${passphrase}`
    else
        _old_dcuser_pwd_=`$ECHO ${_old_dcuser_pwd_1} | openssl enc -base64 -d`
        default_dcuser_password=`$ECHO ${_user_passwd_} | openssl enc -base64 -d`
    fi
else
    # Get RepDB Port and ServerName Password
    REP_PORT=`iniget REP -v PortNumber -f ${CLI_CONF_DIR}/niq.ini`
    REP_ENG=`iniget REP -v ServerName -f ${CLI_CONF_DIR}/niq.ini`
    if [ ! "${REP_PORT}" -o ! "${REP_ENG}" ]; then
        _err_msg_="Could not read db values from ${CLI_CONF_DIR}/${ENIQ_INI}"
        abort_script "$_err_msg_"
    fi
    
    #Initialising the connection string for dwhdb
    rep_connection_string="-c \"eng=${REP_ENG};links=tcpip{host=localhost;port=${REP_PORT}};uid=dba;pwd=${DBA_PASSWORD}\""
    rep_connection_string_enc=${VAR_TMP_DIR}/con_str_encrypt.txt.$$
    
    # encrypt the connection string.
    get_encrypt_file "${rep_connection_string}" "${rep_connection_string_enc}"
    
    
    # Fetching old password for dcuser from RepDB
    log_msg -s "\nFetching password information for dcuser from database...\n" -l "${LOGFILE}"
    _timeout_=0
    while true; do
        $SU - ${_sysuser_} -c "$DBISQL -nogui -onerror exit @${rep_connection_string_enc} \"select PASSWORD from etlrep.meta_databases where USERNAME='dcuser';OUTPUT TO /tmp/dcuser_pwd.txt\"" 1>/dev/null
        if [ $? -ne 0 ];then
            log_msg -s "Wating for command to get successfully executed" -l ${LOGFILE}
            $SLEEP 5
            (( _timeout_ = _timeout_ + 5 ))
            if [ ${_timeout_} -eq 120 ]; then
                _err_msg_="Failed to execute the command"
                abort_script "${_err_msg_}"
                break
            else
                continue
            fi
        else
            break
        fi
    done
    
	$SED -i "s/[\']//g" /tmp/dcuser_pwd.txt
    _old_dcuser_pwd_1=`$CAT /tmp/dcuser_pwd.txt | $UNIQ | $AWK -F "'" '{print $2}'`
	
    if [ $? -ne 0 ]; then
         _err_msg_="Could not fetch password for dcuser."
         abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
    fi
    
    #_old_dcuser_pwd_=`$ECHO ${_old_dcuser_pwd_1} | openssl enc -base64 -d`
    
    _SUNOS_INI_=SunOS.ini_${STORAGE_TYPE}
    path_dir=/eniq/installation/core_install/templates/stats/
	
    #checking for encryption flag
    dcuser_encryption_flag=`iniget SunOS_USER_1 -v dcuser_encryption_flag -f ${path_dir}/${_SUNOS_INI_}`
    if [ "${dcuser_encryption_flag}" = "yy" ]; then
        _old_dcuser_pwd_=`$ECHO ${_old_dcuser_pwd_1} | openssl enc -aes-256-ctr -md sha512 -a -d -salt -pass pass:${passphrase}`
    else
        _old_dcuser_pwd_=`$ECHO ${_old_dcuser_pwd_1} | openssl enc -base64 -d`
    fi	
	
    _user_list_=`iniget SunOS_USER -f ${path_dir}/${_SUNOS_INI_}`
    if [ $? -ne 0 ]; then
         _err_msg_="Could not fetch ${_user_list_} for dcuser."
         abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
    fi
    for _user_ in ${_user_list_}; do
        _user_name_=`iniget ${_user_} -f ${path_dir}/${_SUNOS_INI_} -v name`
    	
        if [ ${_user_name_} == dcuser ]; then
            _user_passwd_=`iniget ${_user_} -f ${path_dir}/${_SUNOS_INI_} -v password`
            if [ -z ${_user_passwd_} ]; then
                 _err_msg_="Could not fetch password for dcuser."
                 abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
            fi
            if [ "${dcuser_encryption_flag}" = "yy" ]; then
    		    default_dcuser_password=`$ECHO ${_user_passwd_} | openssl enc -aes-256-ctr -md sha512 -a -d -salt -pass pass:${passphrase}`
    		else
                default_dcuser_password=`$ECHO ${_user_passwd_} | openssl enc -base64 -d`
    		fi
        fi
    done
fi

if [ ${_old_dcuser_pwd_} == ${default_dcuser_password} ]; then
    copy_shadow_file
    # Creating flg file
    $TOUCH /tmp/os_post_upgrade
    # Ask for dcuser password.
    common_get_dcuser_password ${_sysuser_}

    _DC_PWD_=`$ECHO ${DCPASSWORD}`
    _DC_PWD_1=`$ECHO ${_DC_PWD_}`

    # Creating flg file
    $TOUCH /tmp/password_change_required
    file_dcpass=/tmp/password_change_required
    $RM -rf /tmp/dcuser_pwd.txt

    $RM -rf ${CLI_CONF_DIR}/dcuser_password_change
    $ECHO "OLD_DCUSER_PASSWORD : ${_old_dcuser_pwd_1}" > ${CLI_CONF_DIR}/dcuser_password_change
    $ECHO "NEW_DCUSER_PASSWORD : ${_DC_PWD_1}" >> ${CLI_CONF_DIR}/dcuser_password_change

    $ECHO "${_DC_PWD_1}" > ${CLI_CONF_DIR}/dcuser_password_file
else
    $ECHO "${_old_dcuser_pwd_1}" > ${CLI_CONF_DIR}/dcuser_password_file
    $ECHO "dcuser password is already changed."
fi

if [ -f /tmp/os_post_upgrade ]; then

    $RM -rf /tmp/os_post_upgrade

fi
}

### Function: check_default_repdb_password ###
#
# To check repdb users password stored in repdb.
# Ask user input to change repdb users password.
#
# Arguments:
#    none
# Return Values:
#     none
check_default_repdb_password()
{
    # Checking passwords of RepDB users already updated or not.
    RepDB_password=`$CAT ${CLI_CONF_DIR}/${ENIQ_INI} | $GREP -iw "RepDB_users_password_change_indicator"` >> /dev/null 2>&1
    if [ ${RepDB_password} ]; then
        log_msg -s "RepDB users passwords are already changed." 
    else
        # Creating flg file
        $TOUCH /tmp/repdb_user_password_change_required
        file_repdbpass=/tmp/repdb_user_password_change_required
        $RM -rf ${CLI_CONF_DIR}/.repdb_user_password_change
        user="ETLREP DWHREP"
        for _user_ in ${user}; do
            case "${_user_}" in
                ETLREP)
                    block_ini="REP"
                    property="ETLREPPassword"
                    ;;
                DWHREP)
                    block_ini="REP"
                    property="DWHREPPassword"
                    ;;
                *)
                    _err_msg_="$($DATE '+%Y-%b-%d_%H.%M.%S'): USER - ${user} not found."
                    abort_script "$_err_msg_"
            esac
        
            common_get_repdb_user_password "${_user_}"

            if [ "${DBPASSWORD}" ]; then
                #get the username for the user
                _for_user_=`iniget REP -f ${ENIQ_CONF_DIR}/${ENIQ_INI} -v ${_user_}Username`
                if [ -z "${_for_user_}" ]; then
                    _err_msg_="Could not read ${_user_} username from ${ENIQ_CONF_DIR}/${ENIQ_INI}"
                    abort_script "${_err_msg_}"
                fi
                #get the old password for the user
                _present_pass_=`iniget REP -f ${ENIQ_CONF_DIR}/${ENIQ_INI} -v ${_user_}Password`
                if [ -z "${_present_pass_}" ]; then
                    _err_msg_="Could not read ${_user_} password from ${ENIQ_CONF_DIR}/${ENIQ_INI}"
                    abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
                fi
                #Check if the current password is encrypted or not
                _pass_encrypt_=`iniget DB -f ${ENIQ_CONF_DIR}/${ENIQ_INI} -v ${_user_}Password_Encrypted`
                if [ -z "${_pass_encrypt_}" ]; then
                    _err_msg_="Could not read ${_user_} password encryption status from ${ENIQ_CONF_DIR}/${ENIQ_INI}"
                    abort_script "${_err_msg_}"
                fi
                if [ ${_pass_encrypt_} == N ];then
                _present_pass_=`$ECHO "${_present_pass_}" | openssl enc -base64`
                fi
                _new_pass_=${DBPASSWORD}
                _new_pass_1_=`$ECHO ${_new_pass_}`
                
                $ECHO "OLD_${_user_}_PASSWORD :${_present_pass_}" >> ${CLI_CONF_DIR}/.repdb_user_password_change
                $ECHO "NEW_${_user_}_PASSWORD :${_new_pass_1_}" >> ${CLI_CONF_DIR}/.repdb_user_password_change
            fi
        done
    fi
}


### Function: change_repdb_password ###
#
# To change repdb users password stored in repdb.
# Ask user input to change repdb users password.
#
# Arguments:
#    none
# Return Values:
#     none
change_repdb_password()
{
# Define variables
local ENIQ_BASE_DIR=/eniq
local ENIQ_CONF_DIR=${ENIQ_BASE_DIR}/installation/config
local CLI_CONF_DIR=${ENIQ_BASE_DIR}/sw/conf
local ENIQ_SW_PF_DIR=${ENIQ_BASE_DIR}/sw/platform
local ENIQ_CLI_SW_DIR=${ENIQ_BASE_DIR}/sw
local _sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/SunOS.ini -v ENIQ_SYSUSER`

$SU - ${_sysuser_} -c "$CP ${CLI_CONF_DIR}/ETLCServer.properties ${CLI_CONF_DIR}/ETLCServer.properties_bkp"

DBISQL="$(ls /eniq/sybase_iq/IQ-*/bin64/dbisql)"
if [ ! -x "$DBISQL" ]; then
    _err_msg_="$DBISQL commands not found or not executable."
    abort_script "${_err_msg_}"
fi

DWH_PORT=`iniget DWH -f ${ENIQ_CONF_DIR}/${ENIQ_INI} -v PortNumber`
if [ -z "${DWH_PORT}" ]; then
    _err_msg_="Could not read ${DWH_PORT} from ${ENIQ_CONF_DIR}/${ENIQ_INI}"
    abort_script "${_err_msg_}"
fi

DBA_password=`iniget DB -f ${ENIQ_CONF_DIR}/${ENIQ_INI} -v DBAPassword`
if [ -z "${DBA_password}" ]; then
    _err_msg_="Could not read ${DBA_password} from ${ENIQ_CONF_DIR}/${ENIQ_INI}"
    abort_script "${_err_msg_}"
fi
DBAPassword_Encrypted=`iniget DB -f ${ENIQ_CONF_DIR}/${ENIQ_INI} -v DBAPassword_Encrypted`
if [ -z "${DBAPassword_Encrypted}" ]; then
    _err_msg_="Could not read ${DBAPassword_Encrypted} from ${ENIQ_CONF_DIR}/${ENIQ_INI}"
    abort_script "${_err_msg_}"
fi
if [ "${DBAPassword_Encrypted}" == "Y" ]; then
    DBA_password=`$ECHO ${DBA_password} | openssl enc -base64 -d`
fi
#Initialising the connection string for dwhdb
DWH_CONN_STR_FOR_REPDB_USER_DBA="-c \"eng=repdb;links=tcpip{host=dwhdb;port=${DWH_PORT}};uid=dba;pwd=${DBA_password}\""
DWH_CONN_STR_FOR_REPDB_USER_DBA_ENC=${VAR_TMP_DIR}/con_str_repdb_encrypt.txt.$$

# encrypt the connection string.
get_encrypt_file "${DWH_CONN_STR_FOR_REPDB_USER_DBA}" "${DWH_CONN_STR_FOR_REPDB_USER_DBA_ENC}"

user="DWHREP ETLREP"
for _user_ in ${user}; do

    # Get old and new password for dcuser
    _old_rep_pwd_=`$CAT ${CLI_CONF_DIR}/.repdb_user_password_change | $GREP -w "OLD_${_user_}_PASSWORD" | $AWK -F ":" '{print $2}'`
    _new_rep_pwd_=`$CAT ${CLI_CONF_DIR}/.repdb_user_password_change | $GREP -w "NEW_${_user_}_PASSWORD" | $AWK -F ":" '{print $2}'`

    # Decrypt old and new password for dcuser
    _old_repdb_pwd_=`$ECHO ${_old_rep_pwd_} | openssl enc -base64 -d`
    _repdb_PWD_=`$ECHO ${_new_rep_pwd_} | openssl enc -base64 -d`

    _for_user_=`iniget REP -f ${ENIQ_CONF_DIR}/${ENIQ_INI} -v ${_user_}Username`
    if [ -z "${_for_user_}" ]; then
        _err_msg_="Could not read ${_user_} username from ${ENIQ_CONF_DIR}/${ENIQ_INI}"
        abort_script "${_err_msg_}"
    fi

    # Update the password in niq.ini file 
    BLOCKS_TO_BE_PROCESSED_ARRAY="REP"
    log_msg -s -q "setting the new password of ${_user_} in config files." -l ${LOGFILE}
    iniset ${BLOCKS_TO_BE_PROCESSED_ARRAY} -f ${TEM_DIR}/${ENIQ_INI} ${_user_}Password=${_new_rep_pwd_}
    if [ $? -ne 0 ]; then
        _err_msg_="Could not update ${TEM_DIR}/${ENIQ_INI} with ${_user_}Password"
        abort_script "$_err_msg_"
    fi
    iniset DB -f ${TEM_DIR}/${ENIQ_INI} ${_user_}Password_Encrypted=Y
    if [ $? -ne 0 ]; then
        _err_msg_="Could not update ${TEM_DIR}/${ENIQ_INI} with ${_user_}Password_Encrypted"
        abort_script "$_err_msg_"
    fi

    # Update the in RepDB meta database and alter password for the specific user 
    if [ "${CURR_SERVER_TYPE}" == "eniq_stats" -o "${CURR_SERVER_TYPE}" == "stats_coordinator" ] ; then
        # For updating password in the meta.database
        # Get R_State of repository package
        R_STATE=`cat ${ENIQ_SW_PF_DIR}/../installer/versiondb.properties | $GREP -w repository | $AWK -F "=" '{print $2}'`
        # Get system user (dcuser)

       $CHMOD +x ${ENIQ_SW_PF_DIR}/repository-${R_STATE}/bin/ChangeUserPasswordsInRepdb
       if [ $? -ne 0 ]; then
           _err_msg_="Could not change permission for ${ENIQ_SW_PF_DIR}/repository-${R_STATE}/bin/ChangeUserPasswordsInRepdb."
           abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
       fi

        log_msg -s "Executing $SU - ${_sysuser_} -c $BASH ${ENIQ_SW_PF_DIR}/repository-${R_STATE}/bin/ChangeUserPasswordsInRepdb to update the ${_user_} user password in Repdb meta database\n" -l ${LOGFILE}

        $SU - ${_sysuser_} -c "$BASH ${ENIQ_SW_PF_DIR}/repository-${R_STATE}/bin/ChangeUserPasswordsInRepdb -u ${_for_user_} -o ${_old_repdb_pwd_} -p ${_repdb_PWD_} -r ${_repdb_PWD_}"
        if [ $? -ne 0 ]; then
            _err_msg_="Failed to set password of ${_for_user_} in REPDB meta.database"
            abort_script "$_err_msg_"
        fi

        # For updating password to able to login
        log_msg -s "Executing IQ DBISQL command to update the ${_user_} user password in Repdb\n" -l ${LOGFILE}
        $SU - ${_sysuser_} -c "$DBISQL -nogui -onerror exit @${DWH_CONN_STR_FOR_REPDB_USER_DBA_ENC} \"ALTER USER ${_for_user_} IDENTIFIED BY '${_repdb_PWD_}';\"" 2>>${LOGFILE} 1>/dev/null
        if [ $? -ne 0 ]; then
            log_msg -s "Failed to alter the password of ${_for_user_} in REPDB" -l ${LOGFILE}
            log_msg -s "Reverting the password in REPDB" -l ${LOGFILE}
            rollback_repdb_password "${_for_user_}"
            if [ "${_for_user_}" == "dwhrep" ];then
                log_msg -s "Updating new password failed for ${_for_user_}, hence old password is reverted for ${_for_user_} in REPDB" -l ${LOGFILE}
            elif [ "${_for_user_}" == etlrep ];then
                log_msg -s "Updating new password failed for ${_for_user_}, hence old password is reverted for dwhrep and ${_for_user_} in REPDB." -l ${LOGFILE}
            fi
            log_msg -s "Re-execute the same procedure to update the password of DWHREP and ETLREP." -l ${LOGFILE}
            return 1
        fi
    fi
done

#Update flag for etlrep and dwhrep users password change in config file.
$ECHO -e "\n[RepDB_users_password_change_indicator]" >> ${TEM_DIR}/${ENIQ_INI}
$ECHO "RepDB_users_password_change=Y" >> ${TEM_DIR}/${ENIQ_INI}    

 $CP ${TEM_DIR}/${ENIQ_INI} ${CLI_CONF_DIR}/${ENIQ_INI}
 if [ $? -ne 0 ]; then
     _err_msg_="Could not copy ${TEM_DIR}/${ENIQ_INI} to ${CLI_CONF_DIR}/${ENIQ_INI}"
     abort_script "$_err_msg_"
 fi

_new_etlrep_pwd_=`iniget REP -f ${CLI_CONF_DIR}/${ENIQ_INI} -v ETLREPPassword`
_new_dwhrep_pwd_=`iniget REP -f ${CLI_CONF_DIR}/${ENIQ_INI} -v DWHREPPassword`

for _line_ in `$CAT ${_deployed_servers_}`; do
    unset _ip_address_ _serv_hostname_ _serv_type_ _count_
	local _ip_address_ _serv_hostname_ _serv_type_ _count_
	_count_=`$ECHO "${_line_}" | grep -o "::" | wc -l`

	if [ "${_ip_type_}" == "IPv6" ] && [ "${_count_}" == 3 ]; then
		_ip_address_=`$ECHO ${_line_} | grep -oE '([a-fA-F0-9]{1,4}::?){1,7}[a-fA-F0-9]{1,4}' | head -n 1 | awk -F "::" '{ print $1 "::" $2}'`
		_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
		_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $4}'`
	else
		_ip_address_=`$ECHO ${_line_} | $AWK -F"::" '{print $1}'`
		_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $2}'`
		_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
	fi
    if [ ! "${_ip_address_}" -o ! "${_serv_hostname_}" -o ! "${_serv_type_}" ]; then
        _err_msg_="Unable to retrieve IP or hostname or server type.\n"
        abort_script "${_err_msg_}"
    fi

    # If the IP found in the order file matches my IP, run locally
    if [ "${_ip_address_}" == "${HOST_IP}" ]; then
        $CP ${TEM_DIR}/${ENIQ_INI} ${ENIQ_CONF_DIR}/${ENIQ_INI}
        if [ $? -ne 0 ]; then
            _err_msg_="Could not copy ${Tem_DIR}/${ENIQ_INI} to ${ENIQ_CONF_DIR}/${ENIQ_INI} in ${_ip_address_}"
            abort_script "$_err_msg_"
        fi
    else
        run_remote_cmd "${_serv_hostname_}" ". ${ENIQ_CORE_INST_DIR}/lib/common_functions.lib;iniset REP -f ${ENIQ_CONF_DIR}/${ENIQ_INI} ETLREPPassword=${_new_etlrep_pwd_}" >> /dev/null 2>&1
        if [ $? -ne 0 ]; then
            _err_msg_="Could not set to ETLREPPassword ${ENIQ_CONF_DIR}/${ENIQ_INI} in ${_ip_address_}"
            abort_script "$_err_msg_"
        fi
        run_remote_cmd "${_serv_hostname_}" ". ${ENIQ_CORE_INST_DIR}/lib/common_functions.lib;iniset REP -f ${ENIQ_CONF_DIR}/${ENIQ_INI} DWHREPPassword=${_new_dwhrep_pwd_}" >> /dev/null 2>&1
        if [ $? -ne 0 ]; then
            _err_msg_="Could not set to DWHREPPassword to ${ENIQ_CONF_DIR}/${ENIQ_INI} in ${_ip_address_}"
            abort_script "$_err_msg_"
        fi
        run_remote_cmd "${_serv_hostname_}" ". ${ENIQ_CORE_INST_DIR}/lib/common_functions.lib;iniset DB -f ${ENIQ_CONF_DIR}/${ENIQ_INI} ETLREPPassword_Encrypted=Y" >> /dev/null 2>&1
        if [ $? -ne 0 ]; then
            _err_msg_="Could not cset ETLREPPassword_Encrypted to ${ENIQ_CONF_DIR}/${ENIQ_INI} in ${_ip_address_}"
            abort_script "$_err_msg_"
        fi
        run_remote_cmd "${_serv_hostname_}" ". ${ENIQ_CORE_INST_DIR}/lib/common_functions.lib;iniset DB -f ${ENIQ_CONF_DIR}/${ENIQ_INI} DWHREPPassword_Encrypted=Y" >> /dev/null 2>&1
        if [ $? -ne 0 ]; then
            _err_msg_="Could not set DWHREPPassword_Encrypted to ${ENIQ_CONF_DIR}/${ENIQ_INI} in ${_ip_address_}"
            abort_script "$_err_msg_"
        fi
        run_remote_cmd "${_serv_hostname_}" "$ECHO -e "[RepDB_users_password_change_indicator]" >> ${ENIQ_CONF_DIR}/${ENIQ_INI}" >> /dev/null 2>&1
        if [ $? -ne 0 ]; then
            _err_msg_="Could not set RepDB indicator to ${ENIQ_CONF_DIR}/${ENIQ_INI} in ${_ip_address_}"
            abort_script "$_err_msg_"
        fi
        run_remote_cmd "${_serv_hostname_}" "$ECHO "RepDB_users_password_change=Y" >> ${ENIQ_CONF_DIR}/${ENIQ_INI}" >> /dev/null 2>&1
        if [ $? -ne 0 ]; then
            _err_msg_="Could not set RepDB flag to ${ENIQ_CONF_DIR}/${ENIQ_INI} in ${_ip_address_}"
            abort_script "$_err_msg_"
        fi
    fi
done
log_msg -s "Successfully updated passwords for RepDB user in config files\n"
rm -rf ${CLI_CONF_DIR}/.repdb_user_password_change 
rm -rf ${CLI_CONF_DIR}/ETLCServer.properties_bkp
}



### Function: cleanup ###
#
# Final stage. Cleanup of temporary directory 
#
# Arguments:
#   none
# Return Values:
#   none
cleanup()
{
insert_header_footer head "Entering ${ACTION_TYPE} stage - ${NEXT_STAGE}" ${LOGFILE}

if [ "${ACTION_TYPE}" == "rollback" ]; then
    log_msg -s "Cleaning up the temporary files" -l ${LOGFILE}
    if [ ! -s "${_deployed_servers_}" ]; then
        _err_msg_="Unable to retrieve deployed servers list.\n"
        abort_script "${_err_msg_}"
    fi

    for _line_ in `$CAT ${_deployed_servers_}`; do
        unset _ip_address_ _serv_hostname_ _serv_type_ _count_
		local _ip_address_ _serv_hostname_ _serv_type_ _count_
		_count_=`$ECHO "${_line_}" | grep -o "::" | wc -l`

		if [ "${_ip_type_}" == "IPv6" ] && [ "${_count_}" == 3 ]; then
			_ip_address_=`$ECHO ${_line_} | grep -oE '([a-fA-F0-9]{1,4}::?){1,7}[a-fA-F0-9]{1,4}' | head -n 1 | awk -F "::" '{ print $1 "::" $2}'`
			_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
			_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $4}'`
		else
			_ip_address_=`$ECHO ${_line_} | $AWK -F"::" '{print $1}'`
			_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $2}'`
			_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
		fi
        if [ ! "${_ip_address_}" -o ! "${_serv_hostname_}" -o ! "${_serv_type_}" ]; then
            _err_msg_="Unable to retrieve IP or hostname or server type.\n"
            abort_script "${_err_msg_}"
        fi

        # If the IP found in the order file matches my IP, run locally
        if [ "${_ip_address_}" == "${HOST_IP}" ]; then
            $RM -rf ${FS_ROLLBACK_SUCCESS}
        else
           	if [ "${_user_root}" == 1 ]; then			
				run_remote_cmd "${_serv_hostname_}" "$RM -rf ${FS_ROLLBACK_SUCCESS}" >> /dev/null 2>&1
			else
				run_remote_cmd "${_serv_hostname_}" "$SUDO $RM -rf ${FS_ROLLBACK_SUCCESS}" "" "$_get_id_" >> /dev/null 2>&1
			fi 
		fi
    done
    _temp_files_="${ROLLBACK_SNAP_LABEL_CONF}
    ${NAS_ROLLBACK_SUCCESS}
    ${SAN_ROLLBACK_SUCCESS}
    ${SELECTED_SNAPSHOT}
    ${VAR_TMP_DIR}/rollback_conf
    ${CALLED_THROUGH_UPGRADE}
    ${ENIQ_ADMIN_BIN_DIR}/snap_label
    ${VAR_TMP_DIR}/feature_upgrade_flag
    ${ENIQ_CORE_ETC_DIR}/current_upgrade_stage
    ${ENIQ_CORE_ETC_DIR}/current_upgrade_platform_only_stage
    /tmp/dcuser_file_encrypted"

    for _file_ in ${_temp_files_}; do
        if [ -f "${_file_}" ]; then
            log_msg -t -q -s "Deleting ${_file_} file" -l ${LOGFILE}
            $RM -rf ${_file_}
        fi
    done

    if [ "${rollback_type_flag}" != 1 ]; then  
        $RM -rf "${STAGEFILE}"
    fi

    # Run the clean-up script of Admin-UI
    if [ "${rollback_type_flag}" -eq 1 ]; then
        cleanup_admin_ui -rollback
    fi

    log_msg -t -q -s "Successfully deleted temporary files" -l ${LOGFILE}
fi

if [ "${ACTION_TYPE}" == "post_upgrade" ]; then
    _temp_files_="${TEM_DIR}/feature_output_list2
    ${VAR_TMP_DIR}/rollback_conf_adminUI
    ${VAR_TMP_DIR}/rollback_conf
    ${VAR_TMP_DIR}/feature_upgrade_flag"
    
    for _file_ in ${_temp_files_}; do
        if [ -f "${_file_}" ]; then
            log_msg -t -q -s "Deleting ${_file_} file" -l ${LOGFILE}
            $RM -rf ${_file_}
        fi
    done

    if [ "${post_upgrade_type_flag}" -ne 1 ]; then
        $RM -rf "${STAGEFILE}"
    fi

    # Run the clean-up script of Admin-UI
    if [ "${post_upgrade_type_flag}" -eq 1 ]; then
        cleanup_admin_ui -commit
    fi

    log_msg -t -q -s "Successfully deleted temporary files" -l ${LOGFILE}
fi

_temp_files_="${ENIQ_CORE_ETC_DIR}/features_to_be_managed" 

for _file_ in ${_temp_files_}; do
    if [ -f "${_file_}" ]; then
        log_msg -t -q -s "Deleting ${_file_} file" -l ${LOGFILE}
        $RM -rf ${_file_}
    fi
done

$RM -rf "${ENIQ_CORE_ETC_DIR}/feature_output_list_"*

if [ -e /ericsson/storage/bin/storobs_removal.py ]; then
$ECHO "Removing storobs user from ${HOST_IP}" | $TEE -a ${LOGFILE}    
/ericsson/storage/bin/storobs_removal.py
if [ $? -eq 0 ]; then
    $ECHO "Successfully removed the storobs user from ${HOST_IP} server" | $TEE -a ${LOGFILE}
elif [ $? -eq 1 ]; then
	$ECHO "storobs user is already removed in ${HOST_IP} server" | $TEE -a ${LOGFILE}
else
	_err_msg_="Failed to remove storobs user in ${HOST_IP} server"
    abort_script "${_err_msg_}"
fi
fi

 # Incase of multi blade Copy the /eniq/installation/core_insatll/templates/stats/storage.ini.<deployment_type> file from co-ordinator to all the connected blades.
    if [ "${CURR_SERVER_TYPE}" == "stats_coordinator" ]; then
        $ECHO "Copying storage.ini from co-ordinator to all the connected blades" | $TEE -a ${LOGFILE}  
        $PERL ${GET_IP_ORDER} -f ${VAR_TMP_DIR}/server_order_list
        for _line_ in `$CAT ${VAR_TMP_DIR}/server_order_list`
        do
		    unset _server_ _serv_hostname_ _count_ 
			local _server_ _serv_hostname_ _count_ 
		    _count_=`$ECHO "${_line_}" | grep -o "::" | wc -l`

		    if [ "${_ip_type_}" == "IPv6" ] && [ "${_count_}" == 3 ]; then
			    _server_=`$ECHO ${_line_} | grep -oE '([a-fA-F0-9]{1,4}::?){1,7}[a-fA-F0-9]{1,4}' | head -n 1 | awk -F "::" '{ print $1 "::" $2}'`
	            _serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
		    else
			    _server_=`$ECHO ${_line_} | $AWK -F"::" '{print $1}'`
			    _serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $2}'`
		    fi
		    if [ "${_server_}" == "${HOST_IP}" ]; then
                continue
            fi
			if [ "${_ip_type_}" == "IPv6" ]; then
				$SCP -6 -rp -o StrictHostKeyChecking=no ${ENIQ_TEMPL_DIR}/${_storage_ini_templ} [${_server_}]:${ENIQ_TEMPL_DIR}/  >>/dev/null
			else
				$SCP -rp -o StrictHostKeyChecking=no ${ENIQ_TEMPL_DIR}/${_storage_ini_templ} ${_server_}:${ENIQ_TEMPL_DIR}/  >>/dev/null
			fi
            if [ $? -ne 0 ]; then
                _err_msg_="Failed to copy ${ENIQ_TEMPL_DIR}/${_storage_ini_templ} from ${HOST_IP} to ${_server_}"
                abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
            fi
		if [ -e /ericsson/storage/bin/storobs_removal.py ]; then
			$ECHO "Removing storobs user from ${_server_} server" | $TEE -a ${LOGFILE}    			
			run_remote_cmd "${_serv_hostname_}" "/ericsson/storage/bin/storobs_removal.py"
			if [ $? -eq 0 ]; then
				$ECHO "Successfully removed the storobs user from ${_server_} server" | $TEE -a ${LOGFILE}
			elif [ $? -eq 1 ]; then
				$ECHO "storobs user is already removed in ${_server_} server" | $TEE -a ${LOGFILE}
			else
				_err_msg_="Failed to remove storobs user in ${_server_} server"
				abort_script "${_err_msg_}"
			fi
		fi
			
        done
        $ECHO "Successfully copied the ${ENIQ_TEMPL_DIR}/${_storage_ini_templ} from co-ordinator to all the connected blades" | $TEE -a ${LOGFILE}
		
    fi



log_msg -s "Cleaning up the temporary directory" -l ${LOGFILE}
$RM -rf ${TEM_DIR}

#Removing directory demo from ${ENIQ_BASE_DIR}/sybase_iq/IQ-*/demo
if [ -f ${ENIQ_BASE_DIR}/sybase_iq/IQ-*/demo/mkasiqdemo.sql ]; then
    $ECHO " Removing directory demo from ${ENIQ_BASE_DIR}/sybase_iq/IQ-*/demo - For security vulnerability password issue ">> ${LOGFILE}
    $RM -rf ${ENIQ_BASE_DIR}/sybase_iq/IQ-*/demo
    if [ $? -ne 0 ]; then
        _err_msg_="Could not remove demo directory from - ${ENIQ_BASE_DIR}/sybase_iq/IQ-*/demo"
        abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
    fi
fi

#Removing sample IQ files runtests.py for Security Jira EQEV-119318  
if [ -f ${ENIQ_BASE_DIR}/sybase_iq/IQ-*/sdk/python/scripts/runtests.py ]; then
    $ECHO " Removing runtests.py sample IQ file for security vulnerability password issue ">> ${LOGFILE}
    $RM -f ${ENIQ_BASE_DIR}/sybase_iq/IQ-*/sdk/python/scripts/runtests.py
    if [ $? -ne 0 ]; then
        _err_msg_="Could not remove runtests.py file from ${ENIQ_BASE_DIR}/sybase_iq/IQ-*/sdk/python/scripts directory"
        abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
    fi
fi


#Removing sample IQ files test.py for Security Jira EQEV-119318
if [ -f ${ENIQ_BASE_DIR}/sybase_iq/IQ-*/sdk/python/scripts/test.py ]; then
    $ECHO " Removing test.py sample IQ file for security vulnerability password issue ">> ${LOGFILE}
    $RM -f ${ENIQ_BASE_DIR}/sybase_iq/IQ-*/sdk/python/scripts/test.py
    if [ $? -ne 0 ]; then
        _err_msg_="Could not remove test.py file from ${ENIQ_BASE_DIR}/sybase_iq/IQ-*/sdk/python/scripts directory"
        abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
    fi
fi

#Remove sample IQ file FixedSession.java for Security Jira EQEV-119318
if [ -f ${ENIQ_BASE_DIR}/sybase_iq/jConnect-*/gateway2/FixedSession.java ]; then
    $ECHO " Removing FixedSession.java sample IQ file for security vulnerability password issue ">> ${LOGFILE}	
    $RM -f ${ENIQ_BASE_DIR}/sybase_iq/jConnect-*/gateway2/FixedSession.java
     if [ $? -ne 0 ]; then
         _err_msg_="Could not remove FixedSession.java file from ${ENIQ_BASE_DIR}/sybase_iq/jConnect-*/gateway2 directory"
     fi
fi

#Remove sample IQ file IsqlApp.java for Security Jira EQEV-119318
if [ -f ${ENIQ_BASE_DIR}/sybase_iq/jConnect-*/sample2/IsqlApp.java ]; then
    $ECHO " Removing IsqlApp.java sample IQ file for security vulnerability password issue ">> ${LOGFILE}
    $RM -f ${ENIQ_BASE_DIR}/sybase_iq/jConnect-*/sample2/IsqlApp.java
     if [ $? -ne 0 ]; then
         _err_msg_="Could not remove IsqlApp.java file from ${ENIQ_BASE_DIR}/sybase_iq/jConnect-*/sample2 directory"
     fi
fi

#Copying fbx64.efi file for Gen 10+ servers
if [ "${ACTION_TYPE}" == "post_upgrade" ]; then
	_boot_efi_="/boot/efi/EFI/BOOT/"
	if [ -d ${_boot_efi_} ]; then
		_fbx64_loc_="${OM_SW_DIR}/om_linux/omtools/bmr/fbx64.efi"
		if [ -f ${_fbx64_loc_} ]; then
			if [ "${CURR_SERVER_TYPE}" == "stats_coordinator" ]; then
				$PERL ${GET_IP_ORDER} -f ${VAR_TMP_DIR}/server_order_list
				for _line_ in `$CAT ${VAR_TMP_DIR}/server_order_list`
				do
				    unset _server_ _count_
	                local _count_
	                _count_=`$ECHO "${_line_}" | grep -o "::" | wc -l`
					if [ "${_ip_type_}" == "IPv6" ] && [ "${_count_}" == 3 ]; then
		                _server_=`$ECHO ${_line_} | grep -oE '([a-fA-F0-9]{1,4}::?){1,7}[a-fA-F0-9]{1,4}' | head -n 1 | awk -F "::" '{ print $1 "::" $2}'`
		                _serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
	                else
		                _server_=`$ECHO ${_line_} | $AWK -F"::" '{print $1}'`
		                _serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $2}'`
	                fi
					run_remote_cmd "${_serv_hostname_}" "$RM -rf ${_boot_efi_}/fbx64.efi"
					run_remote_cmd "${_serv_hostname_}" "$CP -pr ${_fbx64_loc_} ${_boot_efi_}"
					_fbx64_copy_=$?
					if [ "${_fbx64_copy_}" -ne 0 ]; then
						_err_msg_="Failed to copy fbx64.efi file for Gen 10+ server: ${_server_}\n"
						abort_script "$_err_msg_"
					else
						log_msg -s "Successfully copied fbx64.efi file for Gen 10+ server: ${_server_}\n" -l ${LOGFILE}
					fi
				done
			elif [ "${CURR_SERVER_TYPE}" == "eniq_stats" ]; then
				$RM -rf ${_boot_efi_}/fbx64.efi
				$CP -pr ${_fbx64_loc_} ${_boot_efi_}
				_fbx64_copy_=$?
				if [ "${_fbx64_copy_}" -ne 0 ]; then
					_err_msg_="Failed to copy fbx64.efi file for Gen 10+ server\n"
					abort_script "$_err_msg_"
				else
					log_msg -s "Successfully copied fbx64.efi file for Gen 10+ server\n" -l ${LOGFILE}
				fi
			fi
		fi
	fi
fi

#Logging Eniq Activity
if [ "${ACTION_TYPE}" == "post_upgrade" ]; then
    ENIQ_HIST_FILE=${ENIQ_ADMIN_DIR}/version/eniq_history
    UPG_PATH=`$CAT ${ENIQ_HIST_FILE} | $GREP -w ENIQ_STATUS | $AWK '{print $2}' | $TAIL -1`
    UPG_DATE=`$DATE '+%Y-%m-%d %H:%M:%S'`
    $ECHO "ENIQ ACTIVITY INFO=Upgrade;${UPG_DATE};${UPG_PATH}" | $TEE -a ${ENIQ_LOG_DIR}/eniq_activity_history.log >> ${LOGFILE}
    _hist_status_=$?
    if [ "${_hist_status_}" -ne 0 ]; then
        _err_msg_="Failed to update Eniq Activity log file\n"
        abort_script "$_err_msg_"
    else
       $ECHO "Successfully logged Eniq Activity"
    fi
fi

insert_header_footer foot "Successfully completed the cleanup" ${LOGFILE}

}

### Function: cleanup_admin_ui ###     
#
# Necessary flag files set through Admin-UI are deleted.
#
# Arguments:
#    $1 - parameter that should be passed to the function.
# Return Values:
#   none
cleanup_admin_ui()
{
log_msg -t -q "Running clean-up script of admin UI " -l ${LOGFILE}

# Check the required script exists or not
cleanup_ffu_script_="${SW_INSTALLER_DIR}/cleanup_FFU.bsh"
check_for_file -s ${cleanup_ffu_script_}
    log_msg -q -s "\nStarting to run $BASH ${SW_INSTALLER_DIR}/cleanup_FFU.bsh "$1" -l ${LOGFILE}" -l ${LOGFILE}
    $BASH ${SW_INSTALLER_DIR}/cleanup_FFU.bsh "$1" -l ${LOGFILE}
    if [ $? -ne 0 ]; then
        _err_msg_="Error running script ${SW_INSTALLER_DIR}/cleanup_FFU.bsh "$1" . Please refer logs \n"
        abort_script "$_err_msg_"
    fi
}

### Function: cleanup_feature_only ###    
#
# Delete the current stage files from last run
#
# Arguments:
#   none
# Return Values:
#   none
cleanup_feature_only()
{
if [ "${ACTION_TYPE}" == "upgrade_feature_only" ]; then
    if [ -s "${ENIQ_CORE_INST_DIR}/etc/current_upgrade_feature_only_stage" ]; then
        $CAT ${ENIQ_CORE_INST_DIR}/etc/current_upgrade_feature_only_stage | $GREP -w "cleanup" >> /dev/null 2>&1
        if [ $? -eq 0 ]; then
            $RM -rf "${ENIQ_CORE_INST_DIR}/etc/current_upgrade_feature_only_stage"
        fi
    fi
elif [ "${post_upgrade_type_flag}" == "1" ]; then
    if [ -s "${ENIQ_CORE_INST_DIR}/etc/current_post_upgrade_feature_only_stage" ]; then
        $CAT ${ENIQ_CORE_INST_DIR}/etc/current_post_upgrade_feature_only_stage | $GREP -w "cleanup" >> /dev/null 2>&1
        if [ $? -eq 0 ]; then
            $RM -rf "${ENIQ_CORE_INST_DIR}/etc/current_post_upgrade_feature_only_stage"
        fi
    fi
elif [ "${rollback_type_flag}" == "1" ]; then
    if [ -s "${VAR_TMP_DIR}/current_rollback_feature_only_stage" ]; then
        $CAT ${VAR_TMP_DIR}/current_rollback_feature_only_stage | $GREP -w "cleanup" >> /dev/null 2>&1
        if [ $? -eq 0 ]; then
            $RM -rf "${VAR_TMP_DIR}/current_rollback_feature_only_stage"
        fi
    fi
fi    
}

### Function: copy_fls_file ###
#
# To copy the fls_conf file to reader server for oss entry merging
#
# Arguments:
#       none
# Return Values:
#       none
copy_fls_file()
{
 
_reader_server_=/var/tmp/reader_server
$RM -rf ${_reader_server_} 

for _line_ in `$CAT  ${_deployed_servers_} | $EGREP -v 'stats_coordinator|stats_engine'`
do
	unset _ip_address_ _count_
	local _ip_address_ _count_
	_count_=`$ECHO "${_line_}" | grep -o "::" | wc -l`

	if [ "${_ip_type_}" == "IPv6" ] && [ "${_count_}" == 3 ]; then
		_ip_address_=`$ECHO ${_line_} | grep -oE '([a-fA-F0-9]{1,4}::?){1,7}[a-fA-F0-9]{1,4}' | head -n 1 | awk -F "::" '{ print $1 "::" $2}'`
	else
		_ip_address_=`$ECHO ${_line_} | $AWK -F"::" '{print $1}'`
	fi
	$ECHO "${_ip_address_}" >> ${_reader_server_}
done

if [ ! -f ${_reader_server_} ]; then
    _err_msg_="could not find reader server details"
    abort_script "${_err_msg_}"  "${EXEC_SHELL_CMD}"
fi

log_msg -s "Copying .${ENIQ_CONF_DIR}/fls_config file to reader." -l ${LOGFILE}
for reader in  `$CAT ${_reader_server_}`; do
    if [ "${_ip_type_}" == "IPv6" ]; then
		$SCP -6 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -pr ${ENIQ_CONF_DIR}/fls_conf  ${DEFAULT_USER}@[${reader}]:/${ENIQ_CONF_DIR}
	else
		$SCP -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -pr ${ENIQ_CONF_DIR}/fls_conf  ${DEFAULT_USER}@${reader}:/${ENIQ_CONF_DIR}
	fi
    if [ $? -ne 0 ]; then
        _err_msg_="could not copy ${ENIQ_CONF_DIR}/fls_conf to reader server"
        abort_script "${_err_msg_}"  "${EXEC_SHELL_CMD}"
    fi
done

}
### Function: core_sw_upgrade ###
#
# To upgrade the Core SW on all server(s) in the deployment
#
# Arguments:
#       none
# Return Values:
#       none
core_sw_upgrade()
{
insert_header_footer head "Entering Upgrade stage - ${NEXT_STAGE}" ${LOGFILE}

#Checking if upgrade is required
if [ ! "${USER_STAGE}" -a ! -f "${ENIQ_CONF_DIR}/core_upgrade_proceed" ]; then
    if [ "${ACTION_TYPE}" == "upgrade" -o "${ACTION_TYPE}" == "upgrade_platform_only" ]; then
        if [ ! -s "${UPG_VAR_TMP_DIR}/${UPG_SW_DIR}/core_install/version/pkginfo" ]; then
            _err_msg_="${UPG_VAR_TMP_DIR}/${UPG_SW_DIR}/core_install/version/pkginfo file not found"
            abort_script "${_err_msg_}"  "${EXEC_SHELL_CMD}"
        else
            check_upgrade_required
            if [ "${_upgrade_required_}" == "0" ]; then
                log_msg -s "ENIQ_Installation package version of upgrade release is equal to or lower than that of current release" -l ${LOGFILE}
                log_msg -s "No ENIQ Core SW upgrade required" -l ${LOGFILE}
                CORE_SW_LOGFILE=`$LS -at ${CORE_SW_LOGFILE_DIR} | $GREP manage_upgrade | $HEAD -1`
                insert_header_footer foot "INFO: Skipping ${ACTION_TYPE} Stage - ${NEXT_STAGE} for ${CURR_SERVER_TYPE}" ${LOGFILE} 
                log_msg -s "\nLog file for the stage - ${NEXT_STAGE}: ${CORE_SW_LOGFILE_DIR}/${CORE_SW_LOGFILE}" -l ${LOGFILE}
                set_next_stage `$EXPR ${ARRAY_ELEM}+1`
                return 0
            else
                log_msg -s "ENIQ_Installation package version of upgrade release is higher than that of current release" -l ${LOGFILE}
            fi
            $TOUCH ${ENIQ_CONF_DIR}/core_upgrade_proceed
        fi
    fi
fi

#updating dcuser_pass file
passphrase=`$CAT ${CLI_CONF_DIR}/strong_passphrase`
dcuser_pass_file=`$CAT /eniq/sw/conf/dcuser_password_file`
encryption_flag=`iniget SunOS_USER_1 -v dcuser_encryption_flag -f /eniq/installation/config/SunOS.ini`

if [ ! -f /tmp/dcuser_file_encrypted -a "${encryption_flag}" != "yy" ]; then
    log_msg -s "Updating the dcuser_password_file with new encryption mechanism" -l ${LOGFILE}
    encoded_dcuser_password=`$ECHO ${dcuser_pass_file} | openssl enc -base64 -d`
    encrypted_dcuser_password=`$ECHO ${encoded_dcuser_password} | openssl enc -aes-256-ctr -md sha512 -a -salt -pass pass:${passphrase}`
    $ECHO ${encrypted_dcuser_password} > /eniq/sw/conf/dcuser_password_file
    $TOUCH /tmp/dcuser_file_encrypted
fi

#updating default dcuser password
if [ "${CURR_SERVER_TYPE}" == "eniq_stats" -o "${CURR_SERVER_TYPE}" == "stats_coordinator" ] ; then
    dcuser_encryption_flag=`iniget SunOS_USER_1 -v dcuser_encryption_flag -f ${TEMP_CORE_SW_UPG_DIR}/templates/stats/SunOS.ini_vnx`
    if [ "${dcuser_encryption_flag}" = "y" ]; then
        passphrase=`$CAT ${CLI_CONF_DIR}/strong_passphrase`
        dcuser_pass=`iniget SunOS_USER_1 -v password -f ${TEMP_CORE_SW_UPG_DIR}/templates/stats/SunOS.ini_raw`
        dcuser_decryp_pass=`echo ${dcuser_pass}| openssl enc -base64 -d`
        dcuser_new_enc=`echo ${dcuser_decryp_pass} | openssl enc -aes-256-ctr -md sha512 -a -salt -pass pass:${passphrase}`
        sunos_list=`$LS ${TEMP_CORE_SW_UPG_DIR}/templates/stats/ | grep SunOS.ini | awk -F " " {'print $1'}`
        for list in ${sunos_list}; do
            iniset SunOS_USER_1 -f ${TEMP_CORE_SW_UPG_DIR}/templates/stats/${list} password=${dcuser_new_enc}
			password_update=$?
            iniset SunOS_USER_1 -f ${TEMP_CORE_SW_UPG_DIR}/templates/stats/${list} dcuser_encryption_flag=yy
			encryption_update=$?
			if [ [ "${password_update}" -ne 0 ] -o [ "${encryption_update}" -ne 0 ] ]; then
		        _err_msg_="Unable to update password or dcuser encryption flag for SunOS_USER_1 in ${TEMP_CORE_SW_UPG_DIR}/templates/stats/${list}"
			    abort_script "${_err_msg_}"
			fi
        done
        $ECHO "Dcuser password updated in SunOS.ini" | $TEE -a ${LOGFILE}
    fi
fi

if [ "${CURR_SERVER_TYPE}" == "stats_coordinator" ] ; then
    if [ ! -f ${_deployed_servers_} ]; then
        _deployed_servers_="${TEM_DIR}/deployed_servers.$$.tmp"
        $PERL ${GET_IP_ORDER_SCRIPT} -f ${_deployed_servers_}
    fi
    sunos_list=`$LS ${TEMP_CORE_SW_UPG_DIR}/templates/stats/ | grep SunOS.ini | awk -F " " {'print $1'}`
    for _line_ in `cat ${_deployed_servers_} | grep -vw "stats_coordinator"`; do
	    unset _count_
	    local _count_
	    _count_=`$ECHO "${_line_}" | grep -o "::" | wc -l`

	    if [ "${_ip_type_}" == "IPv6" ] && [ "${_count_}" == 3 ]; then
		    _server_=`$ECHO ${_line_} | grep -oE '([a-fA-F0-9]{1,4}::?){1,7}[a-fA-F0-9]{1,4}' | head -n 1 | awk -F "::" '{ print $1 "::" $2}'`
	    else
		    _server_=`$ECHO ${_line_} | $AWK -F"::" '{print $1}'`
	    fi
        for list in ${sunos_list}; do
		    if [ "${_ip_type_}" == "IPv6" ]; then
			    scp -6 -p -o StrictHostKeyChecking=no ${TEMP_CORE_SW_UPG_DIR}/templates/stats/${list} [${_server_}]:${TEMP_CORE_SW_UPG_DIR}/templates/stats/
			else
			    scp -p -o StrictHostKeyChecking=no ${TEMP_CORE_SW_UPG_DIR}/templates/stats/${list} ${_server_}:${TEMP_CORE_SW_UPG_DIR}/templates/stats/
			fi
            if [ $? -ne 0 ]; then
               _err_msg_="Failed to copy ${TEMP_CORE_SW_UPG_DIR}/templates/stats/${list} from ${_server_} to ${TEMP_CORE_SW_UPG_DIR}/templates/stats/${list}"
               abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
            fi
        done
    done
fi





# Check upgrade sw dir exists or not
local _check_command_="${CORE_SW_UPG_DIR}/upgrade_core_sw.bsh"
check_for_file -s ${_check_command_}

cd ${CORE_SW_UPG_DIR}

log_msg -q -s "\nStarting to run $BASH ./upgrade_core_sw.bsh -d $BASE_SW_DIR -p ${UPG_VAR_TMP_DIR}/${UPG_SW_DIR} -o ${OM_SW_DIR}/om -t ${STORAGE_TYPE} -N -l ${CORE_SW_LOGFILE}" -l ${LOGFILE}

$BASH ./upgrade_core_sw.bsh -d $BASE_SW_DIR -p ${UPG_VAR_TMP_DIR}/${UPG_SW_DIR} -o ${OM_SW_DIR}/om_linux -t ${STORAGE_TYPE} -N -l ${CORE_SW_LOGFILE}


if [ $? -ne 0 ]; then
    _err_msg_="Upgrade failed at ${NEXT_STAGE}. Please refer log file at ${CORE_SW_LOGFILE_DIR}. \n"
    abort_script "$_err_msg_"
fi

CORE_SW_LOGFILE=`$LS -at ${CORE_SW_LOGFILE_DIR} | $GREP manage_upgrade | $HEAD -1`
$RM -rf ${ENIQ_CONF_DIR}/core_upgrade_proceed
insert_header_footer foot "Successfully upgraded CORE SW" ${LOGFILE}
log_msg -s "\nLog file for the stage - ${NEXT_STAGE}: ${CORE_SW_LOGFILE_DIR}/${CORE_SW_LOGFILE}" -l ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: create_snapshots ###
#
# To create NAS, SAN and ZFS Snapshots
#
# Arguments:
#    none
# Return Values:
#     none
create_snapshots()
{
insert_header_footer head "Entering Upgrade stage - ${NEXT_STAGE}" ${LOGFILE}

if [ ${STAGE_QUIET} ]; then
        insert_header_footer foot "INFO: Skipping Upgrade Stage - ${NEXT_STAGE} for non FT deployments" ${LOGFILE}
        set_next_stage `$EXPR ${ARRAY_ELEM}+1`
        return 0
elif [ -f "${VAR_TMP_DIR}/feature_upgrade_flag" ]; then
        insert_header_footer foot "INFO: Skipping Upgrade Stage - ${NEXT_STAGE} for frequent feature upgrade." ${LOGFILE}
        set_next_stage `$EXPR ${ARRAY_ELEM}+1`  
        return 0
fi 


if [ -s ${ENIQ_CONF_DIR}/san_details ]; then
    STORAGE_TYPE=`$CAT ${ENIQ_CONF_DIR}/san_details | $EGREP "^STORAGE_TYPE=" | $AWK -F\= '{print $2}'`
fi

generation=`dmidecode -s system-product-name | awk -F " " '{print $3}'`
 
if [ "${STORAGE_TYPE}" == "fs" ]; then
    if [ "${generation}" == "Gen10" ]; then 
      iniget Gen10_eniq_stats_fs_size -f ${ENIQ_CONF_DIR}/${SUNOS_INI} | $GREP -w sw > ${TEM_DIR}/snap_size.txt
      $SED -i "s/$( $CAT ${TEM_DIR}/snap_size.txt | $AWK -F "=" '{print $2}' | $AWK -F "." '{print $2}' | $AWK -F ":" '{print $2}')/"100"/" ${TEM_DIR}/snap_size.txt
      size=`$CAT ${TEM_DIR}/snap_size.txt | $AWK -F "=" '{print $2}' | $AWK -F "." '{print $2}' | $AWK -F ":" '{print $2}'`
      if [ $size -eq 100 ]; then
        $SED -i "s/$(iniget Gen10_eniq_stats_fs_size -f ${ENIQ_CONF_DIR}/${SUNOS_INI} | $GREP -w sw)/$($CAT ${TEM_DIR}/snap_size.txt )/" ${ENIQ_CONF_DIR}/${SUNOS_INI}
      fi
	fi
	if [ "${generation}" == "Gen9" ]; then 
      iniget Gen9_eniq_stats_fs_size -f ${ENIQ_CONF_DIR}/${SUNOS_INI} | $GREP -w sw > ${TEM_DIR}/snap_size.txt
      $SED -i "s/$( $CAT ${TEM_DIR}/snap_size.txt | $AWK -F "=" '{print $2}' | $AWK -F "." '{print $2}' | $AWK -F ":" '{print $2}')/"100"/" ${TEM_DIR}/snap_size.txt
      size=`$CAT ${TEM_DIR}/snap_size.txt | $AWK -F "=" '{print $2}' | $AWK -F "." '{print $2}' | $AWK -F ":" '{print $2}'`
      if [ $size -eq 100 ]; then
        $SED -i "s/$(iniget Gen9_eniq_stats_fs_size -f ${ENIQ_CONF_DIR}/${SUNOS_INI} | $GREP -w sw)/$($CAT ${TEM_DIR}/snap_size.txt )/" ${ENIQ_CONF_DIR}/${SUNOS_INI}
      fi
	fi
	if [ "${generation}" == "Gen8" ]; then 
      iniget Gen8_eniq_stats_fs_size -f ${ENIQ_CONF_DIR}/${SUNOS_INI} | $GREP -w sw > ${TEM_DIR}/snap_size.txt
      $SED -i "s/$( $CAT ${TEM_DIR}/snap_size.txt | $AWK -F "=" '{print $2}' | $AWK -F "." '{print $2}' | $AWK -F ":" '{print $2}')/"100"/" ${TEM_DIR}/snap_size.txt
      size=`$CAT ${TEM_DIR}/snap_size.txt | $AWK -F "=" '{print $2}' | $AWK -F "." '{print $2}' | $AWK -F ":" '{print $2}'`
      if [ $size -eq 100 ]; then
        $SED -i "s/$(iniget Gen8_eniq_stats_fs_size -f ${ENIQ_CONF_DIR}/${SUNOS_INI} | $GREP -w sw)/$($CAT ${TEM_DIR}/snap_size.txt )/" ${ENIQ_CONF_DIR}/${SUNOS_INI}
      fi
	fi
fi


local _check_command_="${ENIQ_BKUP_SW_BIN_DIR}/prep_eniq_snapshots.bsh"
check_for_file -s ${_check_command_}

if [ "${ACTION_TYPE}" == "upgrade_feature_only" ]; then
   $TOUCH ${VAR_TMP_DIR}/rollback_conf_adminUI
fi

$TOUCH ${CALLED_THROUGH_UPGRADE}

log_msg -q -s "\nStarting to run $BASH ${ENIQ_BKUP_SW_BIN_DIR}/prep_eniq_snapshots.bsh -N" -l ${LOGFILE}

if [ -f ${VAR_TMP_DIR}/current_upgrade_feature_only_ui_stage ]; then
    $ECHO "Snapshot Creation" > ${VAR_TMP_DIR}/current_upgrade_feature_only_ui_stage 
elif [ -f ${VAR_TMP_DIR}/current_add_features_ui_stage ]; then
    $ECHO "Snapshot Creation" > ${VAR_TMP_DIR}/current_add_features_ui_stage     
fi 

$BASH ${ENIQ_BKUP_SW_BIN_DIR}/prep_eniq_snapshots.bsh -N
if [ $? -ne 0 ]; then
    _err_msg_="Exiting... Unable to  create snapshots. Please refer logfile: ${SNAPSHOT_LOGFILE}. \n"
    $RM -rf ${CALLED_THROUGH_UPGRADE}
    $RM -rf ${ENIQ_ADMIN_BIN_DIR}/snap_label
    $RM -rf ${VAR_TMP_DIR}/snap_server_list
    abort_script "$_err_msg_"
fi

$RM -rf ${CALLED_THROUGH_UPGRADE}
insert_header_footer foot "Successfully created Snapshots." ${LOGFILE}
log_msg -s "\nLog file for the stage - ${NEXT_STAGE}: ${SNAPSHOT_LOGFILE}" -l ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: delete_rolling_snapshots ###
#
# To delete NAS, SAN and FS Snapshots
#
# Arguments:
#    none
# Return Values:
#     none
delete_rolling_snapshots()
{
log_msg -h -s "Starting to delete rolling snapshots on $HOST_NAME" -l ${LOGFILE}

_check_command_1_="${ENIQ_BKUP_SW_BIN_DIR}/manage_san_snapshots.bsh" 
check_for_file -s ${_check_command_1_}

_check_command_2_="${ENIQ_BKUP_SW_BIN_DIR}/manage_nas_snapshots.bsh" 
check_for_file -s ${_check_command_2_}

_check_command_3_="${ENIQ_BKUP_SW_BIN_DIR}/manage_fs_snapshots.bsh" 
check_for_file -s ${_check_command_3_}

_check_command_4_="${ENIQ_BKUP_SW_BIN_DIR}/cleanup_eniq_backup.bsh" 
check_for_file -s ${_check_command_4_}

# Get Snapshot label 
san_snap_label=`$BASH ${ENIQ_BKUP_SW_BIN_DIR}/manage_san_snapshots.bsh -a list -f ALL | $AWK '{print \$2}' | $GREP -v '^$' | $GREP [a-z0-9-]*@[0-9]*@[a-z0-9]*| $AWK -F'@' '{print \$NF}' | $SORT | $UNIQ`

nas_snap_label=`$NASCLI list_snapshots - | $AWK '{print \$1}' | $AWK -F'/' '{print \$NF}'| $SORT | $UNIQ` 

fs_snap_label=`$BASH ${ENIQ_BKUP_SW_BIN_DIR}/manage_fs_snapshots.bsh -a list -f ALL | $AWK '{print \$1}' | $GREP -v '^$' | $GREP @[a-z0-9]* | $AWK -F'@' '{print \$NF}'| $SORT | $UNIQ`

log_msg -q -s "Snap Labels on $HOST_NAME ::" -l ${LOGFILE}
log_msg -q -s " SAN Snap Label(s): $san_snap_label" -l ${LOGFILE}
log_msg -q -s " NAS Snap Label(s): $nas_snap_label" -l ${LOGFILE}
log_msg -q -s " FS Snap Label(s): $fs_snap_label" -l ${LOGFILE}

if [ "${CURR_SERVER_TYPE}" == "stats_coordinator" -o  "${CURR_SERVER_TYPE}" == "eniq_stats" ]; then
    
    if [ ! "${san_snap_label}" -a ! "${nas_snap_label}" -a ! "${fs_snap_label}" ]; then
        log_msg -s "\nNo Rolling Snapshots found on $HOST_NAME. " -l ${LOGFILE}
    else
        roll_snap_list=(${san_snap_label} ${nas_snap_label} ${fs_snap_label})
        unique_roll_snap=$(echo "${roll_snap_list[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' ')
        log_msg -q -s "Deleting Rolling Snapshots with label(s) - ${unique_roll_snap} " -l ${LOGFILE}

        for snap_label in ${unique_roll_snap[*]} ; do
            log_msg -q -s "\nStarting to run $BASH ${ENIQ_BKUP_SW_BIN_DIR}/cleanup_eniq_backup.bsh -N -R -S ${snap_label} on $HOST_NAME " -l ${LOGFILE}
            $BASH ${ENIQ_BKUP_SW_BIN_DIR}/cleanup_eniq_backup.bsh -N -R -S ${snap_label} 
            if [ $? -ne 0 ]; then
                _err_msg_="Exiting... Unable to delete snapshots. Please refer logfile: ${DEL_SNAP_LOGFILE} on $HOST_NAME  \n"
                abort_script "$_err_msg_"
            fi
        done
        log_msg -s "Successfully deleted Snapshots on $HOST_NAME. Please refer log file: ${DEL_SNAP_LOGFILE}\n" -l ${LOGFILE}
    fi
fi
    
# Get an ordered list of servers based on the server_list file:
_deployed_servers_="${TEM_DIR}/deployed_servers.$$.tmp"
$PERL ${GET_IP_ORDER_SCRIPT} -f ${_deployed_servers_}

for _line_ in `$EGREP -i 'engine|eniq_mz|ec_|dwh_reader_|eniq_ui' ${_deployed_servers_}`; do
    unset _ip_address_ _serv_hostname_ _serv_type_ _count_
	local _ip_address_ _serv_hostname_ _serv_type_ _count_	
	_count_=`$ECHO "${_line_}" | grep -o "::" | wc -l`

	if [ "${_ip_type_}" == "IPv6" ] && [ "${_count_}" == 3 ]; then
		_ip_address_=`$ECHO ${_line_} | grep -oE '([a-fA-F0-9]{1,4}::?){1,7}[a-fA-F0-9]{1,4}' | head -n 1 | awk -F "::" '{ print $1 "::" $2}'`
		_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
		_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $4}'`
	else
		_ip_address_=`$ECHO ${_line_} | $AWK -F"::" '{print $1}'`
		_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $2}'`
		_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
	fi
    local _snap_check_="true"
        
    if [ ! "${_ip_address_}" -o ! "${_serv_hostname_}" -o ! "${_serv_type_}" ]; then
                _err_msg_="Error obtaining list of deployed servers."
                abort_script "${_err_msg_}"
        fi

    log_msg -h -s "Deleting FS Snaphots on $_serv_hostname_" -l ${LOGFILE}    

    _cmd_1_="$BASH ${ENIQ_BKUP_SW_BIN_DIR}/manage_fs_snapshots.bsh -a list -f ALL | $AWK '{print \$1}' | $GREP -v '^$' | $GREP @[a-z0-9*]* | $AWK -F'@' '{print \$NF}'| $SORT | $UNIQ"
    
    if [ "${_user_root}" == 1 ]; then			
		log_msg -s "run_remote_cmd ${_serv_hostname_} ${_cmd_1_}" -l ${LOGFILE}
		_cmd_2_=`run_remote_cmd ${_serv_hostname_} "${_cmd_1_}"`
	else
		log_msg -s "run_remote_cmd ${_serv_hostname_} $SUDO ${_cmd_1_}" -l ${LOGFILE}
		_cmd_2_=`run_remote_cmd ${_serv_hostname_} "$SUDO ${_cmd_1_}" "" "$_get_id_"`
	fi
    
    roll_snap_list=($_cmd_2_)
    log_msg -s "List of FS Snap Label: ${roll_snap_list[*]}" -l ${LOGFILE}
    if [ ${#roll_snap_list[@]} -eq 0 ]; then
        log_msg -s "No FS snapshots found on $_serv_hostname_" -l ${LOGFILE}
        _snap_check_="false"
    fi

    if [ "$_snap_check_" == "true" ]; then
        for snap_label in ${roll_snap_list[*]}; do
            snap_label=`echo $snap_label | sed 's/\^M//'`
            log_msg -q -s "FS Snapshot with label - ${snap_label} found"
            log_msg -q -s "\nStarting to run $BASH ${ENIQ_BKUP_SW_BIN_DIR}/cleanup_eniq_backup.bsh -N -R -S ${snap_label} on $_serv_hostname_" -l ${LOGFILE}
            _cmd_2_="$BASH ${ENIQ_BKUP_SW_BIN_DIR}/cleanup_eniq_backup.bsh -N -R -S ${snap_label}"
			if [ "${_user_root}" == 1 ]; then			
				run_remote_cmd "${_serv_hostname_}" "${_cmd_2_}"
				if [ $? -ne 0 ]; then
					_err_msg_="Exiting... Unable to delete snapshots. Please refer logfile: ${DEL_SNAP_LOGFILE} on $_serv_hostname_.  \n"
					abort_script "$_err_msg_"
				fi
			else
				run_remote_cmd "${_serv_hostname_}" "$SUDO ${_cmd_2_}" "" "$_get_id_"
				if [ $? -ne 0 ]; then
					_err_msg_="Exiting... Unable to delete snapshots. Please refer logfile: ${DEL_SNAP_LOGFILE} on $_serv_hostname_.  \n"
					abort_script "$_err_msg_"
				fi
			fi 
        done    
    fi
    log_msg -q -s "Successfully deleted FS Snapshots on $_serv_hostname_. Please refer log file: ${DEL_SNAP_LOGFILE}\n" -l ${LOGFILE}
done
}

### Function: disable_oss_mounts ###
# 
# To disable the mounts for the duration of the upgrade
#
# Arguments:
#       none
# Return Values:
#     none
disable_oss_mounts()
{
insert_header_footer head "Entering ${ACTION_TYPE} stage - ${NEXT_STAGE}" ${LOGFILE}

if [ "${ACTION_TYPE}" == "post_upgrade" -o "${ACTION_TYPE}" == "post_upgrade_platform_only" -o "${ACTION_TYPE}" == "post_upgrade_feature_only" ]; then
    insert_header_footer foot "INFO: Skipping ${ACTION_TYPE} Stage - ${NEXT_STAGE} for ${CURR_SERVER_TYPE}" ${LOGFILE} 
    set_next_stage `$EXPR ${ARRAY_ELEM}+1`
    return 0
fi

if [ "${rollback_type_flag}" != 1 ]; then
    local _disable_mounts_script_="${TMPL_ADMIN_BIN_DIR}/disable_mounts.bsh"
else
    local _disable_mounts_script_="${TEMPLATES_ADMIN_BIN_DIR}/disable_mounts.bsh"
fi

check_for_file -s ${_disable_mounts_script_}

# Stop ENIQ Services
if [ "${rollback_type_flag}" != 1 ]; then
    stop_services
fi

log_msg -t -s "Disabling OSS mounts" -l ${LOGFILE}
# Get an ordered list of servers based on the server_list file:
_deployed_servers_="${TEM_DIR}/deployed_servers.$$.tmp"
$PERL ${GET_IP_ORDER_SCRIPT} -f ${_deployed_servers_}

for _line_ in `$EGREP -i 'engine|coordinator|eniq_mz|ec_|eniq_events|eniq_stats' ${_deployed_servers_}`; do
    unset _ip_address_ _serv_hostname_ _serv_type_ _count_
	local _ip_address_ _serv_hostname_ _serv_type_ _count_
	_count_=`$ECHO "${_line_}" | grep -o "::" | wc -l`

	if [ "${_ip_type_}" == "IPv6" ] && [ "${_count_}" == 3 ]; then
		_ip_address_=`$ECHO ${_line_} | grep -oE '([a-fA-F0-9]{1,4}::?){1,7}[a-fA-F0-9]{1,4}' | head -n 1 | awk -F "::" '{ print $1 "::" $2}'`
		_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
		_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $4}'`
	else
		_ip_address_=`$ECHO ${_line_} | $AWK -F"::" '{print $1}'`
		_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $2}'`
		_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
	fi
    if [ ! "${_ip_address_}" -o ! "${_serv_hostname_}" -o ! "${_serv_type_}" ]; then
        _err_msg_="Failed to disable mounts. Error obtaining list of deployed servers."
        abort_script "${_err_msg_}"
    fi

    # Stats coordinator should not run the script 
    if [ "${_serv_type_}" != "stats_coordinator" ]; then    
        # If the IP found in the order file matches my IP, run locally
        if [ "${_ip_address_}" == "${HOST_IP}" ]; then
            log_msg -t -l ${LOGFILE} -s "Disabling mounts on ${HOST_NAME}"
            log_msg -s "Starting to run $BASH ${_disable_mounts_script_}" -l ${LOGFILE}
            $BASH ${_disable_mounts_script_}
            if [ $? -ne 0 ]; then
                abort_script "Failed to disable mounts on ${HOST_NAME}.\nPlease check log file at ${ENIQ_LOG_DIR}/upgrade"
            else
                log_msg -t -s "Disabled mounts on ${HOST_NAME}\n" -l ${LOGFILE}
            fi
        else
            log_msg -t -s "Disabling mounts on ${_serv_hostname_}" -l ${LOGFILE}
            log_msg -s "Starting to run $BASH ${_disable_mounts_script_}" -l ${LOGFILE}
            run_remote_cmd "${_serv_hostname_}" "$BASH ${_disable_mounts_script_}"
            if [ $? -ne 0 ]; then
                abort_script "Failed to disable mounts on ${_serv_hostname_}. \n Please check log file at ${ENIQ_LOG_DIR}/upgrade"
            else
                log_msg -t -s "Disabled mounts on ${_serv_hostname_}\n" -l ${LOGFILE}
            fi
        fi
    fi
done

if [ "${rollback_type_flag}" != 2 ]; then

    if [ -f ${ENIQ_LOG_DIR}/.dtrace_enabled ]; then
        #Terminate Data Regeneration Logging
        local _manage_dtrace_script_="${ENIQ_ADMIN_BIN_DIR}/manage_dtrace.bsh"
        check_for_file -s ${_manage_dtrace_script_}

        log_msg -q -s "Starting to run $BASH ${_manage_dtrace_script_} -a regen_prep" -l ${LOGFILE}
        $BASH ${_manage_dtrace_script_} -a regen_prep | $TEE -a ${LOGFILE}
        _rc_manage_dtrace_=`$ECHO ${PIPESTATUS[0]}`
        if [ "${_rc_manage_dtrace_}" -ne 0 ]; then
            _err_msg_="Exiting... Unable to terminate data regeneration logging \n"
            abort_script "${_err_msg_}"
        fi
    fi
fi

insert_header_footer foot "Completed Stage - disabled OSS Mounts on all required Servers " ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: get_array_element ###
#
# Get the current array element number
#
# Arguments:
#   none
# Return Values:
#   none
get_array_element()
{
_num_elements_=${#ENIQ_CORE_STAGES[*]}
_array_length_=`${EXPR} ${_num_elements_} - 1`

for (( _elem_=0; _elem_<=${_array_length_}; _elem_++ )); do
    $ECHO ${ENIQ_CORE_STAGES[${_elem_}]} | $GREP -w ${NEXT_STAGE} >> /dev/null 2>&1
    if [ $? -eq 0 ]; then
        ARRAY_ELEM=${_elem_}
        break
    fi
done
}

### Function: get_next_stage ###
#
# Get the stage to be run
#
# Arguments:
#   $1 : Stage to be set to. Either numeric value or 'done'
# Return Values:
#   none
get_next_stage()
{
ARRAY_ELEM=0

if [ -s $STAGEFILE ]; then
    NEXT_STAGE=`$CAT $STAGEFILE | $EGREP -v '^[[:blank:]]*#' | $SED -e 's| ||g'`
    if [ ! "$NEXT_STAGE" ]; then
        _err_msg_="Failed to read stage from ${STAGEFILE}, exiting."
        abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
    fi

    if [ "$NEXT_STAGE" == "cleanup" ]; then
        return 0
    else
        $ECHO ${ENIQ_CORE_STAGES[*]} | $GREP -w ${NEXT_STAGE} >> /dev/null 2>&1
        if [ $? -ne 0 ]; then
            _err_msg_="Specified stage ${NEXT_STAGE} is not a valid upgrade stage"
            abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
        fi
    fi

    # Get the element number so we can move along the array
    get_array_element
else
    $MKDIR -p `$DIRNAME $STAGEFILE`
    if [ $? -ne 0 ]; then
        _err_msg_="Failed to create directory `$DIRNAME ${STAGEFILE}`, exiting."
        abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
    fi

    NEXT_STAGE=${ENIQ_CORE_STAGES[${ARRAY_ELEM}]}
fi
}

### Function: insert_header_footer ###
#
#   Insert a stage header/footer message
#
# Arguments:
#   $1 : head/foot
#   $2 : Message
#   $3 : Logfile
# Return Values:
#   none
insert_header_footer()
{
if [ $# -ne 3 ]; then
    _err_msg_="3 Parameters must be passed to header/footer function"
    abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ "$1" != "head" -a "$1" != "foot" ]; then
    _err_msg_="Only Param of head/foot is allowed...exiting!"
    abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi
_type_=$1

_msg_=$2

_logfile_=$3

_time_=`$DATE '+%Y-%b-%d_%H.%M.%S'`
if [ "$_type_" == "head" ]; then
    log_msg -s "\n----------------------------------------------------------------------------" -l ${_logfile_}
    log_msg -s "\n----------------------------------------------------------------------------" -l ${_logfile_}
    log_msg -s "----------------------------------------------------------------------------" -l ${_logfile_}
    log_msg -s "$_time_ : $_msg_" -l ${_logfile_}
    log_msg -s "----------------------------------------------------------------------------" -l ${_logfile_}
fi

if [ "$_type_" == "foot" ]; then
    log_msg -s "\n----------------------------------------------------------------------------" -l ${_logfile_}
    log_msg -s "$_time_ : $_msg_" -l ${_logfile_}
    log_msg -s "----------------------------------------------------------------------------" -l ${_logfile_}
    log_msg -s "----------------------------------------------------------------------------\n" -l ${_logfile_}
fi
}

## Function: platform_upgrade ###
#
# Arguments:
#   none
# Return Values:
#   none
platform_upgrade()
{
insert_header_footer head "Entering Upgrade stage - ${NEXT_STAGE}" ${LOGFILE}



# Check upgrade sw dir exists or not
local _check_command_="${ENIQ_ADMIN_BIN_DIR}/upgrade_platform_modules.bsh "
check_for_file -s ${_check_command_}

log_msg -q -s "\nStarting to run $BASH ${ENIQ_ADMIN_BIN_DIR}/upgrade_platform_modules.bsh -d $BASE_SW_DIR -N -l ${PLATFORM_UPG_LOGFILE}" -l ${LOGFILE}

$BASH ${ENIQ_ADMIN_BIN_DIR}/upgrade_platform_modules.bsh -d $BASE_SW_DIR -N -l ${PLATFORM_UPG_LOGFILE}
if [ $? -ne 0 ]; then
    _err_msg_="Upgrade failed at ${NEXT_STAGE}. Please refer logs. \n"
    abort_script "$_err_msg_"
else
    insert_header_footer foot "Successfully completed Platform Upgrade" ${LOGFILE}
fi

log_msg -s "\nLog file for the stage - ${NEXT_STAGE}: ${PLATFORM_UPG_LOGFILE}" -l ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

## Function: feature_upgrade ###
#
# Arguments:
#   none
# Return Values:
#   none
feature_upgrade()
{
insert_header_footer head "Entering Upgrade stage - ${NEXT_STAGE}" ${LOGFILE}

#This block is used only for feature upgrade and feature addition from Admin UI
if [ -f ${VAR_TMP_DIR}/current_upgrade_feature_only_ui_stage ]; then
    $ECHO "Parsers Update" > ${VAR_TMP_DIR}/current_upgrade_feature_only_ui_stage 
fi

if [ ! -s "${ENIQ_CORE_ETC_DIR}/features_to_be_managed" ]; then
        insert_header_footer foot "INFO: Skipping Upgrade Stage - ${NEXT_STAGE} no features have been selected for upgrade." ${LOGFILE}
        set_next_stage `$EXPR ${ARRAY_ELEM}+1`  
        return 0
fi

if [ "${CURR_SERVER_TYPE}" == "eniq_stats" -o "${CURR_SERVER_TYPE}" == "stats_coordinator" ]; then
   
    local _check_command_="${ENIQ_ADMIN_BIN_DIR}/manage_features.bsh"
    check_for_file -s ${_check_command_}
    
    log_msg -q -s "\nStarting to run $BASH ${ENIQ_ADMIN_BIN_DIR}/manage_features.bsh -a update -d ${FEATURE_SW_DIR} -G -l ${FEATURE_UPG_LOGFILE}" -l ${LOGFILE}
    
    $BASH ${ENIQ_ADMIN_BIN_DIR}/manage_features.bsh -a update -d ${FEATURE_SW_DIR} -G -l ${FEATURE_UPG_LOGFILE}
    if [ $? -ne 0 ]; then
        _err_msg_="Upgrade failed at ${NEXT_STAGE}. Please refer logs. \n"
        abort_script "$_err_msg_"
    else
        # Re-granting customized database users access to features
        $CP ${ENIQ_CORE_ETC_DIR}/features_to_be_managed /tmp/
        $BASH ${ENIQ_ADMIN_BIN_DIR}/admin_query_user.bsh -u -f /tmp/features_to_be_managed >> /dev/null 2>&1 &
        insert_header_footer foot "Successfully completed Feature Upgrade." ${LOGFILE}
    fi
else
    insert_header_footer foot "INFO: Skipping Upgrade Stage - ${NEXT_STAGE} for ${CURR_SERVER_TYPE}  " ${LOGFILE}
fi

$TOUCH ${VAR_TMP_DIR}/feature_upgrade_flag

log_msg -s "\nLog file for the stage - ${NEXT_STAGE}: ${FEATURE_UPG_LOGFILE}" -l ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
return 0
}

## Function: Add new features ###
#
# Arguments:
#   none
# Return Values:
#   none
add_new_features()
{
insert_header_footer head "Entering Upgrade stage - ${NEXT_STAGE}" ${LOGFILE}

$LS -l ${ENIQ_CORE_ETC_DIR}/feature_output_list_eniq_oss_* >> /dev/null 2>&1
if [ $? -ne 0 ]; then
    insert_header_footer foot "INFO: Skipping Upgrade stage - ${NEXT_STAGE} " ${LOGFILE}
    set_next_stage `$EXPR ${ARRAY_ELEM}+1`  
    return 0
fi

if [ "${CURR_SERVER_TYPE}" == "eniq_stats" -o "${CURR_SERVER_TYPE}" == "stats_coordinator" ]; then
   
    local _check_command_="${ENIQ_ADMIN_BIN_DIR}/manage_eniq_oss.bsh"
    check_for_file -s ${_check_command_}

    for _oss_name_ in `$CAT ${OSS_REF_NAME_FILE} | $AWK -F" " '{print $1}'`; do
           
        if [ -s "${ENIQ_CORE_ETC_DIR}/feature_output_list_${_oss_name_}" ]; then
            if [ -f ${VAR_TMP_DIR}/current_add_features_ui_stage ]; then
                $ECHO "Parsers Install" > ${VAR_TMP_DIR}/current_add_features_ui_stage
            fi
            log_msg -q -s "\nStarting to run $BASH ${ENIQ_ADMIN_BIN_DIR}/manage_eniq_oss.bsh -a update -h ${_oss_name_} -d ${FEATURE_SW_DIR} -l ${ADD_NEW_FEATURE_LOGFILE} -G" -l ${LOGFILE}
            $BASH ${ENIQ_ADMIN_BIN_DIR}/manage_eniq_oss.bsh -a update -h ${_oss_name_} -d ${FEATURE_SW_DIR} -G -l ${ADD_NEW_FEATURE_LOGFILE}
            if [ $? -ne 0 ]; then
                _err_msg_="Add new feature failed. Please refer logs ${LOGFILE}. \n"
                abort_script "$_err_msg_"
            else
                log_msg -q -s "Successfully added new features for ${_oss_name_}." -l ${LOGFILE}
            fi
        fi    
        
    done
    insert_header_footer foot "Successfully completed add new features." ${LOGFILE}
else
    insert_header_footer foot "INFO: Skipping Upgrade Stage - ${NEXT_STAGE} for ${CURR_SERVER_TYPE}  " ${LOGFILE}
fi

log_msg -s "\nLog file for the stage - ${NEXT_STAGE}: ${ADD_NEW_FEATURE_LOGFILE}" -l ${LOGFILE}

set_next_stage `$EXPR ${ARRAY_ELEM}+1`

return 0
}

## Function: read_storage_type ###
#
# Arguments:
#   none
# Return Values:
#   set varibale STORAGE_TYPE
read_storage_type()
{
# Read the storage type
if [ -s ${ENIQ_CONF_DIR}/${SUNOS_INI} ]; then
    STORAGE_TYPE=`iniget STOR_TYPE -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v STORAGE_TYPE`
else
    if [ -s ${ENIQ_CONF_DIR}/san_details ]; then
        STORAGE_TYPE=`$CAT ${ENIQ_CONF_DIR}/san_details | $EGREP "^STORAGE_TYPE=" | $AWK -F\= '{print $2}'`
    fi
fi

if [ ! "${STORAGE_TYPE}" ]; then
    _err_msg_="Could not read STORAGE_TYPE param "
    abort_script "$_err_msg_"
fi

# Store SAN device type
if [ "${STORAGE_TYPE}" == "raw" ]; then
    SAN_DEVICE=`$CAT ${ENIQ_CONF_DIR}/san_details |$EGREP SAN_DEVICE= |$CUT -d "=" -f2`
    if [ ! "${SAN_DEVICE}" ]; then
        _err_msg_="Could not get SAN_DEVICE from ${ENIQ_CONF_DIR}/san_details"
        abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
    fi
fi
}

### Function: resize_nas_sybase_iq ###
#
# To re-size NAS file system size for sybase_iq to of 5G
#
# Arguments:
#       none
# Return Values:
#       none
resize_nas_sybase_iq()
{
# Check resize_nas_fs.bsh is executable or not 
local _check_command_="${ENIQ_ADMIN_BIN_DIR}/resize_nas_fs.bsh"
check_for_file -s ${_check_command_}

# Resize NAS File System for SYBASE IQ
log_msg  -s "\nResizing NAS Sybase IQ File System to 5G " -l ${LOGFILE}
    
log_msg -q -s "\nStarting to run $BASH ${ENIQ_ADMIN_BIN_DIR}/resize_nas_fs.bsh -a auto -s 5g -f sybase_iq -N" -l ${LOGFILE}
$BASH ${ENIQ_ADMIN_BIN_DIR}/resize_nas_fs.bsh -a auto -s 5g -f sybase_iq -N 
if [ $? -ne 0 ]; then
    _err_msg_="NAS File System Resize for Sybase IQ failed. Please refer log file at ${RESIZE_NAS_LOGFILE_DIR}. \n"
    abort_script "$_err_msg_"
fi

RESIZE_NAS_IQ_LOGFILE=`$LS -at ${RESIZE_NAS_LOGFILE_DIR} | $GREP resize_nas | $HEAD -1`
log_msg -s  "\nSuccessfully Resized the NAS File System for Sybase IQ" -l ${LOGFILE}
log_msg -s "Please refer log file: ${RESIZE_NAS_LOGFILE_DIR}/${RESIZE_NAS_IQ_LOGFILE}" -l ${LOGFILE}
}

### Function: resize_nas_sw ###
#
# To re-size NAS file system size for /eniq/sw
#
# Arguments:
#       none
# Return Values:
#       none
resize_nas_sw()
{
local _check_command_="${ENIQ_ADMIN_BIN_DIR}/resize_nas_fs.bsh"
check_for_file -s ${_check_command_}

# Resize NAS File System for SW
log_msg -s  "\nResizing NAS /eniq/sw File System." -l ${LOGFILE} 
    
# Check the deployment of current blade
log_msg -s "Checking deployment type of current blade." -l ${LOGFILE} 
if [ ! "${DEPLOYMENT_TYPE}" ]; then
    _err_msg_="Could not determine deployment type."
    abort_script "$_err_msg_"
fi

log_msg -s "Deployment type of current blade: ${DEPLOYMENT_TYPE}." -l ${LOGFILE} 
if [ "${DEPLOYMENT_TYPE}" == "small" -o "${DEPLOYMENT_TYPE}" == "medium" -o "${DEPLOYMENT_TYPE}" == "large" -o "${DEPLOYMENT_TYPE}" == "extralarge" ]; then
    _new_nas_sw_size_=10g
fi

if [ "${DEPLOYMENT_TYPE}" == "ft" -o "${DEPLOYMENT_TYPE}" == "vm" ]; then
    _new_nas_sw_size_=6g
fi

log_msg -s "/eniq/sw file system needs to be resized to ${_new_nas_sw_size_}." -l ${LOGFILE} 

log_msg -q -s  "\nStarting to run $BASH ${ENIQ_ADMIN_BIN_DIR}/resize_nas_fs.bsh -a auto -s ${_new_nas_sw_size_} -f sw -N" -l ${LOGFILE}
$BASH ${ENIQ_ADMIN_BIN_DIR}/resize_nas_fs.bsh -a auto -s ${_new_nas_sw_size_} -f sw -N 
if [ $? -ne 0 ]; then
    _err_msg_="NAS File System Resize for SW failed.  Please refer log file at ${RESIZE_NAS_LOGFILE_DIR}. \n"
    abort_script "$_err_msg_"
fi

RESIZE_NAS_SW_LOGFILE=`$LS -at ${RESIZE_NAS_LOGFILE_DIR} | $GREP resize_nas | $HEAD -1`
log_msg -s  "\nSuccessfully Resized the NAS File System for SW." -l ${LOGFILE}
log_msg -s "Please refer log file: ${RESIZE_NAS_LOGFILE_DIR}/${RESIZE_NAS_SW_LOGFILE}. \n" -l ${LOGFILE}
}

### Function: resize_nas_fs ###
#
# To resize NAS Syabse iq and sw Filesystems.
#
# Function includes: delete snapshots, resize sybase iq, resize sw, 
#                      start roll snap service and start ENIQ servie
# Arguments:
#    none
# Return Values:
#     none
resize_nas_fs()
{
insert_header_footer head "Entering Upgrade stage - ${NEXT_STAGE} " ${LOGFILE}

if [ ! -f "${VAR_TMP_DIR}/resize_sw_required" -a ! -f "${VAR_TMP_DIR}/resize_iq_required" ]; then
    log_msg -s " Resizing NAS File Systems not required." -l ${LOGFILE}
    insert_header_footer foot "INFO: Skipping Upgrade stage - ${NEXT_STAGE} " ${LOGFILE} 
    set_next_stage `$EXPR ${ARRAY_ELEM}+1`
    return 0
fi

# Stop Roll Snap Service
stop_roll_snap

# Stop ENIQ Services
stop_services

if [ ${STAGE_QUIET} ]; then
        log_msg -s "INFO: Skipping deletion of rolling snapshots for non FT deployments" -l ${LOGFILE}
else
        # Delete Rolling Snapshots
        delete_rolling_snapshots
fi

# Resize NAS SW File System
if [ -f "${VAR_TMP_DIR}/resize_sw_required" ]; then 
    if [ "${CURR_SERVER_TYPE}" == "eniq_stats" -o "${CURR_SERVER_TYPE}" == "stats_coordinator"  ]; then
        resize_nas_sw
    else
        log_msg -s "INFO: Skipping Resize NAS SW File System for ${CURR_SERVER_TYPE}" ${LOGFILE}
    fi
fi
 
# Resize NAS Sybase IQ File System
if [ -f "${VAR_TMP_DIR}/resize_iq_required" ]; then 
    resize_nas_sybase_iq
fi

# Start Roll Snap Service
start_roll_snap

# Start ENIQ Services
start_services

# Remove temporary files
$RM -rf ${VAR_TMP_DIR}/resize_sw_required
$RM -rf ${VAR_TMP_DIR}/resize_iq_required

insert_header_footer foot "Successfully completed Upgrade Stage - ${NEXT_STAGE}." ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}


### Function: get_active_snapshot ###
#
# To get active snapshot name.
#
# Arguments:
#    none
# Return Values:
#     none
get_active_snapshot()
{
insert_header_footer head "Entering Rollback stage - ${NEXT_STAGE}" ${LOGFILE}

if [ ! -s "${_deployed_servers_}" ]; then
    _err_msg_="Unable to retrieve deployed servers list.\n"
    abort_script "${_err_msg_}"
fi

_temp_rollback_conf_=${VAR_TMP_DIR}/rollback.conf.$$.$$
$RM -rf ${_temp_rollback_conf_}
$TOUCH ${_temp_rollback_conf_}

if [ -s ${SELECTED_SNAPSHOT} ]; then

    #Get fs snapshots label
    for _line_ in `$CAT ${_deployed_servers_}`; do
        unset _ip_address_ _serv_hostname_ _serv_type_ _count_
		local _ip_address_ _serv_hostname_ _serv_type_ _count_
	    _count_=`$ECHO "${_line_}" | grep -o "::" | wc -l`

	    if [ "${_ip_type_}" == "IPv6" ] && [ "${_count_}" == 3 ]; then
		    _ip_address_=`$ECHO ${_line_} | grep -oE '([a-fA-F0-9]{1,4}::?){1,7}[a-fA-F0-9]{1,4}' | head -n 1 | awk -F "::" '{ print $1 "::" $2}'`
			_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
			_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $4}'`
		else
			_ip_address_=`$ECHO ${_line_} | $AWK -F"::" '{print $1}'`
			_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $2}'`
			_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
		fi
        if [ ! "${_ip_address_}" -o ! "${_serv_hostname_}" -o ! "${_serv_type_}" ]; then
            _err_msg_="Unable to retrieve IP or hostname or server type.\n"
            abort_script "${_err_msg_}"
        fi
            get_snap_label fs
    done

    # Get san snapshots label
    if [ "${STORAGE_TYPE}" != "fs" ]; then
        get_snap_label san
    fi

    # Get nas snapshots label
    if [ "${STORAGE_TYPE}" != "fs" ]; then
        get_snap_label nas
    fi
    
    if [ ! "${ADMIN_UI}" ]; then
        $ECHO "\n------------------------------------------------------"
        $ECHO "Below are the snapshots created at the time of upgrade\n"
        $CAT ${_temp_rollback_conf_}
        $ECHO "\n------------------------------------------------------"
        user_confirmation
        if [ "${USER_CONF}" == "No" ]; then
            exit 0
        fi
    fi
else
    ask_label_from_user
fi

# Save the rollback_snap_label.conf
$CP ${_temp_rollback_conf_} ${ROLLBACK_SNAP_LABEL_CONF}
if [ $? -ne 0 ]; then
     _err_msg_="Unable to update ${ROLLBACK_SNAP_LABEL_CONF}"
    abort_script "${_err_msg_}"
fi
$RM -rf ${_temp_rollback_conf_}

for _line_ in `$CAT ${_deployed_servers_}`; do
        unset _ip_address_ _serv_hostname_ _serv_type_ _count_
		local _ip_address_ _serv_hostname_ _serv_type_ _count_
		_count_=`$ECHO "${_line_}" | grep -o "::" | wc -l`

		if [ "${_ip_type_}" == "IPv6" ] && [ "${_count_}" == 3 ]; then
			_ip_address_=`$ECHO ${_line_} | grep -oE '([a-fA-F0-9]{1,4}::?){1,7}[a-fA-F0-9]{1,4}' | head -n 1 | awk -F "::" '{ print $1 "::" $2}'`
			_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
			_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $4}'`
		else
			_ip_address_=`$ECHO ${_line_} | $AWK -F"::" '{print $1}'`
			_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $2}'`
			_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
		fi
        if [ ! "${_ip_address_}" -o ! "${_serv_hostname_}" -o ! "${_serv_type_}" ]; then
            _err_msg_="Unable to retrieve IP or hostname or server type.\n"
            abort_script "${_err_msg_}"
        fi
        _SNAP_LABEL_=`$CAT ${ROLLBACK_SNAP_LABEL_CONF} | $GREP "FS_SNAP_LABEL_${_serv_type_}" | $AWK -F '=' '{print $2}'`
        if [ -z "${_SNAP_LABEL_}" ]; then
            _err_msg_="Failed to get FS snapshot label on ${_serv_hostname_}"
            abort_script "$_err_msg_"
        else
            log_msg -t -l ${LOGFILE} -s "FS snapshots label is ${_SNAP_LABEL_} on ${_serv_hostname_}\n"
        fi
                
        if [ "${_ip_address_}" == "${HOST_IP}" ]; then
            $LVS -o lvname,snap_percent --noheadings | $GREP -w ${_SNAP_LABEL_} > ${TEM_DIR}/snapfs
            if [ ! -s ${TEM_DIR}/snapfs ]; then
                _err_msg_="Failed to get FS snapshot on ${_serv_hostname_}"
                abort_script "$_err_msg_"
            else
                while read line ; do
                    _snap_size_=`echo $line | awk '{print $2}'`
                    _snap_fs_=`echo $line | awk '{print $1}'`
                    if [ ${_snap_size_} == 100.00 ]; then
                        _err_msg_="Snapshot size has reached 100% for ${_snap_fs_}. Cannot rollback."
                        abort_script "$_err_msg_"
                    fi
                done < ${TEM_DIR}/snapfs
            fi
        else
            run_remote_cmd "${_serv_hostname_}" "$LVS -o lvname,snap_percent --noheadings | $GREP -w ${_SNAP_LABEL_}" > ${TEM_DIR}/snapfs
            if [ ! -s ${TEM_DIR}/snapfs ]; then
                _err_msg_="Failed to get FS snapshot on ${_serv_hostname_}"
                abort_script "$_err_msg_"
            else
                while read line ; do
                    _snap_size_=`echo $line | awk '{print $2}'`
                    _snap_fs_=`echo $line | awk '{print $1}'`
                    if [ ${_snap_size_} == 100.00 ]; then
                        _err_msg_="Snapshot size has reached 100% for ${_snap_fs_}. Cannot rollback."
                        abort_script "$_err_msg_"
                    fi
                done < ${TEM_DIR}/snapfs
            fi
           
        fi
        
done

insert_header_footer foot "Completed Stage - Get active snapshot label " ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: get_snap_label ###
#
# To get snap shot label.
#
# Arguments:
#    none
# Return Values:
#     none
get_snap_label()
{
if [ ! "$1" ]; then
  _err_msg_="Snapshot type not passed\n"
  abort_script "${_err_msg_}"
fi

_type_=$1
    
case ${_type_} in
fs) _fs_snap_label_=`$CAT ${SELECTED_SNAPSHOT} | $GREP ${_serv_hostname_} | $AWK -F":" '{print \$2}'`
     _param_to_update_="FS_SNAP_LABEL_${_serv_type_}"
     _param_value_=${_fs_snap_label_}
     ;;
san) _san_snap_label_=`$CAT ${SELECTED_SNAPSHOT} | $GREP ${HNAME} | $AWK -F":" '{print \$2}'`
     _param_to_update_="SAN_SNAP_LABEL"
     _param_value_=${_san_snap_label_}
     ;;
nas) _nas_snap_label_=`$CAT ${SELECTED_SNAPSHOT} | $GREP ${HNAME} | $AWK -F":" '{print \$2}'`
     _param_to_update_="NAS_SNAP_LABEL"
     _param_value_=${_nas_snap_label_}
     ;;
\?) $ECHO "Invalid type"
    usage_msg
    exit 1
    ;;
esac

set_conf_value "${_param_to_update_}" ${_param_value_} ${_temp_rollback_conf_}
}

### Function: ask_label_from_user ###
#
# To ask rollback snap label from user.
#
# Arguments:
#    none
# Return Values:
#     none
ask_label_from_user()
{
$RM -rf ${_temp_rollback_conf_}
_temp_rollback_conf_=${VAR_TMP_DIR}/rollback.conf.$$.$$
$TOUCH ${_temp_rollback_conf_}

if [ ! -s "${_deployed_servers_}" ]; then
    _err_msg_="Unable to retrieve deployed servers list.\n"
    abort_script "${_err_msg_}"
fi
#Get fs snapshots label
for _line_ in `$CAT ${_deployed_servers_}`; do
    unset _ip_address_ _serv_hostname_ _serv_type_ _count_
	local _ip_address_ _serv_hostname_ _serv_type_ _count_
	_count_=`$ECHO "${_line_}" | grep -o "::" | wc -l`

	if [ "${_ip_type_}" == "IPv6" ] && [ "${_count_}" == 3 ]; then
		_ip_address_=`$ECHO ${_line_} | grep -oE '([a-fA-F0-9]{1,4}::?){1,7}[a-fA-F0-9]{1,4}' | head -n 1 | awk -F "::" '{ print $1 "::" $2}'`
		_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
		_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $4}'`
	else
		_ip_address_=`$ECHO ${_line_} | $AWK -F"::" '{print $1}'`
		_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $2}'`
		_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
	fi
    if [ ! "${_ip_address_}" -o ! "${_serv_hostname_}" -o ! "${_serv_type_}" ]; then
        _err_msg_="Unable to retrieve IP or hostname or server type.\n"
        abort_script "${_err_msg_}"
    fi
    if [ "${_ip_address_}" == "${HOST_IP}" ]; then
        get_label fs
    else
        get_label fs $_serv_hostname_
    fi
done

# Get san snapshots label
if [ "${STORAGE_TYPE}" != "fs" ]; then
    get_label san
fi

# Get nas snapshots label
if [ "${STORAGE_TYPE}" != "fs" ]; then
    get_label nas
fi
}

### Function: rollback_fs_snapshot ###
#
# To rollback ZFS Filesystems.
#
# Arguments:
#    none
# Return Values:
#     none
rollback_fs_snapshot()
{
insert_header_footer head "Entering Rollback stage - ${NEXT_STAGE}" ${LOGFILE}

if [ -f ${VAR_TMP_DIR}/current_rollback_ui_stage ]; then
    $ECHO "ENIQ Services Stop" > ${VAR_TMP_DIR}/current_rollback_ui_stage 
fi

# Stop ENIQ Services
stop_services

if [ -f ${VAR_TMP_DIR}/current_rollback_ui_stage ]; then
    $ECHO "Rolling Back File System" > ${VAR_TMP_DIR}/current_rollback_ui_stage 
fi

if [ ! -s "${_deployed_servers_}" ]; then
    _err_msg_="Unable to retrieve deployed servers list.\n"
    abort_script "${_err_msg_}"
fi

for _line_ in `$CAT ${_deployed_servers_}`; do
    unset _ip_address_ _serv_hostname_ _serv_type_ _count_
	local _ip_address_ _serv_hostname_ _serv_type_ _count_
	_count_=`$ECHO "${_line_}" | grep -o "::" | wc -l`

	if [ "${_ip_type_}" == "IPv6" ] && [ "${_count_}" == 3 ]; then
		_ip_address_=`$ECHO ${_line_} | grep -oE '([a-fA-F0-9]{1,4}::?){1,7}[a-fA-F0-9]{1,4}' | head -n 1 | awk -F "::" '{ print $1 "::" $2}'`
		_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
		_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $4}'`
	else
		_ip_address_=`$ECHO ${_line_} | $AWK -F"::" '{print $1}'`
		_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $2}'`
		_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
	fi
    if [ ! "${_ip_address_}" -o ! "${_serv_hostname_}" -o ! "${_serv_type_}" ]; then
        _err_msg_="Unable to retrieve IP or hostname or server type.\n"
        abort_script "${_err_msg_}"
    fi
    local _SNAP_LABEL_=`$CAT ${ROLLBACK_SNAP_LABEL_CONF} | $GREP "FS_SNAP_LABEL_${_serv_type_}" | $AWK -F '=' '{print $2}'`
    if [ -z "${_SNAP_LABEL_}" ]; then
        _err_msg_="Failed to get FS snapshot label on ${_serv_hostname_}"
         abort_script "$_err_msg_"
    else
        log_msg -t -l ${LOGFILE} -s "FS snapshots label is ${_SNAP_LABEL_} on ${_serv_hostname_}\n"
    fi
    # If the IP found in the order file matches my IP, run locally
    if [ "${_ip_address_}" == "${HOST_IP}" ]; then
        if [ ! -f ${FS_ROLLBACK_SUCCESS} ]; then
            log_msg -t -l ${LOGFILE} -s "Rolling FS snapshots on ${HOST_NAME} with label ${_SNAP_LABEL_}"
            cd /
            $BASH ${ROLLBACK_TEMP_SW_BIN_DIR}/manage_fs_snapshots.bsh -a rollback -f ALL=${_SNAP_LABEL_} -N -F | $TEE -a ${LOGFILE}
            _rc_fs_=`$ECHO ${PIPESTATUS[0]}`
            if [ "${_rc_fs_}" -ne 0 ]; then
                _err_msg_="Failed to rollback FS snapshot with label \"${_SNAP_LABEL_}\" on ${HOST_NAME}"
                abort_script "$_err_msg_"
            else
                $TOUCH ${FS_ROLLBACK_SUCCESS}
                log_msg -t -s "Rolled back FS snapshot on ${HOST_NAME}\n" -l ${LOGFILE}
            fi
        else
            log_msg -t -s "Already rolled back FS snapshot on ${HOST_NAME}\n" -l ${LOGFILE}
        fi
    else
		if [ "${_user_root}" == 1 ]; then			
			run_remote_cmd "${_serv_hostname_}" "$LS ${FS_ROLLBACK_SUCCESS}" >> /dev/null 2>&1
			if [ $? -ne 0 ]; then
				log_msg -t -l ${LOGFILE} -s "Rolling FS snapshots on ${_serv_hostname_} with label ${_SNAP_LABEL_}"
				run_remote_cmd "${_serv_hostname_}" "cd /; $BASH ${ROLLBACK_TEMP_SW_BIN_DIR}/manage_fs_snapshots.bsh -a rollback -f ALL=${_SNAP_LABEL_} -N -F"
				if [ $? -ne 0 ]; then
					abort_script "Failed to rollback FS snapshot with label \"${_SNAP_LABEL_}\" on ${_serv_hostname_}."
				else
					run_remote_cmd "${_serv_hostname_}" "$TOUCH ${FS_ROLLBACK_SUCCESS}"
					log_msg -t -s "Rolled back FS snapshot on ${_serv_hostname_}\n" -l ${LOGFILE}
				fi
			else
				log_msg -t -s "Already rolled back FS snapshot on ${_serv_hostname_}\n" -l ${LOGFILE}
			fi 
		else
			run_remote_cmd "${_serv_hostname_}" "$SUDO $LS ${FS_ROLLBACK_SUCCESS}" "" "$_get_id_" >> /dev/null 2>&1
			if [ $? -ne 0 ]; then
				log_msg -t -l ${LOGFILE} -s "Rolling FS snapshots on ${_serv_hostname_} with label ${_SNAP_LABEL_}"
				run_remote_cmd "${_serv_hostname_}" "cd /; $BASH ${ROLLBACK_TEMP_SW_BIN_DIR}/manage_fs_snapshots.bsh -a rollback -f ALL=${_SNAP_LABEL_} -N -F" 
				if [ $? -ne 0 ]; then
					abort_script "Failed to rollback FS snapshot with label \"${_SNAP_LABEL_}\" on ${_serv_hostname_}."
				else
					run_remote_cmd "${_serv_hostname_}" "$SUDO $TOUCH ${FS_ROLLBACK_SUCCESS}" "" "$_get_id_"
					log_msg -t -s "Rolled back FS snapshot on ${_serv_hostname_}\n" -l ${LOGFILE}
				fi
			else
				log_msg -t -s "Already rolled back FS snapshot on ${_serv_hostname_}\n" -l ${LOGFILE}
			fi
		fi 
    fi
done


insert_header_footer foot "Completed Stage - rolled back FS snapshot " ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: rollback_nas_snapshot ###
#
# To rollback NAS Filesystems.
#
# Arguments:
#    none
# Return Values:
#     none
rollback_nas_snapshot()
{
insert_header_footer head "Entering Rollback stage - ${NEXT_STAGE}" ${LOGFILE}

if [ "${STORAGE_TYPE}" == "fs" ]; then
    insert_header_footer foot "INFO: Skipping Rollback Stage - ${NEXT_STAGE} for Rack" ${LOGFILE} 
    set_next_stage `$EXPR ${ARRAY_ELEM}+1`
    return 0
fi

if [ ! -s "${_deployed_servers_}" ]; then
    _err_msg_="Unable to retrieve deployed servers list.\n"
    abort_script "${_err_msg_}"
fi

 #Disable the NAS Services
 for _line_ in `$CAT ${_deployed_servers_}`; do
    unset _ip_address_ _serv_hostname_ _serv_type_ _count_
	local _ip_address_ _serv_hostname_ _serv_type_ _count_
	_count_=`$ECHO "${_line_}" | grep -o "::" | wc -l`

	if [ "${_ip_type_}" == "IPv6" ] && [ "${_count_}" == 3 ]; then
		_ip_address_=`$ECHO ${_line_} | grep -oE '([a-fA-F0-9]{1,4}::?){1,7}[a-fA-F0-9]{1,4}' | head -n 1 | awk -F "::" '{ print $1 "::" $2}'`
		_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
		_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $4}'`
	else
		_ip_address_=`$ECHO ${_line_} | $AWK -F"::" '{print $1}'`
		_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $2}'`
		_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
	fi
     if [ ! "${_ip_address_}" -o ! "${_serv_hostname_}" -o ! "${_serv_type_}" ]; then
         _err_msg_="Unable to retrieve IP or hostname or server type.\n"
         abort_script "${_err_msg_}"
     fi
    
     # If the IP found in the order file matches my IP, run locally
     if [ "${_ip_address_}" == "${HOST_IP}" ]; then
         log_msg -t -l ${LOGFILE} -s "Disabling NAS services on ${HOST_NAME}"
         cd /
         $SYSTEMCTL stop NASd.service
         _service_state=`$SYSTEMCTL show NASd.service -p ActiveState | $AWK -F"=" '{print $2}'`
         if [ "${_service_state}" == "active" ] ; then
           _err_msg_="Could not disable NAd.service"
           abort_script "$_err_msg_"
         fi
         log_msg -t -s "Disabled NAS services on ${HOST_NAME}\n" -l ${LOGFILE}
     else
         log_msg -t -s "Disabling NAS services on ${_serv_hostname_}" -l ${LOGFILE}
         if [ "${_user_root}" == 1 ]; then			
			run_remote_cmd "${_serv_hostname_}" "cd /; $SYSTEMCTL stop NASd.service" >> /dev/null 2>&1
			_service_state=$(run_remote_cmd "${_serv_hostname_}" "cd /;$SYSTEMCTL show NASd.service -p ActiveState | $AWK  '{print }'" "" "$_get_id_")
		 else
			run_remote_cmd "${_serv_hostname_}" "cd /; $SUDO $SYSTEMCTL stop NASd.service" >> /dev/null 2>&1
			_service_state=$(run_remote_cmd "${_serv_hostname_}" "cd /;$SUDO $SYSTEMCTL show NASd.service -p ActiveState | $AWK  '{print }'" "" "$_get_id_")
		 fi 
         _service_final_state=`$ECHO "${_service_state}" | $TR -d "\r" | $TR -d "$" | $AWK -F"=" '{print $2}'`
         if [ "${_service_final_state}" == "active" ] ; then
           _err_msg_="Could not disable NAd.service"
           abort_script "$_err_msg_"
         fi
         log_msg -t -s "Disabled NAS services on ${_serv_hostname_}\n" -l ${LOGFILE}
     fi
 done

local _SNAP_LABEL_=`$CAT ${ROLLBACK_SNAP_LABEL_CONF} | $GREP "NAS_SNAP_LABEL" | $AWK -F '=' '{print $2}'`
if [ -z "${_SNAP_LABEL_}" ]; then
    _err_msg_="Failed to get NAS snapshot label on ${HOST_NAME}"
    abort_script "$_err_msg_"
else
    log_msg -t -l ${LOGFILE} -s "NAS snapshots label is ${_SNAP_LABEL_} on ${HOST_NAME}\n"
fi

if [ ! -f ${NAS_ROLLBACK_SUCCESS} ]; then
    log_msg -t -l ${LOGFILE} -s "Rolling NAS snapshots with label ${_SNAP_LABEL_} on ${HOST_NAME}"
    cd /
    $BASH ${ROLLBACK_TEMP_SW_BIN_DIR}/manage_nas_snapshots.bsh -a rollback -f ALL -n ${_SNAP_LABEL_} -N | $TEE -a ${LOGFILE}
    _rc_nas_=`$ECHO ${PIPESTATUS[0]}`
    if [ "${_rc_nas_}" -ne 0 ]; then
        _err_msg_="Failed to rollback NAS snapshot with label \"${_SNAP_LABEL_}\""
        abort_script "$_err_msg_"
    else
        $TOUCH ${NAS_ROLLBACK_SUCCESS}
    fi
else
    log_msg -t -s "Already rolled back NAS snapshot on ${HOST_NAME}\n" -l ${LOGFILE}
fi

 #Enable the NAS Services
 for _line_ in `$CAT ${_deployed_servers_}`; do
    unset _ip_address_ _serv_hostname_ _serv_type_ _count_
	local _ip_address_ _serv_hostname_ _serv_type_ _count_
	_count_=`$ECHO "${_line_}" | grep -o "::" | wc -l`

	if [ "${_ip_type_}" == "IPv6" ] && [ "${_count_}" == 3 ]; then
		_ip_address_=`$ECHO ${_line_} | grep -oE '([a-fA-F0-9]{1,4}::?){1,7}[a-fA-F0-9]{1,4}' | head -n 1 | awk -F "::" '{ print $1 "::" $2}'`
		_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
		_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $4}'`
	else
		_ip_address_=`$ECHO ${_line_} | $AWK -F"::" '{print $1}'`
		_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $2}'`
		_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
	fi
     if [ ! "${_ip_address_}" -o ! "${_serv_hostname_}" -o ! "${_serv_type_}" ]; then
         _err_msg_="Unable to retrieve IP or hostname or server type.\n"
         abort_script "${_err_msg_}"
     fi
    
     # If the IP found in the order file matches my IP, run locally
     if [ "${_ip_address_}" == "${HOST_IP}" ]; then
         log_msg -t -l ${LOGFILE} -s "Enabling NAS services on ${HOST_NAME}"
         $SYSTEMCTL start NASd.service
         $SLEEP 15
         while true;
         do
             _service_status_=`$SYSTEMCTL show -p ActiveState NAS-online | $AWK -F= '{print $2}'`
             if [ "${_service_status_}" != "active" ];then
               $SLEEP 15
               continue
             else    
               log_msg -t -s "Enabled NAS services on ${HOST_NAME}\n" -l ${LOGFILE}
               break
             fi
         done 
            
     else
         log_msg -t -s "Enabling NAS services on ${_serv_hostname_}" -l ${LOGFILE}
         run_remote_cmd "${_serv_hostname_}" "$SYSTEMCTL start NASd.service"
         $SLEEP 15
         while true;
         do
             _service_status_=`run_remote_cmd "${_serv_hostname_}" "$SYSTEMCTL show -p ActiveState NAS-online | $AWK -F= '{print }' "`
             _service_final_state=`$ECHO "${_service_status_}" | $TR -d "\r" | $TR -d "$" | $AWK -F"=" '{print $2}'`
             if [ "${_service_final_state}" != "active" ];then
               $SLEEP 15
               continue
             else    
               log_msg -t -s "Enabled NAS services on ${_serv_hostname_}\n" -l ${LOGFILE}
               break
             fi
         done 
            
     fi
 done

_sentinel_smf_str_=`iniget SENTINEL -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v SENTINEL_SYSTEMD_STR`
sentinel_state_=`$SYSTEMCTL show ${_sentinel_smf_str_} -p ActiveState | $AWK -F "=" '{print $2}'`
if [ ${sentinel_state_} != "active" ]; then
    $SYSTEMCTL reset-failed ${_sentinel_smf_str_} >> /dev/null 2>&1
    $SYSTEMCTL start ${_sentinel_smf_str_}
    $SYSTEMCTL enable ${_sentinel_smf_str_}

    if [ $? -ne 0 ]; then
        _err_msg_="sentinel service failed to enable"
        abort_script "${_err_msg_}"
    fi
    _sentinel_state_recheck_=`$SYSTEMCTL show ${_sentinel_smf_str_} -p ActiveState | $AWK -F "=" '{print $2}'`
    if [ ${_sentinel_state_recheck_} == "active" ]; then
        $ECHO "sentinel service has been successfully enabled"
    fi 
fi
#Remove Newly Created NAS File systems
if [ "${rollback_type_flag}" != 1 ]; then
local _manage_storage_fs_script_="${TMPL_ADMIN_BIN_DIR}/manage_storage_fs.bsh"
else
    local _manage_storage_fs_script_="${TEMPLATES_ADMIN_BIN_DIR}/manage_storage_fs.bsh"
fi
check_for_file -s ${_manage_storage_fs_script_}

log_msg -q -s "Starting to run $BASH ${_manage_storage_fs_script_} -r ${ENIQ_INST_DIR}" -l ${LOGFILE}
$BASH ${_manage_storage_fs_script_} -r ${ENIQ_INST_DIR} | $TEE -a ${LOGFILE}
_rc_storage_=`$ECHO ${PIPESTATUS[0]}`
if [ "${_rc_storage_}" -ne 0 ]; then
    _err_msg_="Exiting... Unable to remove newly created NAS file systems \n"
    abort_script "$_err_msg_"
fi

insert_header_footer foot "Completed Stage - rolled back NAS snapshot " ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: rollback_san_snapshot ###
#
# To rollback SAN Filesystems.
#
# Arguments:
#    none
# Return Values:
#     none
rollback_san_snapshot()
{
insert_header_footer head "Entering Rollback stage - ${NEXT_STAGE}" ${LOGFILE}

if [ "${STORAGE_TYPE}" == "fs" ]; then
    insert_header_footer foot "INFO: Skipping Rollback Stage - ${NEXT_STAGE} for Rack" ${LOGFILE} 
    set_next_stage `$EXPR ${ARRAY_ELEM}+1`
    return 0
fi

local _SNAP_LABEL_=`$CAT ${ROLLBACK_SNAP_LABEL_CONF} | $GREP "SAN_SNAP_LABEL" | $AWK -F '=' '{print $2}'`
if [ -z "${_SNAP_LABEL_}" ]; then
    _err_msg_="Failed to get SAN snapshot label on ${HOST_NAME}"
    abort_script "$_err_msg_"
else
    log_msg -t -l ${LOGFILE} -s "SAN snapshots label is ${_SNAP_LABEL_} on ${HOST_NAME}\n"
fi

if [ ! -f ${SAN_ROLLBACK_SUCCESS} ]; then
    log_msg -t -l ${LOGFILE} -s "Rolling SAN snapshots with label ${_SNAP_LABEL_} on ${HOST_NAME}"
    cd /
    $BASH ${ROLLBACK_TEMP_SW_BIN_DIR}/manage_san_snapshots.bsh -a rollback -f ALL -n ${_SNAP_LABEL_} -N | $TEE -a ${LOGFILE}
    _rc_san_=`$ECHO ${PIPESTATUS[0]}`
    if [ "${_rc_san_}" -ne 0 ]; then
        _err_msg_="Failed to rollback SAN snapshot with label \"${_SNAP_LABEL_}\""
        abort_script "$_err_msg_"
    else
        $TOUCH ${SAN_ROLLBACK_SUCCESS}
    fi
else
    log_msg -t -s "Already rolled back SAN snapshot on ${HOST_NAME}\n" -l ${LOGFILE}
fi

insert_header_footer foot "Completed Stage - rolled back SAN snapshot " ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: rollback_repdb_password ###
#
# To change repdb users password stored in repdb back to old.
#
# Arguments:
#    _revert_user_ : user for which password failed
# Return Values:
#     none
rollback_repdb_password()
{
local CLI_CONF_DIR=/eniq/sw/conf
local ENIQ_INI=niq.ini
local ENIQ_CONF_DIR=/eniq/installation/config
local ENIQ_SW_PF_DIR=/eniq/sw/platform
local ENIQ_SW=/eniq/sw
local _sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/SunOS.ini -v ENIQ_SYSUSER`
_revert_user_=$1
if [ ! $1 ]; then
    _err_msg_="Failed to get the $1"
    abort_script "$_err_msg_"
fi

R_STATE=`$CAT ${ENIQ_SW}/installer/versiondb.properties | $GREP -w repository | $AWK -F "=" '{print $2}'`


#Getting old and new password again
revert_dwhrep_pass=`$CAT ${CLI_CONF_DIR}/.repdb_user_password_change | ${GREP} -w "OLD_DWHREP_PASSWORD" | $AWK -F ":" '{print $2}'`
revert_etlrep_pass=`$CAT ${CLI_CONF_DIR}/.repdb_user_password_change | ${GREP} -w "OLD_ETLREP_PASSWORD" | $AWK -F ":" '{print $2}'`
decrypt_revert_dwhrep_pass=`$ECHO ${revert_dwhrep_pass} | openssl enc -base64 -d`
decrypt_revert_etlrep_pass=`$ECHO ${revert_etlrep_pass} | openssl enc -base64 -d`

revert_dwhrep_failed_pass=`$CAT ${CLI_CONF_DIR}/.repdb_user_password_change | ${GREP} -w "NEW_DWHREP_PASSWORD" | $AWK -F ":" '{print $2}'`
revert_etlrep_failed_pass=`$CAT ${CLI_CONF_DIR}/.repdb_user_password_change | ${GREP} -w "NEW_ETLREP_PASSWORD" | $AWK -F ":" '{print $2}'`
decrypt_revert_dwhrep_failed_pass=`$ECHO ${revert_dwhrep_failed_pass} | openssl enc -base64 -d`
decrypt_revert_etlrep_failed_pass=`$ECHO ${revert_etlrep_failed_pass} | openssl enc -base64 -d`


#Reverting the password as per user specific failure
if [ "${_revert_user_}" == "dwhrep" ];then
    #Only dwhrep password fail to set for login, hence updating old passwd in repdb meta_databases for dwhrep
    $SU - ${_sysuser_} -c "$BASH ${ENIQ_SW_PF_DIR}/repository-${R_STATE}/bin/ChangeUserPasswordsInRepdb -u ${_revert_user_} -o ${decrypt_revert_dwhrep_failed_pass} -p ${decrypt_revert_dwhrep_pass} -r ${decrypt_revert_dwhrep_pass}"
    if [ $? -ne 0 ]; then
        _err_msg_="Failed to set password of ${_for_user_} in REPDB meta.database"
        abort_script "$_err_msg_"
    fi
    log_msg -s "Successfully reverted ${_revert_user_} password in Repdb" -l ${LOGFILE}
elif [ "${_revert_user_}" == "etlrep" ];then
    #dwhrep execution is successfull and only etlrep password fail to set for login.

    #reverting ETLCServer file backup for reexecution process
    $SU - ${_sysuser_} -c "$CP ${CLI_CONF_DIR}/ETLCServer.properties_bkp ${CLI_CONF_DIR}/ETLCServer.properties"

    #reverting old in repdb meta_databases for etlrep
    $SU - ${_sysuser_} -c "$BASH ${ENIQ_SW_PF_DIR}/repository-${R_STATE}/bin/ChangeUserPasswordsInRepdb -u ${_revert_user_} -o ${decrypt_revert_etlrep_failed_pass} -p ${decrypt_revert_etlrep_pass} -r ${decrypt_revert_etlrep_pass}"
    if [ $? -ne 0 ]; then
        _err_msg_="Failed to set password of ${_for_user_} in REPDB meta.database"
        abort_script "$_err_msg_"
    fi

    #As dwhrep execution is successfull, reverting password in meta_databases for dwhrep
    $SU - ${_sysuser_} -c "$BASH ${ENIQ_SW_PF_DIR}/repository-${R_STATE}/bin/ChangeUserPasswordsInRepdb -u dwhrep -o ${decrypt_revert_dwhrep_failed_pass} -p ${decrypt_revert_dwhrep_pass} -r ${decrypt_revert_dwhrep_pass}"
    if [ $? -ne 0 ]; then

        _err_msg_="Failed to set password of ${_for_user_} in REPDB meta.database"
        abort_script "$_err_msg_"
    fi

    #As dwhrep execution is successfull, reverting password in database login for dwhrep

    $SU - ${_sysuser_} -c "$DBISQL -nogui -onerror exit @${DWH_CONN_STR_FOR_REPDB_USER_DBA_ENC} \"ALTER USER dwhrep IDENTIFIED BY '${decrypt_revert_dwhrep_pass}';\"" 2>>${LOGFILE} 1>/dev/null
    if [ $? -ne 0 ]; then
        _err_msg_="Failed to rollback password for dwhrep"
        abort_script "$_err_msg_"
    fi

    log_msg -s "Successfully reverted ${_revert_user_} and dwhrep password in Repdb" -l ${LOGFILE}
fi


${RM} -rf ${CLI_CONF_DIR}/.repdb_user_password_change
${RM} -rf ${CLI_CONF_DIR}/ETLCServer.properties_bkp

}

### Function: restore_repository_database ###
#
# To restore the repository database.
#
# Arguments:
#    none
# Return Values:
#     none
restore_repository_database()
{
insert_header_footer head "Entering Rollback stage - ${NEXT_STAGE}" ${LOGFILE}

if [ "${STORAGE_TYPE}" == "fs" ]; then
    insert_header_footer foot "INFO: Skipping Rollback Stage - ${NEXT_STAGE} for Rack" ${LOGFILE} 
    set_next_stage `$EXPR ${ARRAY_ELEM}+1`
    return 0
fi

if [ -f ${VAR_TMP_DIR}/current_rollback_ui_stage ]; then
    $ECHO "Rolling Back Database" > ${VAR_TMP_DIR}/current_rollback_ui_stage 
fi

local _repdb_restore_script_="${ENIQ_BKUP_SW_BIN_DIR}/repdb_restore.bsh"
check_for_file -s ${_repdb_restore_script_}

log_msg -q -s "Starting to run $SU - ${_sysuser_} -c "\"$BASH ${_repdb_restore_script_} -c ${CLI_CONF_DIR}"\"" -l ${LOGFILE}
$SU - ${_sysuser_} -c "$BASH ${_repdb_restore_script_} -c ${CLI_CONF_DIR}" | $TEE -a ${LOGFILE}
_rc_repdb_=`$ECHO ${PIPESTATUS[0]}`
if [ "${_rc_repdb_}" -ne 0 ]; then
    _err_msg_="Exiting... Unable to restore the repository database \n"
    abort_script "$_err_msg_"
fi

insert_header_footer foot "Completed Stage - successfully restored the repository database " ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: restore_dwhdb_database ###
#
# To restore the dwhdb database.
#
# Arguments:
#    none
# Return Values:
#     none
restore_dwhdb_database()
{
insert_header_footer head "Entering Rollback stage - ${NEXT_STAGE}" ${LOGFILE}

if [ "${STORAGE_TYPE}" == "fs" ]; then
    insert_header_footer foot "INFO: Skipping Rollback Stage - ${NEXT_STAGE} for Rack" ${LOGFILE} 
    set_next_stage `$EXPR ${ARRAY_ELEM}+1`
    return 0
fi

#Enable the NAS Services
log_msg -t -l ${LOGFILE} -s "Enabling NAS services"
$SYSTEMCTL start NASd.service
$SLEEP 15
while true;
do
    _service_status_=`$SYSTEMCTL show -p ActiveState NAS-online | $AWK -F= '{print $2}'`
    if [ "${_service_status_}" != "active" ];then
        $SLEEP 15
        continue
    else    
        log_msg -t -s "Enabled NAS services on ${HOST_NAME}\n" -l ${LOGFILE}
        break
    fi
done 

local _recover_iq_script_="${ENIQ_BKUP_SW_BIN_DIR}/recover_iq.bsh"
check_for_file -s ${_recover_iq_script_}

log_msg -q -s "Starting to run $BASH ${_recover_iq_script_} -N" -l ${LOGFILE}
$BASH ${_recover_iq_script_} -N | $TEE -a ${LOGFILE}
_rc_recover_=`$ECHO ${PIPESTATUS[0]}`
if [ "${_rc_recover_}" -ne 0 ]; then
    _err_msg_="Exiting... Unable to restore the dwhdb database \n"
    abort_script "$_err_msg_"
fi

insert_header_footer foot "Completed Stage - successfully restored the dwhdb database " ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: enable_rolling_snapshot ###
#
# To start rolling snapshot service.
#
# Arguments:
#    none
# Return Values:
#     none
enable_rolling_snapshot()
{
insert_header_footer head "Entering Rollback stage - ${NEXT_STAGE}" ${LOGFILE}

if [ -f ${VAR_TMP_DIR}/current_rollback_ui_stage ]; then
    $ECHO "ENIQ Services Start" > ${VAR_TMP_DIR}/current_rollback_ui_stage 
fi

# Stop ENIQ Services
stop_services

# Start ENIQ Services
start_services

if [ -f ${VAR_TMP_DIR}/current_rollback_ui_stage ]; then
    $ECHO "Enable Rolling Snapshot" > ${VAR_TMP_DIR}/current_rollback_ui_stage 
fi

# Enable DDC SMF if rack
if [ "${STORAGE_TYPE}" == "fs" ]; then
    log_msg -t -l ${LOGFILE} -s "Enabling DDC service on ${HOST_NAME}"
    $SYSTEMCTL start ${DDC_SMF_ID}
    if [ $? -ne 0 ]; then
        _err_msg_="Could not enable ${DDC_SMF_ID}"
        abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
    else
    log_msg -t -s "Enabled DDC service on ${HOST_NAME}\n" -l ${LOGFILE}
    fi  
fi

# Start Roll Snap Service
start_roll_snap

insert_header_footer foot "Completed Stage - successfully enabled rolling snapshot service " ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: post_rollback ###
#
# Post configuration after running rollback stages.
#
# Arguments:
#    none
# Return Values:
#     none
post_rollback()
{
insert_header_footer head "Entering Rollback stage - ${NEXT_STAGE}" ${LOGFILE}

if [ -f ${VAR_TMP_DIR}/current_rollback_ui_stage ]; then
    $ECHO "Post Rollback" > ${VAR_TMP_DIR}/current_rollback_ui_stage 
fi

local _post_rollback_script_="${SW_INSTALLER_DIR}/post_rollback.bsh"
check_for_file -s ${_post_rollback_script_}

log_msg -q -s "Starting to run $SU - ${_sysuser_} -c "\"$BASH ${_post_rollback_script_}"\"" -l ${LOGFILE}
$SU - ${_sysuser_} -c "$BASH ${_post_rollback_script_}" | $TEE -a ${LOGFILE}
_rc_rollback_=`$ECHO ${PIPESTATUS[0]}`
if [ "${_rc_rollback_}" -ne 0 ]; then
    _err_msg_="Exiting... Unable to run post_rollback.bsh \n"
    abort_script "$_err_msg_"
fi

#Input Data Regeneration
if [ "${rollback_type_flag}" != 2 ]; then
    if [ -f ${ENIQ_LOG_DIR}/.dtrace_enabled ]; then
        if [ ! -s "${_deployed_servers_}" ]; then
            _err_msg_="Unable to retrieve deployed servers list.\n"
            abort_script "${_err_msg_}"
        fi
        if [ ! -d "${ENIQ_LOG_DIR}"/Dtrace ]; then
            $SU - dcuser -c  "${MKDIR} -p ${ENIQ_LOG_DIR}/Dtrace"
            _dtrace_dir_exe_status_=$?
            if [ "${_dtrace_dir_exe_status_}" -ne 0 ]; then
                _err_msg_="Failed to create Dtrace directory on the Co-ordinator.\n"
                abort_script "${_err_msg_}"
            fi
        fi
        $SU - dcuser -c "$CP ${ENIQ_ADMIN_BIN_DIR}/manage_dtrace.bsh ${ENIQ_LOG_DIR}/Dtrace/"
        _dtrace_cp_exe_status_=$?
        if [ "${_dtrace_cp_exe_status_}" -ne 0 ]; then
            _err_msg_="Failed to copy script manage_dtrace.bsh on the Co-ordinator from ${ENIQ_ADMIN_BIN_DIR}.\n"
            abort_script "${_err_msg_}"
        fi
        for _line_ in `$EGREP -i 'engine|eniq_stats' ${_deployed_servers_}`; do
            unset _ip_address_ _serv_hostname_ _serv_type_ _count_
			local _ip_address_ _serv_hostname_ _serv_type_ _count_
			_count_=`$ECHO "${_line_}" | grep -o "::" | wc -l`

			if [ "${_ip_type_}" == "IPv6" ] && [ "${_count_}" == 3 ]; then
				_ip_address_=`$ECHO ${_line_} | grep -oE '([a-fA-F0-9]{1,4}::?){1,7}[a-fA-F0-9]{1,4}' | head -n 1 | awk -F "::" '{ print $1 "::" $2}'`
				_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
				_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $4}'`
			else
				_ip_address_=`$ECHO ${_line_} | $AWK -F"::" '{print $1}'`
				_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $2}'`
				_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
			fi
            if [ ! "${_ip_address_}" -o ! "${_serv_hostname_}" -o ! "${_serv_type_}" ]; then
                _err_msg_="Unable to retrieve IP or hostname or server type.\n"
                abort_script "${_err_msg_}"
            fi

            # If the IP found in the order file matches my IP, run locally
            if [ "${_ip_address_}" == "${HOST_IP}" ]; then
                log_msg -t -l ${LOGFILE} -s "Checking if Dtrace directory exists on ${HOST_NAME}"
                if [ -d ${ENIQ_LOG_DIR}/Dtrace ]; then
                    local _manage_dtrace_script_="${ENIQ_LOG_DIR}/Dtrace/manage_dtrace.bsh"
                    check_for_file -s ${_manage_dtrace_script_}
                    log_msg -q -s "Starting to run $BASH ${_manage_dtrace_script_} -a regenerate" -l ${LOGFILE}
                    $BASH ${_manage_dtrace_script_} -a regenerate | $TEE -a ${LOGFILE}
                    _rc_dtrace_=`$ECHO ${PIPESTATUS[0]}`
                    if [ "${_rc_dtrace_}" -ne 0 ]; then
                        _err_msg_="Exiting... Unable to regenerate input data \n"
                        abort_script "$_err_msg_"
						else
						log_msg -t -l ${LOGFILE} -s "Input data regeneration Completed Successfully"
						if [ $flag == 'No' ]; then 
							log_msg -t -l ${LOGFILE} -s "Starting Dtrace Cleanup."
							$BASH ${_manage_dtrace_script_} -a cleanup | $TEE -a ${LOGFILE}
							st_cleanup_dtrace=`$ECHO ${PIPESTATUS[0]}`
							if [ "${st_cleanup_dtrace}" -ne 0 ]; then
								err_msg_="Exiting... Unable to cleanup \n"
								abort_script "$_err_msg_"
							else
								log_msg -t -l ${LOGFILE} -s "Completed Dtrace Cleanup Successfully\n" 
							fi
						fi
					fi
                else
                    log_msg -t -s "Warning : Dtrace directory does not exist on ${HOST_NAME}\n" -l ${LOGFILE}
                fi
            else
                log_msg -t -s "Checking if Dtrace directory exists on ${_serv_hostname_}" -l ${LOGFILE}
                run_remote_cmd "${_serv_hostname_}" "$LS -l ${ENIQ_LOG_DIR}/Dtrace >> /dev/null 2>&1"
                if [ $? -ne 0 ]; then
                    log_msg -t -s "Warning: Dtrace directory does not exist on ${_serv_hostname_}\n" -l ${LOGFILE}
                else
                    local _manage_dtrace_script_="${ENIQ_LOG_DIR}/Dtrace/manage_dtrace.bsh"
                    check_for_file -s ${_manage_dtrace_script_}
                    log_msg -q -s "Starting to run $BASH ${_manage_dtrace_script_} -a regenerate" -l ${LOGFILE}
                    $BASH ${_manage_dtrace_script_} -a regenerate | $TEE -a ${LOGFILE}
                    _rc_manage_dtrace_=`$ECHO ${PIPESTATUS[0]}`
                    if [ "${_rc_manage_dtrace_}" -ne 0 ]; then
                        _err_msg_="Exiting... Unable to regenerate input data \n"
                        abort_script "$_err_msg_"
						else
						log_msg -t -l ${LOGFILE} -s "Input data regeneration Completed Successfully"
						if [ $flag == 'No' ]; then 
							log_msg -t -l ${LOGFILE} -s "Starting Dtrace Cleanup."
							$BASH ${_manage_dtrace_script_} -a cleanup | $TEE -a ${LOGFILE}
							st_cleanup_dtrace=`$ECHO ${PIPESTATUS[0]}`
							if [ "${st_cleanup_dtrace}" -ne 0 ]; then
								err_msg_="Exiting... Unable to cleanup \n"
								abort_script "$_err_msg_"
							else
								log_msg -t -l ${LOGFILE} -s "Completed Dtrace Cleanup Successfully\n" 
							fi
						fi
					fi
                fi
            fi
        done
    fi
fi

insert_header_footer foot "Completed Stage - successfully completed post rollback procedure " ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}





### Function: get_label ###
#
# To get snap shot label.
#
# Arguments:
#    none
# Return Values:
#     none
get_label()
{
if [ ! "$1" ]; then
  _err_msg_="Snapshot type not passed\n"
  abort_script "${_err_msg_}"
fi

if [ "$2" ]; then
    local _hostname_=$2
fi

_type_=$1
_run_list_cmd_="$BASH ${ROLLBACK_TEMP_SW_BIN_DIR}/manage_${_type_}_snapshots.bsh -a list -f ALL"

while [ 1 ]; do
    if [ ! -f "${VAR_TMP_DIR}/snap_list" ]; then
        $TOUCH ${VAR_TMP_DIR}/snap_list
        if [ $? -ne 0 ]; then
            _err_msg_="Could not make snap list file"
            abort_script "$_err_msg_"
        fi
    fi

    if [ ${_hostname_} ]; then
       if [ "${_user_root}" == 1 ]; then			
			run_remote_cmd "${_hostname_}" "${_run_list_cmd_}" > ${VAR_TMP_DIR}/snap_list
			if [ $? -ne 0 ]; then
				_err_msg_="Unable to update ${VAR_TMP_DIR}/snap_list"
				abort_script "${_err_msg_}"
			fi
		else
			run_remote_cmd "${_hostname_}" "$SUDO ${_run_list_cmd_}" "" "$_get_id_" > ${VAR_TMP_DIR}/snap_list
			if [ $? -ne 0 ]; then
				_err_msg_="Unable to update ${VAR_TMP_DIR}/snap_list"
				abort_script "${_err_msg_}"
			fi
		fi 
    else
        ${_run_list_cmd_} > ${VAR_TMP_DIR}/snap_list
        if [ $? -ne 0 ]; then
            _err_msg_="Unable to update ${VAR_TMP_DIR}/snap_list"
            abort_script "${_err_msg_}"
        fi
    fi
    
    case ${_type_} in
      fs) _snap_list_=`$CAT ${VAR_TMP_DIR}/snap_list | $AWK '{print \$2}' | $AWK -F"-" '{print $2}' | $SORT -u | $GREP -v '^$'`
           _param_to_update_="FS_SNAP_LABEL_${_serv_type_}"
           _message_to_display_="Listing available ${_type_} snap shot label on ${_serv_hostname_}"
           ;;
      san) if [ "${SAN_DEVICE}" == "vnx" ]; then
                _snap_list_=`$CAT ${VAR_TMP_DIR}/snap_list | $AWK '{print \$2}' | $GREP -v '^$' | $GREP [a-z0-9-]*@[0-9]*@[a-z0-9]*| $AWK -F'@' '{print \$NF}' | $SORT | $UNIQ`
           else
                _snap_list_=`$CAT ${VAR_TMP_DIR}/snap_list | $AWK '{print \$2}' | $GREP -v '^$' | $GREP [0-9]*@[a-z0-9]*| $AWK -F'@' '{print \$NF}' | $SORT | $UNIQ`
           fi
           _param_to_update_="SAN_SNAP_LABEL"
           _message_to_display_="Listing available ${_type_} snap shot label on ${HNAME}"
           ;;
      nas) _snap_list_=`$CAT ${VAR_TMP_DIR}/snap_list | $AWK '{print \$1}' | $AWK -F'/' '{print \$NF}'| $SED '1,8d' | $SORT | $UNIQ`
           _param_to_update_="NAS_SNAP_LABEL"
           _message_to_display_="Listing available ${_type_} snap shot label on ${HNAME}"
          ;;
      \?) $ECHO "Invalid type"
          usage_msg
          exit 1
         ;;
    esac

    $ECHO "\n==========================================================="
    $ECHO "\n${_message_to_display_}"
    $ECHO "\n===================SNAP LABEL=============================="
    
    if [ -z "${_snap_list_}" ] ; then
        $ECHO "\n          No ${_type_} snap shot exists"
        break
    fi

    for _line_ in ${_snap_list_} ; do
        $ECHO "                    ${_line_}"
    done

    $ECHO "\n==========================================================="
    ask_for_input "${_type_} snap label : \c"
    _param_value_=${USER_VALUE}
    
    $ECHO ${_snap_list_} | $GREP -w ${_param_value_} >> /dev/null 2>&1
    if [ $? -ne 0 ]; then
        $ECHO "\nSelected snapshot label doesn't exist in the list. Please select from below list "
        continue
    fi

    user_confirm_rollback
    if [ "${_response_}" != "YES" ]; then
        continue
    else
        $RM -rf ${VAR_TMP_DIR}/snap_list
        set_conf_value "${_param_to_update_}" ${_param_value_} ${_temp_rollback_conf_}
        break
    fi
done
}

### Function: start_roll_snap ###
#
# To enable the ENIQ Roll-Snap service across the deployment
#
# Arguments:
#       none
# Return Values:
#       none
start_roll_snap()
{
log_msg -q -h -s "Starting svc:/eniq/roll-snap:default service" -l ${LOGFILE}

_check_command_="${ENIQ_ADMIN_BIN_DIR}/manage_deployment_services.bsh"
check_for_file -s ${_check_command_}

log_msg -q -s "Starting to run $BASH $_check_command_ -a start -s roll-snap -N" -l ${LOGFILE}
$BASH ${_check_command_} -a start -s roll-snap -N
if [ $? -ne 0 ]; then
        _err_msg_="Exiting... Unable to start roll-snap service \n"
        abort_script "$_err_msg_"
fi

log_msg -s "Successfully started svc:/eniq/roll-snap:default service" -l ${LOGFILE}
}


### Function: start_services ###
#
# To enable the ENIQ services across the deployment
#
# Arguments:
#    none
# Return Values:
#     none
start_services()
{
log_msg -q -h -s "Starting ENIQ services" -l ${LOGFILE}
local _check_command_="${ENIQ_ADMIN_BIN_DIR}/manage_deployment_services.bsh"
check_for_file -s ${_check_command_}

log_msg -q -s "Starting to run $BASH ${_check_command_} -a start -s ALL -N" -l ${LOGFILE}
$BASH ${_check_command_} -a start -s ALL -N
if [ $? -ne 0 ]; then
    _err_msg_="Exiting... Unable to start services \n"
    abort_script "$_err_msg_"
fi

log_msg -q -s "Successfully started ENIQ services" -l ${LOGFILE}
}

### Function: store_params ###
#
# Store input parameters in a file
#
# Arguments:
#   none
# Return Values:
#   none
store_params()
{
if [ "${INSTALL_TYPE}" == "stats" ]; then
    if [ "${ACTION_TYPE}" == "upgrade" -o "${ACTION_TYPE}" ==  "upgrade_platform_only" ]; then
    if [ -s ${VAR_TMP_DIR}/upgrade_param_file ]; then
        $ECHO "Removing file ${VAR_TMP_DIR}/upgrade_param_file"
        $RM -f ${VAR_TMP_DIR}/upgrade_param_file 
    fi

    $ECHO "Storing input parameters in file ${VAR_TMP_DIR}/upgrade_param_file"
    $ECHO "BASE_SW_DIR:${BASE_SW_DIR}" > ${VAR_TMP_DIR}/upgrade_param_file
    $ECHO "OM_SW_DIR:${OM_SW_DIR}" >> ${VAR_TMP_DIR}/upgrade_param_file
    $ECHO "Successfully stored input parameters in file ${VAR_TMP_DIR}/upgrade_param_file"
    fi
fi
}

### Function: set_next_stage ###
#
# Set up the stage to be run
#
# Arguments:
#   $1 : Stage to be set to. Either numeric value or 'cleanup'
# Return Values:
#   none
set_next_stage()
{
# Do I have to reset stage
if [ "${USER_STAGE}" -a "${NO_RESET_STAGE}" ]; then
    return 0
fi

_stage_time_=`$DATE '+%Y-%b-%d_%H.%M.%S'`
$ECHO "# Setting new stage at $_stage_time_" > ${STAGEFILE} | $TEE -a ${LOGFILE}
$ECHO "${ENIQ_CORE_STAGES[$1]} " >> ${STAGEFILE} | $TEE -a ${LOGFILE}
}

### Function: setup_env ###
#
# Setup up path environment etc
#
# Arguments:
#       none
# Return Values:
#       none
setup_env()
{
# Directory for the Core Installation SW
ENIQ_CORE_INST_DIR=${ENIQ_INST_DIR}/core_install

# Directory for the Core Installation SW version
ENIQ_CORE_VER_DIR=${ENIQ_CORE_INST_DIR}/version

# Admin directory in the ENIQ file system
ENIQ_ADMIN_DIR=${ENIQ_BASE_DIR}/admin

# Admin bin dir
ENIQ_ADMIN_BIN_DIR=${ENIQ_ADMIN_DIR}/bin

# Core bin dir
ENIQ_CORE_BIN_DIR=${ENIQ_CORE_INST_DIR}/bin
ENIQ_CORE_ETC_DIR=${ENIQ_CORE_INST_DIR}/etc
GET_IP_ORDER=${ENIQ_CORE_INST_DIR}/lib/get_ip_order.pl

# ENIQ Bkup Sw dir
ENIQ_BKUP_SW_DIR=${ENIQ_BASE_DIR}/bkup_sw
ENIQ_BKUP_SW_BIN_DIR=${ENIQ_BKUP_SW_DIR}/bin

#Templates admin bin dir
TEMPLATES_ADMIN_BIN_DIR=${ENIQ_CORE_INST_DIR}/templates/stats/admin/bin  

# Sentinel dir
ENIQ_SENTINEL_DIR=${ENIQ_BASE_DIR}/sentinel
ENIQ_SENTINEL_BIN_DIR=${ENIQ_SENTINEL_DIR}/bin
ENIQ_SENTINEL_ENV=${ENIQ_SENTINEL_DIR}/etc/sentinel.env
# ENIQ Log Directory
ENIQ_LOG_DIR=${ENIQ_BASE_DIR}/local_logs
LOG_DIR=${ENIQ_BASE_DIR}/log
SW_LOG_DIR=${LOG_DIR}/sw_log

# Set the log directory for Resize NAS File Systems
RESIZE_NAS_LOGFILE_DIR=${LOG_DIR}/resize_nas

# Set the log directory for Create Snapshots stage
SNAPSHOT_LOGFILE_DIR=${SW_LOG_DIR}/rolling_snapshot_logs
SNAPSHOT_LOGFILE=${SNAPSHOT_LOGFILE_DIR}/prep_eniq_snapshots.log

# Set the log directory for Delete Snapshots stage
DEL_SNAP_LOGFILE_DIR=${ENIQ_LOG_DIR}/rolling_snapshot_logs
DEL_SNAP_LOGFILE=${DEL_SNAP_LOGFILE_DIR}/clean_roll_snap.log

# Set the log directory for Core SW Upgrade
CORE_SW_LOGFILE_DIR=${LOG_DIR}/manage_upgrade_log

# Set the log directory for Sybase IQ
SAP_IQ_LOGFILE_DIR=${LOG_DIR}/sybase_iq
SAP_IQ_LOGFILE=${SAP_IQ_LOGFILE_DIR}/upgrade_sybaseiq.log

# Set the log directory for Sybase ASA
SAP_ASA_LOGFILE_DIR=${LOG_DIR}/sybase_asa
SAP_ASA_LOGFILE=${SAP_ASA_LOGFILE_DIR}/upgrade_sybase_asa.log

# Set the log directory for Platform Upgrade 
PLATFORM_UPG_LOGFILE_DIR=${SW_LOG_DIR}/platform_installer/platform_management_log
PLATFORM_UPG_LOGFILE=${PLATFORM_UPG_LOGFILE_DIR}/upgrade_platform_modules.log

# Set the log directory for Feature Upgrade 
FEATURE_UPG_LOGFILE_DIR=${ENIQ_BASE_DIR}/log/feature_management_log
FEATURE_UPG_LOGFILE=${FEATURE_UPG_LOGFILE_DIR}/manage_features.log

# Set the log directory for Add new Feature 
ADD_NEW_FEATURE_LOGFILE_DIR=${ENIQ_BASE_DIR}/log/manage_eniq_oss_log
ADD_NEW_FEATURE_LOGFILE=${ADD_NEW_FEATURE_LOGFILE_DIR}/manage_eniq_oss.log

# Set Temp Core SW Upgrade Directory
TEMP_CORE_SW_UPG_DIR=${UPG_VAR_TMP_DIR}/${UPG_SW_DIR}/core_install

# Set Core SW Upgrade Bin Directory
CORE_SW_UPG_DIR=${TEMP_CORE_SW_UPG_DIR}/bin/

# ENIQ SW conf
CLI_CONF_DIR=${ENIQ_BASE_DIR}/sw/conf

# ENIQ SW install
SW_INSTALLER_DIR=${ENIQ_BASE_DIR}/sw/installer

# Rollback Directories
ROLLBACK_CORE=`$DIRNAME ${SCRIPTHOME}`
if [ "${rollback_type_flag}" != 1 ]; then
    ENIQ_CORE_INST_DIR=${ROLLBACK_CORE}
fi

# Set the Rollback Home as per action type
ROLLBACK_HOME=`$DIRNAME ${ROLLBACK_CORE}`

ROLLBACK_BIN=${ROLLBACK_CORE}/bin
ROLLBACK_LIB=${ROLLBACK_CORE}/lib
ROLLBACK_ETC=${ROLLBACK_CORE}/etc
ROLLBACK_TEMP_DIR=${ROLLBACK_CORE}/templates
ROLLBACK_TEMP_SW_BIN_DIR=${ROLLBACK_TEMP_DIR}/common/bkup_sw/bin
TEM_ROLLBACK_DIR=${UPG_VAR_TMP_DIR}/Rollback


# Rollback config file
ROLLBACK_SNAP_LABEL_CONF=${VAR_TMP_DIR}/rollback_snap_label.conf

#NAS rollback success file
NAS_ROLLBACK_SUCCESS=${VAR_TMP_DIR}/nas_${ACTION_TYPE}_success

#ZFS rollback success file
FS_ROLLBACK_SUCCESS=${VAR_TMP_DIR}/fs_${ACTION_TYPE}_success

#SAN rollback success file
SAN_ROLLBACK_SUCCESS=${VAR_TMP_DIR}/san_${ACTION_TYPE}_success

# Flag file to check snapshot is created through upgrade script
CALLED_THROUGH_UPGRADE=${ENIQ_ADMIN_BIN_DIR}/called_through_upgrade

# Name of file containing List of used OSS reference names
OSS_REF_NAME_FILE=${CLI_CONF_DIR}/.oss_ref_name_file

# Hostname Information
HNAME=`${MYHOSTNAME}`
HOST_IP=`$MYHOSTNAME -i | $AWK '{print $1}' | $HEAD -1` 

# Source the common functions
if [ "${ACTION_TYPE}" == "upgrade" ]; then
    if [ -s ${TEMP_CORE_SW_UPG_DIR}/lib/common_functions.lib ]; then
        . ${TEMP_CORE_SW_UPG_DIR}/lib/common_functions.lib
    else
        _err_msg_="File ${TEMP_CORE_SW_UPG_DIR}/lib/common_functions.lib not found"
        abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
    fi
else
    if [ -s ${ENIQ_CORE_INST_DIR}/lib/common_functions.lib ]; then
        . ${ENIQ_CORE_INST_DIR}/lib/common_functions.lib
    else
        _err_msg_="File ${ENIQ_CORE_INST_DIR}/lib/common_functions.lib not found"
        abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
    fi
fi

if [ -s ${ENIQ_CORE_INST_DIR}/lib/common_core_install_functions.lib ]; then
    . ${ENIQ_CORE_INST_DIR}/lib/common_core_install_functions.lib
else
    _err_msg_="File ${ENIQ_CORE_INST_DIR}/lib/common_core_install_functions.lib not found"
    abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ -s ${ENIQ_CORE_INST_DIR}/lib/common_inirator_functions.lib ]; then
    . ${ENIQ_CORE_INST_DIR}/lib/common_inirator_functions.lib
else
    _err_msg_="File ${ENIQ_CORE_INST_DIR}/lib/common_inirator_functions.lib not found"
    abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi
 
if [ "${ACTION_TYPE}" == "rollback" ]; then
    if [ "${ADMIN_UI}" ]; then 
        if [ -s ${VAR_TMP_DIR}/rollback_conf_adminUI ]; then
            SELECTED_SNAPSHOT=${VAR_TMP_DIR}/rollback_conf_adminUI
        else
            _err_msg_="Exiting...File containing snapshot information not found."
            abort_script "${_err_msg_}"
        fi
    else
        SELECTED_SNAPSHOT=${VAR_TMP_DIR}/rollback_conf
    fi
fi

# File containing the type of OSS installation. Eg. events or statistics
INST_TYPE_FILE=${ENIQ_CONF_DIR}/ericsson_use_config
if [ ! -s "${INST_TYPE_FILE}" ]; then
    _err_msg_="ENIQ install type not defined in ${INST_TYPE_FILE}"
    abort_script "${_err_msg_}"  "${EXEC_SHELL_CMD}"
fi

# Read the installation type - should be "events" or "stats"
INSTALL_TYPE=`$CAT ${INST_TYPE_FILE} | $AWK -F\= '{print $2}'`

# hostname of local host
HOST_NAME=`${MYHOSTNAME}`

# Get the System User.
_sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v ENIQ_SYSUSER`
if [ ! "${_sysuser_}" ]; then
    _err_msg_="Could not read parameter ENIQ_SYSUSER from ${ENIQ_CONF_DIR}/${SUNOS_INI} file"
    abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi


# Read deployment type of blade
DEPLOYMENT_TYPE=`$CAT ${ENIQ_CONF_DIR}/${HOST_NAME}/${HOST_NAME}_installation_param_details | $GREP -w deployment | $CUT -d'=' -f2`

# Set templates directory
TMPL_DIR=${TEMP_CORE_SW_UPG_DIR}/templates
TMPL_ADMIN_BIN_DIR=${TMPL_DIR}/${INSTALL_TYPE}/admin/bin

GET_IP_ORDER_SCRIPT=${ENIQ_CORE_INST_DIR}/lib/get_ip_order.pl
if [ ! -s "${GET_IP_ORDER_SCRIPT}" ]; then
    _err_msg_="Could not find script: ${GET_IP_ORDER_SCRIPT}"
    abort_script "$_err_msg_" "${EXEC_SHELL_CMD}"
fi

# Read storage type
read_storage_type

if [ "${STORAGE_TYPE}" != "fs" -a "${SAN_DEVICE}" != "unityXT" ]; then
    _nas_sw_target_dir_=`iniget NAS_STORAGE_API -f ${ENIQ_CONF_DIR}/${SUNOS_INI} -v NAS_API_TARGET_DIR`
    if [ ! "${_nas_sw_target_dir_}" ]; then
            _err_msg_="Failed to get NAS API target dir information from ${ENIQ_CONF_DIR}/${SUNOS_INI}"
            abort_script "$_err_msg_"
    fi

    NASCLI=${_nas_sw_target_dir_}/bin/nascli
    if [ ! -s ${_nascli_} ]; then
        _err_msg_="${_nascli_} not found"
        abort_script "$_err_msg_"
    fi
fi

# Set snapshot disable flag if post migration upgrade
MIGRATION_FLAG="/var/tmp/solaris_migration_success"
if [ -f "${MIGRATION_FLAG}" ]; then
    STAGE_QUIET="YES"
fi

if [ "${STORAGE_TYPE}" == "raw" ]; then
if [ -s ${ENIQ_CONF_DIR}/extra_params/deployment ]; then
        _deployment_type_=`$CAT ${ENIQ_CONF_DIR}/extra_params/deployment | $TR '[:upper:]' '[:lower:]'`
    else
        _err_msg_="${ENIQ_CONF_DIR}/extra_params/deployment not found or is empty"
        abort_script "$_err_msg_"
    fi
   if [ "${SAN_DEVICE}" != "unityXT" ]; then
    case ${_deployment_type_} in
        small)  _storage_ini_templ="storage_ini.sml"
                ;;
        medium)  _storage_ini_templ="storage_ini.med"
                ;;
        large)  _storage_ini_templ="storage_ini.lrg"
                ;;
        extralarge) _storage_ini_templ="storage_ini.extralrg"
            ;;
        ft)   _storage_ini_templ="storage_ini.ft"
                ;;
        vm)  _storage_ini_templ="storage_ini.vm"
                ;;
    esac
   else
    case ${_deployment_type_} in
        large)  _storage_ini_templ="storage_ini.lrg_unityXT"
                ;;
        extralarge) _storage_ini_templ="storage_ini.extralrg_unityXT"
                    ;;
    esac
   fi
fi

# Store SAN device type
if [ "${STORAGE_TYPE}" == "raw" ]; then
    SAN_DEVICE=`$CAT ${ENIQ_CONF_DIR}/san_details |$EGREP SAN_DEVICE= |$CUT -d "=" -f2`
    if [ ! "${SAN_DEVICE}" ]; then
        _err_msg_="Could not get SAN_DEVICE from ${ENIQ_CONF_DIR}/san_details"
        abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
    fi
fi

#Fetching IP Type from ipmp.ini file.
check_ip_type

if [ ! "${_ip_type_}" ]; then
    _err_msg_="Could not read parameter _IP_TYPE_ from file ${ENIQ_CONF_DIR}/${IPMP_INI}"
    abort_script "$_err_msg_"
fi
}

### Function: get_rollback_backup ###
#
# To create the backup of ENIQ_CORE_INST_DIR for rollback.
#
# Arguments:
#    none
# Return Values:
#     none
get_rollback_backup()
{
for _line_ in `$CAT ${_deployed_servers_}`; do
    unset _ip_address_ _serv_hostname_ _serv_type_ _count_
	local _ip_address_ _serv_hostname_ _serv_type_ _count_
	_count_=`$ECHO "${_line_}" | grep -o "::" | wc -l`

	if [ "${_ip_type_}" == "IPv6" ] && [ "${_count_}" == 3 ]; then
		_ip_address_=`$ECHO ${_line_} | grep -oE '([a-fA-F0-9]{1,4}::?){1,7}[a-fA-F0-9]{1,4}' | head -n 1 | awk -F "::" '{ print $1 "::" $2}'`
		_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
		_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $4}'`
	else
		_ip_address_=`$ECHO ${_line_} | $AWK -F"::" '{print $1}'`
		_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $2}'`
		_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
	fi
    if [ ! "${_ip_address_}" -o ! "${_serv_hostname_}" -o ! "${_serv_type_}" ]; then
        _err_msg_="Unable to retrieve IP or hostname or server type.\n"
        abort_script "${_err_msg_}"
    fi
    
    # If the IP found in the order file matches my IP, run locally
    if [ "${_ip_address_}" == "${HOST_IP}" ]; then
        if [ -d ${TEM_ROLLBACK_DIR} ]; then
            $RM -rf ${TEM_ROLLBACK_DIR}
            if [ $? -ne 0 ]; then
                _err_msg_="Could not delete directory ${TEM_ROLLBACK_DIR}. Please delete it manually."
                abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
            fi
        fi
        $MKDIR -p ${TEM_ROLLBACK_DIR}
        if [ $? -ne 0 ]; then
            _err_msg_="Could not create directory ${TEM_ROLLBACK_DIR}"
            abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
        fi

        $CP -pr ${ENIQ_CORE_INST_DIR} ${TEM_ROLLBACK_DIR}
        if [ $? -ne 0 ]; then
            _err_msg_="Failed to copy files to ${TEM_ROLLBACK_DIR}"
            abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
        fi
    else
       if [ "${_user_root}" == 1 ]; then			
			run_remote_cmd "${_serv_hostname_}" "$LS -ld ${TEM_ROLLBACK_DIR}" >> /dev/null 2>&1
			if [ $? -eq 0 ]; then
				run_remote_cmd "${_serv_hostname_}" "$RM -rf ${TEM_ROLLBACK_DIR}" >> /dev/null 2>&1
				if [ $? -ne 0 ]; then
					_err_msg_="Could not delete directory ${TEM_ROLLBACK_DIR}. Please delete it manually."
					abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
				fi
			fi
			run_remote_cmd "${_serv_hostname_}" "$MKDIR -p ${TEM_ROLLBACK_DIR}" >> /dev/null 2>&1
			if [ $? -ne 0 ]; then
				_err_msg_="Could not create directory ${TEM_ROLLBACK_DIR}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
			run_remote_cmd "${_serv_hostname_}" "$CP -pr ${ENIQ_CORE_INST_DIR} ${TEM_ROLLBACK_DIR}" >> /dev/null 2>&1
			if [ $? -ne 0 ]; then
				_err_msg_="Failed to copy files to ${TEM_ROLLBACK_DIR}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		else
			run_remote_cmd "${_serv_hostname_}" "$SUDO $LS -ld ${TEM_ROLLBACK_DIR}" "" "$_get_id_">> /dev/null 2>&1
			if [ $? -eq 0 ]; then
				run_remote_cmd "${_serv_hostname_}" "$SUDO $RM -rf ${TEM_ROLLBACK_DIR}" "" "$_get_id_">> /dev/null 2>&1
				if [ $? -ne 0 ]; then
					_err_msg_="Could not delete directory ${TEM_ROLLBACK_DIR}. Please delete it manually."
					abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
				fi
			fi
			run_remote_cmd "${_serv_hostname_}" "$SUDO $MKDIR -p ${TEM_ROLLBACK_DIR}" "" "$_get_id_" >> /dev/null 2>&1
			if [ $? -ne 0 ]; then
				_err_msg_="Could not create directory ${TEM_ROLLBACK_DIR}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
			run_remote_cmd "${_serv_hostname_}" "$SUDO $CP -pr ${ENIQ_CORE_INST_DIR} ${TEM_ROLLBACK_DIR}" "" "$_get_id_" >> /dev/null 2>&1
			if [ $? -ne 0 ]; then
				_err_msg_="Failed to copy files to ${TEM_ROLLBACK_DIR}"
				abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
			fi
		fi 
    fi
done
}

### Function: stop_roll_snap ###
#
# To disable the ENIQ Roll-Snap service across the deployment
#
# Arguments:
#    none
# Return Values:
#     none
stop_roll_snap()
{
log_msg -q -h -s "Stopping svc:/eniq/roll-snap:default service" -l ${LOGFILE}

local _check_command_="${ENIQ_ADMIN_BIN_DIR}/manage_deployment_services.bsh"
check_for_file -s ${_check_command_}

log_msg -q -s "Starting to run $BASH ${_check_command_} -a stop -s roll-snap -N" -l ${LOGFILE}
$BASH ${_check_command_} -a stop -s roll-snap -N
if [ $? -ne 0 ]; then
    _err_msg_="Exiting... Unable to stop roll-snap service \n"
    abort_script "$_err_msg_"
fi

log_msg -s "Successfully stopped svc:/eniq/roll-snap:default service" -l ${LOGFILE}
}

### Function: stop_services ###
#
# To disable the ENIQ services across the deployment
#
# Arguments:
#    none
# Return Values:
#     none
stop_services()
{
log_msg -q -h -s "Stopping ENIQ services" -l ${LOGFILE}

local _check_command_="${ENIQ_ADMIN_BIN_DIR}/manage_deployment_services.bsh"
check_for_file -s ${_check_command_}

log_msg -q -s "Starting to run $BASH ${_check_command_} -a stop -s ALL -N" -l ${LOGFILE}
$BASH ${_check_command_} -a stop -s ALL -N
if [ $? -ne 0 ]; then
    _err_msg_="Exiting... Unable to stop services \n"
    abort_script "$_err_msg_"
fi

log_msg -q -s "Successfully stopped ENIQ services" -l ${LOGFILE}
}

### Function: upgrade_sap_asa ###
#
# To Upgrade SAP ASA
#
# Arguments:
#       none
# Return Values:
#    none 
upgrade_sap_asa()
{
insert_header_footer head "Entering Upgrade stage - ${NEXT_STAGE}" ${LOGFILE}

local _check_command_="${ENIQ_CORE_BIN_DIR}/upgrade_sybase_sql_anywhere.bsh"
check_for_file -s ${_check_command_}

log_msg -q -s "\nStarting to run $BASH ${ENIQ_CORE_BIN_DIR}/upgrade_sybase_sql_anywhere.bsh -d $BASE_SW_DIR -N -l ${SAP_ASA_LOGFILE}" -l ${LOGFILE}
$BASH ${ENIQ_CORE_BIN_DIR}/upgrade_sybase_sql_anywhere.bsh -d $BASE_SW_DIR -N -l ${SAP_ASA_LOGFILE}
if [ $? -ne 0 ]; then
    _err_msg_="Upgrade failed at ${NEXT_STAGE}. Please refer logfile: ${SAP_ASA_LOGFILE}. \n"
    abort_script "$_err_msg_"
fi

insert_header_footer foot "Successfully upgraded SAP ASA" ${LOGFILE}
log_msg -s "\nLog file for the stage - ${NEXT_STAGE}: ${SAP_ASA_LOGFILE}" -l ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: update_dwh_reader###
#
# To check the ZFS mountpoint for dwh_reader and 
# update the entry if required in SunOS.ini. 
# Arguments:
#       none
# Return Values:
#       none
update_dwh_reader()
{
insert_header_footer head "Entering Upgrade stage - ${NEXT_STAGE}" ${LOGFILE}

if [ "${STORAGE_TYPE}" != "fs" ]; then
    insert_header_footer foot "INFO: Skipping Upgrade Stage - ${NEXT_STAGE} for Blade" ${LOGFILE} 
    set_next_stage `$EXPR ${ARRAY_ELEM}+1`
    return 0
fi

local _check_command_="${ENIQ_CONF_DIR}/${SUNOS_INI}"
check_for_file -s ${_check_command_}

# Check current mountpoint for dwh reader entry
log_msg -s "Checking mountpoint for dwh_reader in ${_check_command_}" -l ${LOGFILE}
_block_=`$EGREP -B 2 ${ENIQ_BASE_DIR}/database/dwh_reader ${_check_command_} | $GREP SunOS_ZFS_FS | uniq | $TR -d [ | $TR -d ] `
if [  $_block_ ]; then
    log_msg -s "No need to update mountpoint for dwh_reader" -l ${LOGFILE}
    _update_flag_=false
else
    _update_flag_=true
    # Existing mountpoint for dwh_reader
    curr_mountpoint=`iniget $_block_ -f ${_check_command_} -v mountpoint`
    log_msg -s "Current mountpoint for dwh_reader: $curr_mountpoint" -l ${LOGFILE}
fi

if [ "$_update_flag_" == "true" ]; then
    # Mountpoint to be updated 
    new_mountpoint="${ENIQ_BASE_DIR}/database/dwh_reader"
    log_msg -s "Updating mountpoint with $new_mountpoint for dwh_reader in ${_check_command_}" -l ${LOGFILE}
    iniset $_block_ -f ${_check_command_} mountpoint=${new_mountpoint}
    if [ $? -ne 0 ]; then
        _err_msg_="Could not set ${_block_} in ${_check_command_} to mountpoint=${new_mountpoint} \n"
            abort_script "$_err_msg_"
           else 
        log_msg -s "Successfully updated mountpoint for dwh_reader in ${SUNOS_INI}" -l ${LOGFILE}
    fi    
fi

insert_header_footer foot "Successfully completed Upgrade stage - ${NEXT_STAGE}" ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: upgrade_sap_iq ###
#
# To Upgrade SAP IQ
#
# Arguments:
#       none
# Return Values:
#    none
upgrade_sap_iq()
{
insert_header_footer head "Entering Upgrade stage - ${NEXT_STAGE}" ${LOGFILE}

local _check_command_="${ENIQ_CORE_BIN_DIR}/upgrade_sybase_iq.bsh"
check_for_file -s ${_check_command_}

log_msg -q -s "\nStarting to run $BASH ${ENIQ_CORE_BIN_DIR}/upgrade_sybase_iq.bsh -d ${BASE_SW_DIR} -N -l ${SAP_IQ_LOGFILE}" -l ${LOGFILE}
$BASH ${ENIQ_CORE_BIN_DIR}/upgrade_sybase_iq.bsh -d ${BASE_SW_DIR} -N -l ${SAP_IQ_LOGFILE}
if [ $? -ne 0 ]; then
    _err_msg_=" Upgrade failed at ${NEXT_STAGE}. Please refer logfile: ${SAP_IQ_LOGFILE}.  \n"
    abort_script "$_err_msg_"
fi
    
insert_header_footer foot "Successfully upgraded SAP IQ" ${LOGFILE}
log_msg -s "\nLog file for the stage - ${NEXT_STAGE}: ${SAP_IQ_LOGFILE}" -l ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: status_file_update ###
#
# To update the eniq_status file after upgrade
#
# Arguments:
#       none
# Return Values:
#       none
status_file_update()
{
insert_header_footer head "Entering post_upgrade stage - ${NEXT_STAGE}" ${LOGFILE}

if [ "${post_upgrade_type_flag}" == 1 ]; then
        insert_header_footer foot "INFO: Skipping post-upgrade Stage - ${NEXT_STAGE} for post upgrade feature only" ${LOGFILE}
        set_next_stage `$EXPR ${ARRAY_ELEM}+1`
        return 0
fi
          
log_msg -t -s "Updating eniq_status file" -l ${LOGFILE}

# Check the required scripts exist or not
_manage_eniq_status_script_="${ENIQ_ADMIN_BIN_DIR}/manage_eniq_status.bsh"
check_for_file -s ${_manage_eniq_status_script_}

log_msg -q -s "\nStarting to run $BASH ${ENIQ_ADMIN_BIN_DIR}/manage_eniq_status.bsh -d ${BASE_SW_DIR} -l ${LOGFILE}" -l ${LOGFILE}
$BASH ${ENIQ_ADMIN_BIN_DIR}/manage_eniq_status.bsh -d ${BASE_SW_DIR} -l ${LOGFILE}
if [ $? -ne 0 ]; then
    _err_msg_="Upgrade failed at ${NEXT_STAGE}. Please refer logs \n"
    abort_script "$_err_msg_"
fi    
               
insert_header_footer foot "Successfully updated status file " ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}



### Function: update_nas_storage ### 
#
# To update remove any NAS filesystems that are deemed to be no longer required
#
# Arguments:
#       none
# Return Values:
#       none
update_nas_storage()
{
insert_header_footer head "Entering post_upgrade stage - ${NEXT_STAGE}" ${LOGFILE}

if [ "${post_upgrade_type_flag}" == 1 ]; then
        insert_header_footer foot "INFO: Skipping post-upgrade Stage - ${NEXT_STAGE} for post upgrade feature only" ${LOGFILE}
        set_next_stage `$EXPR ${ARRAY_ELEM}+1`
        return 0
fi

if [ "${CURR_SERVER_TYPE}" == "stats_coordinator" -o "${CURR_SERVER_TYPE}" == "eniq_stats" ]; then

        # Read storage type
        read_storage_type

        if [ "${STORAGE_TYPE}" != "fs" ]; then
        
            # Stop ENIQ Services
            stop_services
            
            if [ $? -ne 0 ]; then
                _err_msg_="Failed to stop services \n"
                abort_script "$_err_msg_"
            fi
                
            # Check the required script exists or not
            _manage_storage_fs_script_="${TEMPLATES_ADMIN_BIN_DIR}/manage_storage_fs.bsh"
            check_for_file -s ${_manage_storage_fs_script_}
                
            log_msg -t -s "Removing deleted NAS file-systems on ${HOST_NAME}" -l ${LOGFILE} 
            log_msg -q -s "\nStarting to run $BASH ${TEMPLATES_ADMIN_BIN_DIR}/manage_storage_fs.bsh -a -r ${ENIQ_INST_DIR} -l ${LOGFILE}" -l ${LOGFILE}
            $BASH ${TEMPLATES_ADMIN_BIN_DIR}/manage_storage_fs.bsh -a -r ${ENIQ_INST_DIR} -l ${LOGFILE}
            if [ $? -ne 0 ]; then
                _err_msg_="Post-upgrade failed at ${NEXT_STAGE}. Please refer logs \n" 
                abort_script "$_err_msg_"
            fi

            
            # Start ENIQ Services
            start_services
            
            if [ $? -ne 0 ]; then
                _err_msg_="Failed to start services \n"
                abort_script "$_err_msg_"
            fi
        fi
else
            insert_header_footer foot "INFO: Skipping post-upgrade Stage - ${NEXT_STAGE}" ${LOGFILE}
            set_next_stage `$EXPR ${ARRAY_ELEM}+1`
            return 0        
fi
                
insert_header_footer foot "Completed Stage - update_nas_storage " ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`

}

### Function: post_upgrade_configuration ###
#
# To  remove any FS file-systems that are no longer required and remove /var/tmp/upgrade directory from each server in the deployment
#
# Arguments:
#       none
# Return Values:
#       none
post_upgrade_configuration()
{
insert_header_footer head "Entering post_upgrade stage - ${NEXT_STAGE}" ${LOGFILE}

log_msg -t -s "Starting to run post upgrade configuration" -l ${LOGFILE}
log_msg -t -s "Removing ZFS file that are not required and deleting /var/tmp/upgrade directory on all deployed servers" -l ${LOGFILE} 

# Check the required script exists or not
_post_upgrade_configuration_script_="${ENIQ_ADMIN_BIN_DIR}/post_upgrade_configuration.bsh"
check_for_file -s ${_post_upgrade_configuration_script_}

log_msg -q -s "\nStarting to run $BASH ${ENIQ_ADMIN_BIN_DIR}/post_upgrade_configuration.bsh -N" -l ${LOGFILE}

if [ -f ${VAR_TMP_DIR}/current_post_upgrade_ui_stage ]; then
    $ECHO "Commit Upgrade" > ${VAR_TMP_DIR}/current_post_upgrade_ui_stage 
fi

$BASH ${ENIQ_ADMIN_BIN_DIR}/post_upgrade_configuration.bsh -N
if [ $? -ne 0 ]; then
    _err_msg_="Post-upgrade failed at ${NEXT_STAGE}.Please refer logs \n" 
    abort_script "$_err_msg_"
fi

if [ -f ${ENIQ_LOG_DIR}/.dtrace_enabled ]; then
    if [ "${post_upgrade_type_flag}" != 2 ]; then 
        log_msg -t -s "Disabling and cleaning symlink logging." -l ${LOGFILE} 

        # Check the required script exists or not
        _manage_dtrace_script_="${ENIQ_ADMIN_BIN_DIR}/manage_dtrace.bsh"
        check_for_file -s ${_manage_dtrace_script_}

        log_msg -q -s "\nStarting to run $BASH ${ENIQ_ADMIN_BIN_DIR}/manage_dtrace.bsh -a dtrace_cleanup" -l ${LOGFILE}
        $BASH ${ENIQ_ADMIN_BIN_DIR}/manage_dtrace.bsh -a dtrace_cleanup 
        if [ $? -ne 0 ]; then
            _err_msg_="Post-upgrade failed at ${NEXT_STAGE}. Please refer logs\n" 
            abort_script "$_err_msg_"
        fi 
    fi
fi     

# Start Roll Snap Service
if [ -f ${VAR_TMP_DIR}/current_post_upgrade_ui_stage ]; then
    $ECHO "Enable Rolling Snapshot" > ${VAR_TMP_DIR}/current_post_upgrade_ui_stage 
fi
start_roll_snap

# Updating the permission of /var/adm/log/agent.pid file to 644 in blade
if [ "${STORAGE_TYPE}" == "raw" ]; then
        AGENT_PID_FILE=/var/adm/log/agent.pid
        if [ -f ${AGENT_PID_FILE} ]; then
                log_msg -l ${LOGFILE} -s "Changing ${AGENT_PID_FILE} permissions to 644"
                $CHMOD 644 ${AGENT_PID_FILE}
                if [ $? -ne 0 ]; then
                        _err_msg_="Could not change permissions of ${AGENT_PID_FILE} to 644"
                        abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
                fi
        fi
fi

if [ "${post_upgrade_type_flag}" != 1 ]; then

    # checking if file exists with server order list
    if [ ! -s "${_deployed_servers_}" ]; then
        _err_msg_="Unable to retrieve deployed servers list.\n"
        abort_script "${_err_msg_}"
    fi

    # Remove telnet and ftp packages
    for _line_ in `$CAT ${_deployed_servers_}`; do
        unset _ip_address_ _serv_hostname_ _serv_type_ _count_
		local _ip_address_ _serv_hostname_ _serv_type_ _count_
		_count_=`$ECHO "${_line_}" | grep -o "::" | wc -l`

		if [ "${_ip_type_}" == "IPv6" ] && [ "${_count_}" == 3 ]; then
			_ip_address_=`$ECHO ${_line_} | grep -oE '([a-fA-F0-9]{1,4}::?){1,7}[a-fA-F0-9]{1,4}' | head -n 1 | awk -F "::" '{ print $1 "::" $2}'`
			_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
			_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $4}'`
		else
			_ip_address_=`$ECHO ${_line_} | $AWK -F"::" '{print $1}'`
			_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $2}'`
			_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
		fi
        if [ ! "${_ip_address_}" -o ! "${_serv_hostname_}" -o ! "${_serv_type_}" ]; then
            _err_msg_="Unable to retrieve IP or hostname or server type.\n"
            abort_script "${_err_msg_}"
        fi
        
        # If the IP found in the order file matches my IP, run locally
        if [ "${_ip_address_}" == "${HOST_IP}" ]; then
            if [ ! -f ${ENIQ_CONF_DIR}/packages_removed ]; then
                remove_telnet_ftp_packages ${_serv_hostname_}
                if [ $? -eq 0 ]; then
                    $TOUCH ${ENIQ_CONF_DIR}/packages_removed
                fi
            fi
        else
			if [ "${_user_root}" == 1 ]; then			
				run_remote_cmd "${_serv_hostname_}" "$LS ${ENIQ_CONF_DIR}/packages_removed" >> /dev/null 2>&1
			else
				run_remote_cmd "${_serv_hostname_}" "$SUDO $LS ${ENIQ_CONF_DIR}/packages_removed" "" "$_get_id_" >> /dev/null 2>&1
			fi 
			if [ $? -ne 0 ]; then
                run_remote_cmd "${_serv_hostname_}" ". ${SCRIPTHOME}/../lib/common_core_install_functions.lib; remove_telnet_ftp_packages ${_serv_hostname_}" 
                if [ $? -eq 0 ]; then
					run_remote_cmd "${_serv_hostname_}" "$TOUCH ${ENIQ_CONF_DIR}/packages_removed" >> /dev/null 2>&1
                    if [ $? -ne 0 ]; then
                       _err_msg_="run_remote_cmd failing on the ${_serv_hostname_} to update dcuser password\n"
                       abort_script "${_err_msg_}"
                    fi
                fi
            fi
        fi
    done   
fi                           


if [ -f "$file_repdbpass" ]; then
    change_repdb_password
fi

# dcuser password enforcement
if [ -f "$file_dcpass" ]; then
    local ENIQ_BASE_DIR=/eniq
    local CLI_CONF_DIR=${ENIQ_BASE_DIR}/sw/conf
    for _line_ in `$CAT ${_deployed_servers_}`; do
        unset _ip_address_ _serv_hostname_ _serv_type_ _count_
		local _ip_address_ _serv_hostname_ _serv_type_ _count_
		_count_=`$ECHO "${_line_}" | grep -o "::" | wc -l`

		if [ "${_ip_type_}" == "IPv6" ] && [ "${_count_}" == 3 ]; then
			_ip_address_=`$ECHO ${_line_} | grep -oE '([a-fA-F0-9]{1,4}::?){1,7}[a-fA-F0-9]{1,4}' | head -n 1 | awk -F "::" '{ print $1 "::" $2}'`
			_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
			_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $4}'`
		else
			_ip_address_=`$ECHO ${_line_} | $AWK -F"::" '{print $1}'`
			_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $2}'`
			_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
		fi
        if [ ! "${_ip_address_}" -o ! "${_serv_hostname_}" -o ! "${_serv_type_}" ]; then
            _err_msg_="Unable to retrieve IP or hostname or server type.\n"
            abort_script "${_err_msg_}"
        fi

        # If the IP found in the order file matches my IP, run locally
        if [ "${_ip_address_}" == "${HOST_IP}" ]; then
            dcuser_password_enforcement
            dcuser_enforce_status=$?
            if [ ${dcuser_enforce_status} -ne 0 ];then
                log_msg -t -s "ERROR: ChangeUserPasswordsInRepdb execution failed for dcuser with new password for ${_serv_hostname_}\n" -l ${LOGFILE}
                rollback_dcuser_password
                if [ -f ${CLI_CONF_DIR}/.rollback_repdb_dcuser ];then
                    $RM -rf ${CLI_CONF_DIR}/.rollback_repdb_dcuser 
                fi
                _err_msg_="Reverted the password and ChangeUserPasswordsInRepdb execution failed for ${_serv_hostname_} \n"
                abort_script "${_err_msg_}"
            fi
        else
           run_remote_cmd "${_serv_hostname_}" ". ${SCRIPTHOME}/../lib/common_functions.lib; dcuser_password_enforcement"
           dcuser_enforce_check=$?
           if [ ${dcuser_enforce_check} -ne 0 ];then
                log_msg -t -s "OS level password update for dcuser failed with new password for ${_serv_hostname_}\n" -l ${LOGFILE}
                rollback_dcuser_password
                rollback_dcuser_repdb
           fi
        fi
    done
    $RM -rf /tmp/password_change_required
    $RM -rf /eniq/sw/conf/dcuser_password_change
fi

#Stopping ENIQ Services
stop_services

#Starting ENIQ Services
start_services

insert_header_footer foot "Successfully completed stage - post upgrade configuration " ${LOGFILE}
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}

### Function: rollback_dcuser_password ###
#
# To revert the backup files of dcuser.
#
# Arguments:
#    none
# Return Values:
#     none
rollback_dcuser_password()
{

log_msg -t -s "\nReverting the password for dcuser" -l ${LOGFILE}

for _line_ in `$CAT ${_deployed_servers_}`; do
    unset _ip_address_ _serv_hostname_ _serv_type_ _count_
	local _ip_address_ _serv_hostname_ _serv_type_ _count_
	_count_=`$ECHO "${_line_}" | grep -o "::" | wc -l`

	if [ "${_ip_type_}" == "IPv6" ] && [ "${_count_}" == 3 ]; then
		_ip_address_=`$ECHO ${_line_} | grep -oE '([a-fA-F0-9]{1,4}::?){1,7}[a-fA-F0-9]{1,4}' | head -n 1 | awk -F "::" '{ print $1 "::" $2}'`
		_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
		_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $4}'`
	else
		_ip_address_=`$ECHO ${_line_} | $AWK -F"::" '{print $1}'`
		_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $2}'`
		_serv_type_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
	fi
    if [ ! "${_ip_address_}" -o ! "${_serv_hostname_}" -o ! "${_serv_type_}" ]; then
        _err_msg_="Unable to retrieve IP or hostname or server type.\n"
        abort_script "${_err_msg_}"
    fi
    
    # If the IP found in the order file matches my IP, run locally
    if [ "${_ip_address_}" == "${HOST_IP}" ]; then
        if [ -f /etc/shadow_bkup ]; then
            $CP -p /etc/shadow_bkup /etc/shadow  
            dcuser_revert_check=$?
            if [ "${dcuser_revert_check}" -ne 0 ]; then
                _err_msg_="Failed to revert old dcuser password for ${_serv_hostname_}."
                abort_script "${_err_msg_}"
            else
                $RM -rf /etc/shadow_bkup
                log_msg -t -s "Successfully reverted the dcuser password on ${_serv_hostname_}\n" -l ${LOGFILE}
            fi
        fi
    else
		if [ "${_user_root}" == 1 ]; then			
			run_remote_cmd "${_serv_hostname_}" "$CP -p /etc/shadow_bkup /etc/shadow"  
			dcuser_revert_check=$?
			if [ "${dcuser_revert_check}" -ne 0 ]; then
				_err_msg_="Failed to revert old dcuser password for ${_serv_hostname_}"
				abort_script "${_err_msg_}"
			else
				$TOUCH ${CLI_CONF_DIR}/.rollback_repdb_dcuser
				run_remote_cmd "${_serv_hostname_}" "$RM -rf /etc/shadow_bkup" >> /dev/null 2>&1
				log_msg -t -s "Successfully reverted the dcuser password ${_serv_hostname_}\n"  -l ${LOGFILE}
			fi
		else
			run_remote_cmd "${_serv_hostname_}" "$SUDO $CP -p /etc/shadow_bkup /etc/shadow" "" "$_get_id_" 
			dcuser_revert_check=$?
			if [ "${dcuser_revert_check}" -ne 0 ]; then
				_err_msg_="Failed to revert old dcuser password for ${_serv_hostname_}"
				abort_script "${_err_msg_}"
			else
				$TOUCH ${CLI_CONF_DIR}/.rollback_repdb_dcuser
				run_remote_cmd "${_serv_hostname_}" "$SUDO $RM -rf /etc/shadow_bkup" "" "$_get_id_" >> /dev/null 2>&1
				log_msg -t -s "Successfully reverted the dcuser password ${_serv_hostname_}\n"  -l ${LOGFILE}
			fi
		fi 
    fi
done

return 1
}
### Function: rollback_dcuser_repdb ###
#
# To revert the dcuser password in repdb.
#
# Arguments:
#    none
# Return Values:
#     none
rollback_dcuser_repdb()
{
# Define variables
local ENIQ_BASE_DIR=/eniq
local ENIQ_CONF_DIR=${ENIQ_BASE_DIR}/installation/config
local CLI_CONF_DIR=${ENIQ_BASE_DIR}/sw/conf
local ENIQ_SW_PF_DIR=${ENIQ_BASE_DIR}/sw/platform
passphrase=`$CAT /eniq/sw/conf/strong_passphrase`

# Get old and new password for dcuser
_old_pwd_=`$CAT ${CLI_CONF_DIR}/dcuser_password_change | $GREP -w "OLD_DCUSER_PASSWORD" | $AWK -F ":" '{print $2}'`
_new_pwd_=`$CAT ${CLI_CONF_DIR}/dcuser_password_change | $GREP -w "NEW_DCUSER_PASSWORD" | $AWK -F ":" '{print $2}'`
dcuser_encryption_flag=`iniget SunOS_USER_1 -v password -f /eniq/installation/core_install/templates/stats/SunOS.ini`

if [ ${dcuser_encryption_flag} = yy ]; then
    _old_dcuser_pwd_=`$ECHO ${_old_pwd_} | openssl enc -aes-256-ctr -md sha512 -a -d -salt -pass pass:${passphrase}`
    _DC_PWD_=`$ECHO ${_new_pwd_} | openssl enc -aes-256-ctr -md sha512 -a -d -salt -pass pass:${passphrase}`
else
    _old_dcuser_pwd_=`$ECHO ${_old_pwd_} | openssl enc -base64 -d`
    _DC_PWD_=`$ECHO ${_new_pwd_} | openssl enc -base64 -d`
fi

if [ -f ${CLI_CONF_DIR}/.rollback_repdb_dcuser ];then
    if [ "${CURR_SERVER_TYPE}" == "eniq_stats" -o "${CURR_SERVER_TYPE}" == "stats_coordinator" ] ; then
# Updating same password in RepDB

# Get R_State of repository package
    R_STATE=`$CAT ${ENIQ_SW_PF_DIR}/../installer/versiondb.properties | $GREP -w repository | $AWK -F "=" '{print $2}'`

# Get system user (dcuser)
    local _sysuser_=`iniget ENIQ_INSTALL_CONFIG -f ${ENIQ_CONF_DIR}/SunOS.ini -v ENIQ_SYSUSER`

    $CHMOD +x ${ENIQ_SW_PF_DIR}/repository-${R_STATE}/bin/ChangeUserPasswordsInRepdb
    if [ $? -ne 0 ]; then
        _err_msg_="Could not change permission for ${ENIQ_SW_PF_DIR}/repository-${R_STATE}/bin/ChangeUserPasswordsInRepdb."
        abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
    fi

    $ECHO "Changing password in RepDB for dcuser."

    $SU - ${_sysuser_} -c "$BASH ${ENIQ_SW_PF_DIR}/repository-${R_STATE}/bin/ChangeUserPasswordsInRepdb -u dcuser -o ${_DC_PWD_} -p ${_old_dcuser_pwd_} -r ${_old_dcuser_pwd_}"
    dcuser_password_status_rep=$?
    if [ ${dcuser_password_status_rep} -ne 0 ];then
        _err_msg_="Could not update old dcuser password with ChangeUserPasswordsInRepdb script."
        abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
    else
        log_msg -s "Successfully updated old dcuser password in RepDB.\n" -l ${LOGFILE}
    fi

    fi
    $RM -rf ${CLI_CONF_DIR}/.rollback_repdb_dcuser 
    log_msg -s "Updating new password failed in OS level, hence old password is reverted for dcuser. \n" -l ${LOGFILE}
    exit 1
fi
}

### Function: list_features ###
#
#
# Arguments:
#   none
# Return Values:
#   none
list_features()
{
# Feature selection at start for E_Stats with full upgrade scenario.
if [ "${CURR_SERVER_TYPE}" == "eniq_stats" -o "${CURR_SERVER_TYPE}" == "stats_coordinator" ] ; then
    if [ "${ACTION_TYPE}" == "upgrade" -o "${ACTION_TYPE}" == "upgrade_feature_only" ]; then 
        while :; do
        
            get_eniq_upgrade_feature_list
        
            if [ $? == 99 -a "${INSTALL_TYPE}" == "stats" ]; then
                log_msg -s "Cleaning up the temporary directory" -l ${LOGFILE}
                _err_msg_="Could not locate ENIQ Features input file"
                abort_script "$_err_msg_"
            fi
        
            #Setup user confirmation page
            setup_update_disp_file

            # If there is no file then there is nothing to update
            if [ -s  ${TEM_DIR}/disp_file ]; then
        
                # Confirm that the User still wants to add the features
                confirm_user_input ${TEM_DIR}/disp_file


                if [ "${USER_CONF}" == "N" -o "${USER_CONF}" == "n" ]; then
                    $RM -rf ${ENIQ_CORE_ETC_DIR}/features_to_be_managed
                    $RM -rf ${TEM_DIR}/feature_output_list2
                    continue
                fi
            else
                $CLEAR
                $ECHO "\nFeature upgrade not required....\n\n"
            fi
            break
        
            log_msg -l ${LOGFILE} -q -s "The following features will be updated"
            log_msg -l ${LOGFILE} -q -s "======================================"
            $CAT ${TEM_DIR}/feature_output_list2 | $AWK -F"::" '{print $1}' >> ${LOGFILE}
        done
    fi
fi
}

### Function: add_features_list ###
#
#
# Arguments:
#   none
# Return Values:
#   none
add_features_list()
{

local OSS_NAME=$1

if [ ! "${ADMIN_UI}" ]; then
    # Feature selection at start for E_Stats with full upgrade scenario.
    if [ "${CURR_SERVER_TYPE}" == "eniq_stats" -o "${CURR_SERVER_TYPE}" == "stats_coordinator" ] ; then
        if [ "${ACTION_TYPE}" == "upgrade" -o "${ACTION_TYPE}" == "upgrade_feature_only" ]; then 
            while :; do
          
                get_eniq_add_features_list ${OSS_NAME}
       
                #Setup user confirmation page
                setup_update_disp_file_add_features

                # If there is no file then there is nothing to update
                if [ -s  ${TEM_DIR}/disp_file ]; then
        
                    # Confirm that the User still wants to add the features
                    confirm_user_input ${TEM_DIR}/disp_file

                    if [ "${USER_CONF}" == "N" -o "${USER_CONF}" == "n" ]; then
                        $RM -rf ${ENIQ_CORE_ETC_DIR}/feature_output_list_${OSS_NAME}
                        continue
                    fi
                else
                    $CLEAR
                    $ECHO "\nNo update required for ${OSS_NAME}....\n\n"
                fi
                break
            done
        fi
    fi
fi
}
### Function: usage_msg ###
#
#   Print out the usage message
#
# Arguments:
#   none
# Return Values:
#   none
usage_msg()
{
$CLEAR
$ECHO "
Usage: `$BASENAME $0` -A <action_type> -D <eniq_sw_dir> -O <om_media_location> -P  <new_sw_extraction_loc> [ -M <sol_om_media_location> ] [ -l <path_to_logfile> ]
options:
-A  : Parameter specifying the action type. Should be either of the following:
      upgrade                      : To upgrade the system completly.
      post_upgrade               : To perform the post upgrade steps after which roll back will not be possible.
      post_upgrade_feature_only  : To perform the post upgrade steps in case of feature only upgrade
      post_upgrade_platform_only : To perform the post upgrade steps in case of platform only upgrade
      rollback                   : To rollback the system.
      rollback_feature_only      : To rollback the system in case of feature only upgrade
      rollback_platform_only     : To rollback the systen in case of platform only upgrade
      upgrade_platform_only      : To perform platform only upgrade.
      upgrade_feature_only       : To perform feature only upgrade.  
      

-D  : Parameter specifying the full path to the directory
      containing the ENIQ BASE SW directory structure. 
      
-O  : Parameter specifying the full path to the directory
      containing the O&M SW directory structure.

-M  : Optional parameter for ENIQ Events specifying the full path to the directory
      containing Solaris 11 O&M SW directory structure.
      
-P  : Parameter specifying only the directory where the new core SW is extracted.

-f  : Parameter specifying the full path to the directory
      containing the Feature directory structure.
      
-l  : To generate logfile
"
}

### Function: user_confirmation ###               
#
# Get confirmation from user to proceed with the execution of script
#
# Arguments:
#       none
# Return Values:
#       none
user_confirmation()
{
while :; do
    unset USER_CONF
    if [ ${ACTION_TYPE} == "post_upgrade" ]; then
    $CLEAR
    $ECHO "\nAre you sure you want to commit the upgrade? "
    else
        $CLEAR
        $ECHO "\nAre you sure you want to rollback the upgrade? "
    fi
    $ECHO "Enter [Yes|No] (case sensitive) : \c"

    read USER_CONF
    if [ "${USER_CONF}" == "Yes" -o "${USER_CONF}" == "No" ]; then
        break
    fi
done
if [ "${ACTION_TYPE}" == "post_upgrade" ] && [ "${post_upgrade_type_flag}" -ne 1 ]; then
    $ECHO "Checking Dcuser password are already changed or not"
    check_default_dcuser_password
    $ECHO "Checking RepDB users passwords are already changed or not"
    check_default_repdb_password
fi
}

### Function: setup_update_disp_file ###
#
# Set up a file to display out for update details
#
# Arguments:
#   none
# Return Values:
#   none
setup_update_disp_file()
{
# Set up a file to display out
$RM -f ${TEM_DIR}/disp_file

_update_=0

if [ -s ${ENIQ_CORE_ETC_DIR}/features_to_be_managed ]; then
        #echo "${TEM_DIR}/disp_file"
    $ECHO "\nENIQ Features" >> ${TEM_DIR}/disp_file
    $ECHO "=============" >> ${TEM_DIR}/disp_file
    $CAT ${TEM_DIR}/feature_output_list2 >> ${TEM_DIR}/disp_file
      
    $ECHO "\nDo you wish to continue to update the features above (Yy/Nn)\n" >> ${TEM_DIR}/disp_file    
    _update_=1
fi

# If there is nothing to upgrade then delete the disp file
if [ ${_update_} -eq 0 ]; then
    $RM -f ${TEM_DIR}/disp_file
fi
}

### Function: setup_update_disp_file_add_features ###
#
# Set up a file to display out for update details
#
# Arguments:
#   none
# Return Values:
#   none
setup_update_disp_file_add_features()
{
# Set up a file to display out
$RM -f ${TEM_DIR}/disp_file

_update_=0
if [ "${NEW_SRV_IP}" != "${OLD_SRV_IP}" ]; then
    $ECHO "Alias IP Address : \t$NEW_SRV_IP" >> ${TEM_DIR}/disp_file
    _update_=1
fi

$ECHO "Alias :\t\t\t${OSS_NAME}\n" >> ${TEM_DIR}/disp_file
if [ -s ${ENIQ_CORE_ETC_DIR}/feature_output_list_${OSS_NAME} ]; then
    $ECHO "ENIQ Features" >> ${TEM_DIR}/disp_file
    $ECHO "--------------" >> ${TEM_DIR}/disp_file
    $CAT ${TEM_DIR}/feature_output_list_add_feature |$AWK -F"::" '{print $2}' >> ${TEM_DIR}/disp_file
    $ECHO "\n\nDo you wish to continue to update the system" >> ${TEM_DIR}/disp_file
    $ECHO "with the features above (Yy/Nn)\n" >> ${TEM_DIR}/disp_file
    _update_=1
else
    $ECHO "\n\nDo you wish to continue to update the OSS Server details (Yy/Nn)\n" >> ${TEM_DIR}/disp_file
fi

# If there is nothing to upgrade then delete the disp file
if [ ${_update_} -eq 0 ]; then
    $RM -f ${TEM_DIR}/disp_file
fi
}
### Function: confirm_user_input ###
#
# Confirm with user that values entered are correct
#
# Arguments:
#       none
# Return Values:
#       none
confirm_user_input()
{
while :; do
    $CLEAR
    
    $CAT ${1}
    read USER_CONF

    # If the User hit nothing
    if [ ! "${USER_CONF}" ]; then
        continue
    fi

    # Did the user input (Y/y)
    if [ "${USER_CONF}" == "Y" -o "${USER_CONF}" == "y" -o "${USER_CONF}" == "N" -o "${USER_CONF}" == "n" ]; then
        break
    fi
done
}

### Function: user_confirmation_add_features ###               
#
# Get confirmation from user to proceed with the execution of script
#
# Arguments:
#       none
# Return Values:
#       none
user_confirmation_add_features()
{
while :; do
    unset USER_CONF
    $CLEAR
    $ECHO "\nDo you wish to add new features to the server?"

    $ECHO "Enter [Yes|No] (case sensitive) : \c"
    read USER_CONF

    # If the User hit nothing
    if [ ! "${USER_CONF}" ]; then
        continue
    fi
        
    if [ "${USER_CONF}" == "Yes" -o "${USER_CONF}" == "No" ]; then
       break
    fi
done
}

### Function: encrypt_user_passwords ###
#
# To encrypt the user passwords before storing
#
# Arguments:
#       none
# Return Values:
#       none
encrypt_user_passwords()
{
if [[ $flag == 'No' ]]; then
insert_header_footer head "Entering ${ACTION_TYPE} stage - ${NEXT_STAGE}" ${LOGFILE}

$BASH /eniq/admin/bin/encrypt_user_passwords.bsh

if [ $? -ne 0 ]; then
	_err_msg_=" Failed to encrypt password."
	abort_script "$_err_msg_"
fi

insert_header_footer foot "Successfully Completed ${NEXT_STAGE}.  " ${LOGFILE}
fi
set_next_stage `$EXPR ${ARRAY_ELEM}+1`

}


### Function: delta_dbcheck ###
#
# To perform delta check on the database tables
#
# Arguments:
#       none
# Return Values:
#       none
delta_dbcheck()
{
if [[ $flag == 'No' ]]; then
insert_header_footer head "Entering ${ACTION_TYPE} stage - ${NEXT_STAGE}" ${LOGFILE}

$BASH /eniq/admin/bin/DbCheck.bsh -a verify_tables

if [ $? -ne 0 ]; then
	_err_msg_=" Failed to Complete delta DBcheck."
	abort_script "$_err_msg_"
fi

insert_header_footer foot "Successfully Completed ${NEXT_STAGE}.  " ${LOGFILE}
fi
set_next_stage `$EXPR ${ARRAY_ELEM}+1`

}


### Function: manage_ombs_policies ###
#
# To enable OMBS policies is server is configured
#
# Arguments:
#       none
# Return Values:
#       none
manage_ombs_policies()
{

if [[ $flag == 'No' ]]; then

	insert_header_footer head "Entering ${ACTION_TYPE} stage - ${NEXT_STAGE}" ${LOGFILE}

	ENIQ_CONF_PATH='/eniq/installation/config'

	CURR_SERVER_TYPE=`$CAT /eniq/installation/config/installed_server_type | $EGREP -v '^[[:blank:]]*#' | $SED -e 's/ //g'`
	
	i=1

	ombs_choice=`iniget inputs -f ${ENIQ_CONF_DIR}/upgrade_params.ini -v ombs_configuration`
	ombs_policies=`iniget inputs -f ${ENIQ_CONF_DIR}/upgrade_params.ini -v ombs_policies_configuration`
	ombs_action_type=`iniget inputs -f ${ENIQ_CONF_DIR}/upgrade_params.ini -v ombs_action_type`
	upg_sw_dir=`iniget inputs -f ${ENIQ_CONF_DIR}/upgrade_params.ini -v upg_sw_dir`
	
	if [[ "${ACTION_TYPE}" == "rollback" || "${ACTION_TYPE}" == "rollback_platform_only" ]]; then		
		ENIQ_INST_PATH=/var/tmp/upgrade/${upg_sw_dir}/core_install/bin
	else
		ENIQ_INST_PATH='/eniq/installation/core_install/bin'
	fi

	if [[ "${ACTION_TYPE}" == "rollback" || "${ACTION_TYPE}" == "rollback_platform_only" || "${ACTION_TYPE}" == "rollback_feature_only" ]]; then
		ENIQ_CONF_PATH='/var/tmp'
	else
		ENIQ_CONF_PATH='/eniq/installation/config'
	fi
	script=${ENIQ_INST_PATH}/manage_ombs_policies.bsh
        if [[ ! ${script} ]]; then
          ENIQ_INST_PATH=/var/tmp/upgrade/$upg_sw_dir/core_install/bin/manage_ombs_policies.bsh
          if [[ ! ${script} ]]; then
                  $ECHO "Failed to find manage_ombs_policies.bsh file." | $TEE -a ${LOGFILE}
          fi
	fi

	
	if [[ $ombs_choice == 'Yes' && $ombs_policies == 'No' ]]; then

		if [[ $ombs_action_type == 'disable' ]]; then
		
			$ECHO "\nStarting to Enable OMBS Policies\n" | $TEE -a ${LOGFILE}

			ombs_pass=`iniget inputs -f ${ENIQ_CONF_DIR}/upgrade_params.ini -v ombs_pass`
			ombs_uname=`iniget inputs -f ${ENIQ_CONF_DIR}/upgrade_params.ini -v ombs_uname`
			ombs_host_name=`iniget inputs -f ${ENIQ_CONF_DIR}/upgrade_params.ini -v ombs_backup_ip`

			#ombs_pass=`$ECHO $ombs_pass | openssl enc -base64 -d`
                        passphrase=`$CAT /eniq/sw/conf/strong_passphrase`
                        ombs_pass=`$ECHO $ombs_pass | openssl enc -aes-256-ctr -md sha512 -a -d -salt -pass pass:${passphrase}`

			ombs_action_type='enable'

			if [ "${CURR_SERVER_TYPE}" == "stats_coordinator" ]; then

					$CAT ${ENIQ_CONF_DIR}/upgrade_params.ini | $GREP "eniq_mb*" | $SED 's/=/ /g' | $AWK '{print $2}' > hostnames.txt

					while [[ $i -le 4 ]]
					do
						eniq_hostname=`$CAT hostnames.txt | head -n $i | tail -n 1`
						
							
								$CP -rp ${ENIQ_INST_PATH}/manage_ombs_policies.bsh ${ENIQ_INST_PATH}/manage_ombs_policies_bkp.bsh
								$ECHO "eniq_hostname=$eniq_hostname" >> tmp.txt
								$CAT ${ENIQ_INST_PATH}/manage_ombs_policies.bsh |  $SED -e 's/action_type=disable/action_type=enable/g' >> tmp.txt
								$CP -rp tmp.txt ${ENIQ_INST_PATH}/manage_ombs_policies.bsh
								$RM -rf tmp.txt
								
								CMD="ssh -o StrictHostKeyChecking=no  ${ombs_uname}\@${ombs_host_name} "

						/usr/bin/expect<<END
							set force_conservative 0
							spawn bash  -c "${CMD} ${SUDO} su - root -- -c /bin/bash < ${script} "
							expect  "* password: "
							send -- "${ombs_pass}\r"
							expect  "*$*"
							expect eof
							
END

				if [ $? -eq 0 ]; then
					ombs_action_type='enable'
					iniset inputs -f ${ENIQ_CONF_DIR}/upgrade_params.ini -v ombs_action_type=$ombs_action_type
					if [[ $? -ne 0 ]];then
						$ECHO "Could not set action_type value in ini file." | $TEE -a ${LOGFILE}
					fi
				fi


				$CP -rp ${ENIQ_INST_PATH}/manage_ombs_policies_bkp.bsh ${ENIQ_INST_PATH}/manage_ombs_policies.bsh
				
			i=`$EXPR $i + 1`
			done
				
			$RM -rf hostname.txt


			elif [ "${CURR_SERVER_TYPE}" == "eniq_stats" ]; then

				eniq_hostname=`iniget inputs -f ${ENIQ_CONF_DIR}/upgrade_params.ini -v eniq_hostname`
				
				

						$CP -rp ${ENIQ_INST_PATH}/manage_ombs_policies.bsh ${ENIQ_INST_PATH}/manage_ombs_policies_bkp.bsh
						$ECHO "eniq_hostname=$eniq_hostname" >> tmp.txt
						$CAT ${ENIQ_INST_PATH}/manage_ombs_policies.bsh |  $SED -e 's/action_type=disable/action_type=enable/g' >> tmp.txt
						$CP -rp tmp.txt ${ENIQ_INST_PATH}/manage_ombs_policies.bsh
						$RM -rf tmp.txt


						CMD="ssh -o StrictHostKeyChecking=no  ${ombs_uname}\@${ombs_host_name} "

				/usr/bin/expect<<END
				set force_conservative 0
				spawn bash  -c "${CMD} ${SUDO} su - root -- -c /bin/bash < ${script} "
				expect  "* password: "
				send -- "${ombs_pass}\r"
				expect  "*$*"
				expect eof

END

			if [ $? -eq 0 ]; then
				ombs_action_type='enable'
				iniset inputs -f ${ENIQ_CONF_DIR}/upgrade_params.ini -v ombs_action_type=$ombs_action_type
				if [[ $? -ne 0 ]];then
					$ECHO "\nCould not set action_type value in ini file." | $TEE -a ${LOGFILE}
				fi
			fi

			$CP -rp ${ENIQ_INST_PATH}/manage_ombs_policies_bkp.bsh ${ENIQ_INST_PATH}/manage_ombs_policies.bsh

		
			
			fi
		
		else 
			$ECHO "\nSkipping this stage as Policies not disabled during pre-upgrade" | $TEE -a ${LOGFILE}
		fi
	elif [[ $ombs_choice == 'Yes' && $ombs_policies == 'Yes' ]]; then
		$ECHO "Skipping this stage as OMBS policies are disabled manually" | $TEE -a ${LOGFILE}
	else
		$ECHO "Skipping this stage as OMBS Server not Configured" | $TEE -a ${LOGFILE}
	fi

	$RM -rf ${ENIQ_INST_PATH}/manage_ombs_policies_bkp.bsh

insert_header_footer foot " Succesfully completed ${NEXT_STAGE} stage  " ${LOGFILE}
fi
set_next_stage `$EXPR ${ARRAY_ELEM}+1`

}



### Function: remove_snapshots ###
#
# To Remove the LV snapshots
#
# Arguments:
#       none
# Return Values:
#       none

remove_snapshots()
{
if [[ $flag == 'No' ]]; then

insert_header_footer head "Entering ${ACTION_TYPE} stage - ${NEXT_STAGE}" ${LOGFILE}

GET_IP_ORDER_SCRIPT=/eniq/installation/core_install/lib/get_ip_order.pl
ENIQ_CONF_DIR=/eniq/installation/config

OM_SW_DIR=`iniget inputs -v om_sw -f $ENIQ_CONF_DIR/upgrade_params.ini`
if [ ! "${OM_SW_DIR}" ]; then
    _err_msg_="Could not determine OM SW DIR from $ENIQ_CONF_DIR/upgrade_params.ini"
    abort_script "$_err_msg_"
fi

HOST_IP=`$MYHOSTNAME -i | $AWK '{print $1}' | $HEAD -1`
#Calling the INFRA script to remove the LV snapshots
$ECHO "Removing Snapshots from ${HOST_IP}" | $TEE -a ${LOGFILE}
$PYTHON ${OM_SW_DIR}/om_linux/patch/bin/snapshot_deletion.py
if [ $? -ne 0 ]; then
        _err_msg_="Failed executing ${OM_SW_DIR}/om_linux/patch/bin/snapshot_deletion.py script. "
        abort_script "$_err_msg_"
else
	$ECHO "Successfully removed Snapshots from ${HOST_IP}" | $TEE -a ${LOGFILE}
fi
CURR_SERVER_TYPE=`$CAT $ENIQ_CONF_DIR/installed_server_type | $EGREP -v '^[[:blank:]]*#' | $SED -e 's/ //g'`

if [ "${CURR_SERVER_TYPE}" == "stats_coordinator" ]; then
        $PERL ${GET_IP_ORDER_SCRIPT} -f ${TMP_DIR}/server_order_list
        for _line_ in `$CAT ${TMP_DIR}/server_order_list`;
        do
			unset _server_ _serv_hostname_ _count_
			local _server_ _serv_hostname_ _count_
			_count_=`$ECHO "${_line_}" | grep -o "::" | wc -l`

			if [ "${_ip_type_}" == "IPv6" ] && [ "${_count_}" == 3 ]; then
				_server_=`$ECHO ${_line_} | grep -oE '([a-fA-F0-9]{1,4}::?){1,7}[a-fA-F0-9]{1,4}' | head -n 1 | awk -F "::" '{ print $1 "::" 	$2}'`
				_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $3}'`
			else
				_server_=`$ECHO ${_line_} | $AWK -F"::" '{print $1}'`
				_serv_hostname_=`$ECHO ${_line_} | $AWK -F"::" '{print $2}'`
			fi
                if [ "${_server_}" == "${HOST_IP}" ]; then
                        continue
                fi
		$ECHO "Removing Snapshots from ${_server_}" | $TEE -a ${LOGFILE}
		#Calling the INFRA script to remove the LV snapshots
                snapshot_deletion="$PYTHON ${OM_SW_DIR}/om_linux/patch/bin/snapshot_deletion.py"
                run_remote_cmd ${_serv_hostname_} "${snapshot_deletion}"
		$ECHO "Successfuly removed Snapshots from ${_server_}" | $TEE -a ${LOGFILE}
        done
fi
insert_header_footer foot " Succesfully completed ${NEXT_STAGE} stage  " ${LOGFILE}
fi
set_next_stage `$EXPR ${ARRAY_ELEM}+1`
}



#********************************************************************
#
#       Main body of program
#
#********************************************************************
RUNTIME=`$DATE '+%Y-%b-%d'`

################################################################
# NOTE : Option q is only for non FT deployments i.e. VM or VAPP
################################################################

while getopts ":D:P:l:nO:M:qs:A:f:u" arg; do
  case $arg in
    A) ACTION="$OPTARG"
       ;;
    D) BASE_SW="$OPTARG"
       ;;
    O) OM_SW="$OPTARG"
       ;;
    M) SOL_OM_MEDIA_LOCATION="$OPTARG"
       ;;    
    P) UPG_SW="$OPTARG"
       ;;
    s) USER_STAGE="$OPTARG"
       ;;
    l) LOGFILE="$OPTARG"
       ;;
    n) NO_RESET_STAGE="YES"
       ;;
    q) STAGE_QUIET="YES"
       ;;
    f) FEATURE_SW="$OPTARG"
       ;;        
    u) ADMIN_UI="YES"
       ;;
   \?) usage_msg
       exit 1
       ;;
  esac
done
shift `expr $OPTIND - 1`

# Check that the effective id of the user is root
check_user_id 

#Check current path
$ECHO "Checking current path. Please wait"
sleep 2

_curr_dir_=$(pwd)

if [ "${ACTION}" == "rollback" ]; then
    if [[ "${_curr_dir_}" =~ ^/eniq.* ]]; then
        $ECHO -e "\nYour current directory is $_curr_dir_. Please change to /. \n"
        exit 0
    fi
fi

$ECHO -e "\nScript has been started.\n"

. /eniq/admin/lib/common_functions.lib

flag='No'

ENIQ_CONF_DIR=/eniq/installation/config
VAR_TMP_DIR='/var/tmp'
file="${VAR_TMP_DIR}/inputs_err_file_.txt"

if [ -e "${file}" ]; then
	$RM -rf ${file}
	if [ $? -ne 0 ]; then
		_err_msg_="could not remove the file ${file}"
		abort_script "$_err_msg_"
	fi
fi

$TOUCH ${VAR_TMP_DIR}/inputs_err_file_.txt

if [ ! -f /eniq/sw/conf/strong_passphrase ]; then
    host_name=`hostname`
    touch /eniq/sw/conf/strong_passphrase
    chmod 600 /eniq/sw/conf/strong_passphrase
    chown dcuser:dc5000 /eniq/sw/conf/strong_passphrase
    echo "${host_name}@EnIq" >/eniq/sw/conf/strong_passphrase
 fi

if [[ ! $ACTION ]]; then
	ACTION_TYPE=`iniget inputs -v action_type_upgrade -f ${ENIQ_CONF_DIR}/upgrade_params.ini`
	if [ ! "${ACTION_TYPE}" ]; then
		$ECHO "Could not determine ACTION TYPE from $ENIQ_CONF_DIR/upgrade_params.ini" >> ${file}
	fi
else
	ACTION_TYPE=$ACTION
        flag='Yes'
fi

if [ "${ACTION_TYPE}" == "post_upgrade_platform_only" -o "${ACTION_TYPE}" == "post_upgrade" ]; then
if [[ ! $BASE_SW ]]; then
	BASE_SW_DIR=`iniget inputs -v eniq_base_sw -f $ENIQ_CONF_DIR/upgrade_params.ini`
	if [ ! "${BASE_SW_DIR}" ]; then
		_err_msg_="Could not determine BASE SW DIR from $ENIQ_CONF_DIR/upgrade_params.ini"
        abort_script "$_err_msg_"
	fi
	flag='No'
else
	BASE_SW_DIR=$BASE_SW
	flag='Yes'
fi
fi

if [ "${ACTION_TYPE}" == "rollback_feature_only" -o "${ACTION_TYPE}" == "rollback_platform_only" -o "${ACTION_TYPE}" == "rollback" ]; then

	$CP -rp /eniq/installation/config/upgrade_params.ini /var/tmp/upgrade_params.ini
	if [ $? -ne 0 ]; then
		echo "Could not backup upgrade_params.ini script"
	fi
	if [[ ! $UPG_SW ]]; then
		UPG_SW_DIR=`iniget inputs -v upg_sw_dir -f $ENIQ_CONF_DIR/upgrade_params.ini`
		if [ ! "${UPG_SW_DIR}" ]; then
			_err_msg_="Could not determine UPG SW DIR from $ENIQ_CONF_DIR/upgrade_params.ini"
			abort_script "$_err_msg_"
		fi
			flag='No'
	else
		UPG_SW_DIR=$UPG_SW
			flag='Yes'
		
	fi
fi
if [ "${ACTION_TYPE}" == "upgrade_platform_only" -o "${ACTION_TYPE}" == "upgrade_feature_only" -o "${ACTION_TYPE}" == "upgrade" ]; then
if [[ $flag == 'No' ]]; then

	BASE_SW_DIR=`iniget inputs -v eniq_base_sw -f $ENIQ_CONF_DIR/upgrade_params.ini`
		if [ ! "${BASE_SW_DIR}" ]; then
			$ECHO "Could not determine BASE SW DIR from $ENIQ_CONF_DIR/upgrade_params.ini" >> ${file}
		fi
    OM_SW_DIR=`iniget inputs -v om_sw -f $ENIQ_CONF_DIR/upgrade_params.ini`
		if [ ! "${OM_SW_DIR}" ]; then
			$ECHO "Could not determine OM SW DIR from $ENIQ_CONF_DIR/upgrade_params.ini" >> ${file}
		fi

	FEATURE_SW_DIR=`iniget inputs -v eniq_feature_sw -f $ENIQ_CONF_DIR/upgrade_params.ini`
		if [ ! "${FEATURE_SW_DIR}" ]; then
			$ECHO "Could not determine FEATURE SW DIR from $ENIQ_CONF_DIR/upgrade_params.ini" >> ${file}
		fi

	UPG_SW_DIR=`iniget inputs -v upg_sw_dir -f $ENIQ_CONF_DIR/upgrade_params.ini`
		if [ ! "${UPG_SW_DIR}" ]; then
			$ECHO "Could not determine UPG SW DIR from $ENIQ_CONF_DIR/upgrade_params.ini" >> ${file}
		fi

elif [[ $flag == 'Yes' ]]; then
	BASE_SW_DIR=$BASE_SW
    OM_SW_DIR=$OM_SW
	FEATURE_SW_DIR=$FEATURE_SW
	UPG_SW_DIR=$UPG_SW
fi

if [ "${ACTION_TYPE}" == "upgrade" ]; then
	if [ ! "${ACTION_TYPE}" -o ! "${BASE_SW_DIR}" -o ! "${OM_SW_DIR}" -o ! "${FEATURE_SW_DIR}" -o ! "${UPG_SW_DIR}" ]; then
		_err_msg_=$($CAT "${file}")
		abort_script "$_err_msg_"
	fi
elif [ "${ACTION_TYPE}" == "upgrade_platform_only" ]; then
	if [ ! "${ACTION_TYPE}" -o ! "${BASE_SW_DIR}" -o ! "${OM_SW_DIR}" -o ! "${UPG_SW_DIR}" ]; then
		_err_msg_=$($CAT "${file}")
		abort_script "$_err_msg_"
	fi
else
	if [ ! "${ACTION_TYPE}" -o ! "${FEATURE_SW_DIR}" ]; then
		_err_msg_=$($CAT "${file}")
		abort_script "$_err_msg_"
	fi
fi
fi


# Check if post_restore is ongoing
if [ -f "/var/tmp/post_restore_in_progress" ]; then
    $ECHO "\nOMBS post restore is in progress. Cannot proceed with upgrade!"
    exit 1
fi



# Check that the script is run on Coordinator
check_server

# Multiple instances of the same script should not run in parallel.
check_multiple_instances

# Check input parameters
check_params

# File to hold current Upgrade stage information
if [ "${ACTION_TYPE}" == "rollback_feature_only" -o "${ACTION_TYPE}" == "rollback_platform_only" -o "${ACTION_TYPE}" == "rollback" ]; then
    STAGEFILE=${VAR_TMP_DIR}/current_${ACTION_TYPE}_stage
else
    STAGEFILE=${ENIQ_CORE_INST_DIR}/etc/current_${ACTION_TYPE}_stage    
fi

# Determine absolute path to software
check_absolute_path

post_upgrade_type_flag=0
rollback_type_flag=0

# Refer to the post_upgrade stagelist in case of post feature only upgrade and post platform only upgrade 
if [ "${ACTION_TYPE}" == "post_upgrade_feature_only" ]; then
        post_upgrade_type_flag=1
        ACTION_TYPE="post_upgrade"

elif [ "${ACTION_TYPE}" == "post_upgrade_platform_only" ]; then    
        post_upgrade_type_flag=2
        ACTION_TYPE="post_upgrade"
fi

# Refer to the rollback stagelist in case of rollback for feature only upgrade and rollback for platform only upgrade 
if [ "${ACTION_TYPE}" == "rollback_feature_only" ]; then
        rollback_type_flag=1
        ACTION_TYPE="rollback"

elif [ "${ACTION_TYPE}" == "rollback_platform_only" ]; then    
        rollback_type_flag=2
        ACTION_TYPE="rollback"
fi

# Set Variables
setup_env

# Store upgrade input parameters
store_params

# Run the post upgrade steps on all the blades 
if [ "${ACTION_TYPE}" == "post_upgrade" -a ! "${ADMIN_UI}" ] ; then
    user_confirmation 
    if [ "$USER_CONF" == "No" ]; then
        exit 0
    fi
fi

# Default Log file
if [ ! "${LOGFILE}" ]; then
    $MKDIR -p ${ENIQ_LOG_DIR}/${ACTION_TYPE}
    LOGFILE="${ENIQ_LOG_DIR}/${ACTION_TYPE}/${RUNTIME}_${ACTION_TYPE}_eniq_sw.log"
fi

# If log file doesn't exist, create log file
if [ ! -f "${LOGFILE}" ]; then
    $TOUCH ${LOGFILE}
    if [ $? -ne 0 ]; then
        _err_msg_="Could not make log file"
        abort_script "$_err_msg_"
    fi

    $ECHO "Changing permission of the ${LOGFILE} to 644" | $TEE -a ${LOGFILE}
    $CHMOD 644 ${LOGFILE}
    if [ $? -ne 0 ]; then
        _err_msg_="Could not change ${LOGFILE} file permissions to 644"
        abort_script "$_err_msg_"
    fi
fi

# Run the clean-up script of Admin-UI related clean-up 
if [ "${ACTION_TYPE}" == "upgrade_feature_only" ]; then
    cleanup_admin_ui -update
elif [ "${post_upgrade_type_flag}" == "1" -o "${rollback_type_flag}" == "1" ]; then
    cleanup_admin_ui -postupdate
fi

# Remove the current stage file for feature only upgrade/post_upgrade/rollback for the last run
cleanup_feature_only

# File to hold current stage information for Admin-UI 
if [ "${ADMIN_UI}" == "YES" ]; then
    STAGEFILE_ADMIN_UI=${VAR_TMP_DIR}/current_${ACTION_TYPE}_ui_stage
    $RM -rf ${STAGEFILE_ADMIN_UI}
    $TOUCH ${STAGEFILE_ADMIN_UI}
fi

log_msg -t -h -s "Starting ${ACTION_TYPE} Procedure" -l ${LOGFILE}

# Create a temporary Directory
TEM_DIR=/tmp/upgrade.$$.$$
if [ -d ${TEM_DIR} ]; then
    $RM -rf ${TEM_DIR}
    if [ $? -ne 0 ]; then
        _err_msg_="Could not delete directory $TEM_DIR. Please delete it manually." 
        abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
    fi
fi

$MKDIR -p ${TEM_DIR}
if [ $? -ne 0 ]; then
    _err_msg_="Could not create directory $TEM_DIR"
    abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
fi

if [ -s ${CLI_CONF_DIR}/${ENIQ_INI} ]; then
    $CP ${CLI_CONF_DIR}/${ENIQ_INI} ${TEM_DIR}/${ENIQ_INI}
    if [ $? -ne 0 ]; then
        _err_msg_="Could not copy ${CLI_CONF_DIR}/${ENIQ_INI} to ${TEM_DIR}/${ENIQ_INI}"
        abort_script "$_err_msg_"
    fi
fi

if [[ $flag == 'Yes' ]]; then
if [ ! "${ADMIN_UI}" ]; then
    if [ "${ACTION_TYPE}" == "upgrade" -o "${ACTION_TYPE}" == "upgrade_feature_only" ]; then
        if [ ! "${USER_STAGE}" -a ! -s ${STAGEFILE} ]; then
            list_features
            user_confirmation_add_features
            if [ "${USER_CONF}" == "Yes" ]; then
                $ECHO "\nOSS connected to this server are:" | $TEE -a ${LOGFILE}
                $CAT ${OSS_REF_NAME_FILE} | $AWK -F" " '{print $1}' | $TEE -a ${LOGFILE}
                $ECHO "\nDisplaying the list of features for each connected oss \n"            
                for _oss_name_ in `$CAT ${OSS_REF_NAME_FILE} | $AWK -F" " '{print $1}'`; do
                    $ECHO "\nPlease enter your choice for ${_oss_name_}   \n"
                    add_features_list ${_oss_name_}
                done
            fi
        elif [ "${USER_STAGE}" == "feature_upgrade" ]; then
            list_features
        elif [ "${USER_STAGE}" == "add_new_features" ]; then
            $ECHO "\nOSS connected to this server are:" | $TEE -a ${LOGFILE}
            $CAT ${OSS_REF_NAME_FILE} | $AWK -F" " '{print $1}' | $TEE -a ${LOGFILE}
            $ECHO "\nDisplaying the list of features for each connected oss" 
            for _oss_name_ in `$CAT ${OSS_REF_NAME_FILE} | $AWK -F" " '{print $1}'`; do
                $ECHO "\nPlease enter your choice for ${_oss_name_}"
                add_features_list ${_oss_name_}
            done
        fi
    fi
fi
fi

# Get an ordered list of servers based on the server_list file:
_deployed_servers_="${TEM_DIR}/deployed_servers.$$.tmp"
$PERL ${GET_IP_ORDER_SCRIPT} -f ${_deployed_servers_}

# To Create backup of ENIQ_CORE_INST_DIR for Rollback in case of upgrade_feature_only
if [ "${ACTION_TYPE}" == "upgrade_feature_only" ]; then
    get_rollback_backup
fi

# Create the current stage file to hold the current stage of add new features. 
if [ "${ADMIN_UI}" == "YES" -a "${ACTION_TYPE}" == "upgrade_feature_only" ]; then
    STAGEFILE_ADD_FEATURE_ADMIN_UI=${VAR_TMP_DIR}/current_add_features_ui_stage
    $LS -l ${ENIQ_CORE_ETC_DIR}/feature_output_list_eniq_oss_* >> /dev/null 2>&1
    if [ $? -eq 0 ]; then
        $RM -rf ${STAGEFILE_ADD_FEATURE_ADMIN_UI}
        $RM -rf ${STAGEFILE_ADMIN_UI}
        $TOUCH ${STAGEFILE_ADD_FEATURE_ADMIN_UI}
    fi
fi

# Read storage type
read_storage_type

#Copy fls_conf file to reader server for merging oss entry
if [ "${CURR_SERVER_TYPE}" == "stats_coordinator" ]; then
    if [ -s ${ENIQ_CONF_DIR}/fls_conf ]; then
        if [ "${ACTION_TYPE}" == "upgrade" -o "${ACTION_TYPE}" == "upgrade_platform_only" ]; then
            copy_fls_file
        fi
    fi
fi

# Create a stage array
if [ "${ACTION_TYPE}" == "upgrade" -o "${ACTION_TYPE}" == "upgrade_platform_only" ]; then   
    core_install_build_stage_array ${LOGFILE} ${TEM_DIR} eniq ${ACTION_TYPE} ${TEMP_CORE_SW_UPG_DIR}
    if [ $? -ne 0 ]; then
        _err_msg_="Could not build a stage array for ${ACTION_TYPE}"
        abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
    fi
else
    core_install_build_stage_array ${LOGFILE} ${TEM_DIR} eniq ${ACTION_TYPE} ${ENIQ_CORE_INST_DIR}
    if [ $? -ne 0 ]; then
        _err_msg_="Could not build a stage array for ${ACTION_TYPE}"
        abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
    fi
fi

# If stage specified, make sure it is in the stage list for this server type


if [ "$USER_STAGE" ]; then
    core_install_check_user_stage ${LOGFILE} ${TEM_DIR} ${USER_STAGE}
    if [ $? -ne 0 ]; then
       _err_msg_="The specified stage ${USER_STAGE} is not in the stage list for upgrade"
       abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
    fi
fi

if [ "$USER_STAGE" ]; then
    NEXT_STAGE="${USER_STAGE}"
    # Get the element number so we can move along the array
    get_array_element
else
    get_next_stage
fi

# If we read cleanup from the stagefile
if [ "$NEXT_STAGE" == "cleanup" ]; then
    # We exit unless the user specified that the stage be run again
    if [ ! "$USER_STAGE" ]; then
        log_msg -s "All Stages are already completed" -l ${LOGFILE}
        exit 0
    fi
fi

if [ ! "${USER_STAGE}" ]; then
    if [ "${ACTION_TYPE}" == "upgrade_feature_only" ]; then
        if [ ! -s "${ENIQ_CORE_ETC_DIR}/features_to_be_managed" ]; then
            $LS -l ${ENIQ_CORE_ETC_DIR}/feature_output_list_eniq_oss_* >> /dev/null 2>&1
            if [ $? -ne 0 ]; then 
                log_msg -s "\nExiting...No feature has been selected for upgrade or addition\n" -l ${LOGFILE}
                exit 0
            fi
        fi
    fi
fi

# Loop through the stages for upgrade 
while :; do
    _nxt_stage_="${NEXT_STAGE}"
    $_nxt_stage_
    if [ $? -ne 0 ]; then
        _err_msg_="Error in Stage ${NEXT_STAGE}"
        abort_script "${_err_msg_}" "${EXEC_SHELL_CMD}"
    fi

    # Exit if the user specified to run a specific stage only
    if [ "$USER_STAGE" ]; then
        break
    fi

    # If we read cleanup from the stagefile
    if [ "$NEXT_STAGE" == "cleanup" ]; then
        break
    fi
    
    get_next_stage
done

$RM -rf ${TEM_DIR}
log_msg -t -h -s "Completed ${ACTION_TYPE} Procedure" -l ${LOGFILE}
exit 0

